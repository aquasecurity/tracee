{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>\ud83d\udc4b Welcome to Tracee Documentation! To help you get around, please notice the different sections at the top global menu:</p> <ul> <li>You are currently in the Getting Started section where you can find general information and help with first steps.</li> <li>In the Tutorials section you can find step-by-step guides that help you accomplish specific tasks.</li> <li>In the Docs section you can find the complete reference documentation for all of the different features and settings that Tracee has to offer.</li> <li>In the Contributing section you can find technical developer documentation and contribution guidelines.</li> </ul> <p>Before moving on, please consider giving us a GitHub star \u2b50\ufe0f. Thank you!</p>"},{"location":"#about-tracee","title":"About Tracee","text":"<p>Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. It is using eBPF technology to tap into your system and expose that information as events that you can consume. Events range from factual system activity events to sophisticated security events that detect suspicious behavioral patterns.</p> <p>To learn more about Tracee, check out the documentation. </p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To quickly try Tracee use one of the following snippets. For a more complete installation guide, check out the Installation section. Tracee should run on most common Linux distributions and kernels. For compatibility information see the Prerequisites page. Mac users, please read this FAQ.</p>"},{"location":"#using-docker","title":"Using Docker","text":"<pre><code>docker run --name tracee -it --rm \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  -v /var/run:/var/run:ro \\\n  aquasec/tracee:latest\n</code></pre> <p>For a complete walkthrough please see the Docker getting started guide.</p>"},{"location":"#on-kubernetes","title":"On Kubernetes","text":"<pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\nhelm repo update\nhelm install tracee aqua/tracee --namespace tracee --create-namespace\n</code></pre> <pre><code>kubectl logs --follow --namespace tracee daemonset/tracee\n</code></pre> <p>For a complete walkthrough please see the Kubernetes getting started guide.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Join the community, and talk to us about any matter in the GitHub Discussions or Slack. If you run into any trouble using Tracee or you would like to give use user feedback, please create an issue.</p> <p>Find more information on contribution documentation.</p>"},{"location":"#more-about-aqua-security","title":"More about Aqua Security","text":"<p>Tracee is an Aqua Security open source project. Learn about our open source work and portfolio here.</p>"},{"location":"contributing/documentation/","title":"Contributing to the documentation","text":"<p>We welcome contributions to the Tracee documentation.</p> <p>Our documentation aims to follow the Di\u00e1taxis documentation framework which includes:</p> <ol> <li>A getting started section -- Installation Guidelines and simple scenarios</li> <li>Tutorials -- End-to-end tutorials that have real-world use cases</li> <li>Reference Material -- How to use Tracee</li> <li>Contribution Guidelines</li> </ol> <p>To contribute to the documentation please</p> <ol> <li>Clone the Tracee GitHub repository</li> <li>Make changes in the <code>./docs</code> directory in the root folder</li> <li>Remember to edit the index in <code>mkdocs.yml</code> in the root folder if you add or move existing files or directories</li> <li>Test your changes to the documentation</li> <li>Submit a PR</li> </ol>"},{"location":"contributing/documentation/#test-documentation-changes","title":"Test Documentation Changes","text":"<p>You can test your changes to the documentation by building and running a docker container.</p> <p>Prerequisites: Docker installed and running locally.</p> <p>Build the container image: <pre><code>make -f ./builder/Makefile.mkdocs mkdocs-build\n</code></pre></p> <p>Serve the container image: <pre><code>make -f ./builder/Makefile.mkdocs mkdocs-serve\n</code></pre></p> <p>Open <code>localhost:8000/tracee</code></p> <p>Now you should see the documentation.</p>"},{"location":"contributing/guidelines/","title":"Source Code Guidelines","text":""},{"location":"contributing/guidelines/#style-guide-for-contributors","title":"Style Guide for Contributors","text":"<p>For those willing to contribute to Tracee, this repository has code formatting guidelines being enforced. It is recommended that, before committing your changes, you run the following command:</p> <ol> <li>Check for formatting issues</li> </ol> <p>Check-fmt</p> <pre><code>make check-fmt\n</code></pre> <pre><code>Checking C and eBPF files and headers formatting...\nChecking golang files formatting...\n</code></pre> <p>This will make sure PRs won't fail due to same checks being enforced.</p> <ol> <li>Fix Go and C source files formatting</li> </ol> <p>Fix-fmt</p> <pre><code>make fix-fmt\n</code></pre> <pre><code>Fixing C and eBPF files and headers formatting...\nFormatting ./pkg/ebpf/c/missing_definitions.h\nFormatting ./pkg/ebpf/c/struct_flavors.h\nFormatting ./pkg/ebpf/c/tracee.bpf.c\nFormatting ./pkg/ebpf/c/vmlinux.h\n\nFixing golang files formatting...\npatching file pkg/ebpf/tracee.go\n</code></pre> <pre><code>git status -s\n</code></pre> <pre><code> M Makefile\n M builder/Makefile.checkers\n M pkg/ebpf/c/missing_definitions.h\n M pkg/ebpf/c/struct_flavors.h\n M pkg/ebpf/c/tracee.bpf.c\n M pkg/ebpf/c/vmlinux.h\n</code></pre> <ol> <li>Static Check Go and C source files</li> </ol> <p>Check-code</p> <pre><code>make check-code\n</code></pre> <pre><code>Checking Golang vet...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\ngo vet \\\n    -tags core,ebpf \\\n    ./...\n\nChecking Golang with StaticChecker...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\nstaticcheck -f stylish \\\n    -tags core,ebpf \\\n    ./...\n \u2716 0 problems (0 errors, 0 warnings, 0 ignored)\n\n Checking Golang with errcheck...\n</code></pre>"},{"location":"contributing/overview/","title":"Overview","text":""},{"location":"contributing/overview/#contributing","title":"Contributing","text":"<p>Thank you for taking interest in contributing to Tracee! This document covers our working practices and conventions.</p>"},{"location":"contributing/overview/#issues-and-discussions","title":"Issues and Discussions","text":"<p>We encourage open discussion and collaboration using both GitHub Issues and Discussions.  </p> <ul> <li>Discussions are free-style conversational tool, we use them for conversations.</li> <li>Issues are project management tool, we use them to keep track on who's working on what and plan ahead.</li> </ul> <p>If you have a suggestion, question, or a general comment - please use Discussions. If there's a clear work item (including bugs) - you can open an Issue.</p>"},{"location":"contributing/overview/#discussions","title":"Discussions:","text":"<ul> <li>We have the following discussion topics: <ol> <li>Announcements: One way communication from the team to the community. Consider this like our mini blog</li> <li>Questions and Help: For help and support. Consider this similar to StackOverflow.</li> <li>Development: For discussing potential features, and collaborating on their design.</li> </ol> </li> </ul>"},{"location":"contributing/overview/#issues","title":"Issues:","text":"<ol> <li>Every issue needs to be actionable and assignable. Consider the scope of the issue if assigned to one person, and break down if necessary.</li> <li>Be clear and definitive when composing issues. For bug reports, include detailed error messages and environment description. For features, include a clear scope and acceptance criteria.</li> <li>Since we have different projects under the same monorepo, use labels to denote areas that the issue relates to:<ol> <li><code>tracee</code></li> <li><code>tracee-ebpf</code></li> <li><code>tracee-rules</code></li> <li><code>signatures</code></li> <li>If non of the labels is relevant don't add any (usually for top-level issues)</li> </ol> </li> <li>We use the following labels to describe the type of issue:<ol> <li><code>bug</code></li> <li><code>good-first-issue</code></li> </ol> </li> <li>Self-assign or request assignment for issues you intend to work on. Don't work on an issue assigned to someone else without checking with them first and reassigning.</li> </ol>"},{"location":"contributing/overview/#pull-requests","title":"Pull Requests","text":"<ol> <li>Every Pull Request should have an associated Issue unless it is a trivial fix.</li> <li>When adding a flag option or other UX related change, make sure the design is explicitly described in the associated issue, and a maintainer approved it.</li> <li>Commit subject should succinctly describe the change:<ol> <li>Max 50 chars.</li> <li>Written in imperative mood: begin with a verb like \"fix\", \"add\", \"improve\", or \"refactor\"; Think \"once applied, this commit will...\".</li> <li>If ambiguous, mention the area that this commit affects (see area labels above).</li> </ol> </li> <li>Optional commit body (separated by empty line from subject) may explain why the change was made and not how. Wrap at 72 chars.</li> <li>Code related information should be in commit message, review related information should be in PR description.</li> <li>For changes that span different areas please try to make each change self contained and independent.</li> </ol>"},{"location":"contributing/overview/#code","title":"Code","text":"<ol> <li>Follow Golang's code review standards: https://github.com/golang/go/wiki/CodeReviewComments.</li> <li>Follow <code>gofmt</code> + <code>govet</code> + <code>goimports</code> formatting.</li> <li>Tests should be included alongside code changes wherever applicable, except for parts that are harder to test and are not currently tested (e.g. eBPF). When modifying already tested code, your changes must be represented in the existing tests.</li> </ol>"},{"location":"contributing/setup-development-machine-with-vagrant/","title":"Setup Development Machine with Vagrant","text":"<p>HashiCorp Vagrant leverages a declarative configuration file, which describes all software requirements, packages, operating system configuration, and users to provide the same development environment for everyone.</p> <p>The Vagrantfile describes the type of machine required to build Tracee from source and follow the Getting Started guides. This allows developers involved in the project to check out the code, run <code>vagrant up</code>, and be on their way.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#prerequisites","title":"Prerequisites","text":"<ul> <li>Vagrant</li> <li>Hypervisor supported by Vagrant, such as VirtualBox on a amd64 (Linux) machine or Parallels on an arm64 M1 (Darwin) machine.</li> </ul>"},{"location":"contributing/setup-development-machine-with-vagrant/#create-development-machine","title":"Create Development Machine","text":"<p>Clone and change directory to Tracee Git repository:</p> <pre><code>git clone --branch v0.21.0-rc-32-gc858afa7d https://github.com/aquasecurity/tracee.git\ncd tracee\n</code></pre> <p>Create and configure development machine according to the <code>Vagrantfile</code>:</p> <pre><code>vagrant up\n</code></pre> <p>If everything goes well, you can SSH into a running development machine and access its shell:</p> <pre><code>vagrant ssh\n</code></pre> <pre><code>vagrant@ubuntu-jammy:/vagrant$\n</code></pre> <p>Tip</p> <p>Provisioning from scratch take time, but once created you can reuse the machine with <code>vagrant halt</code> and <code>vagrant up</code> commands. If something goes wrong with your machine, there's also the <code>vagrant destroy</code> to destroy it and start over again.</p> <p>Synced folders enable Vagrant to sync a folder on the host machine to the development machine, allowing you to continue working on your project's files on your host machine, but use the resources in the development machine to compile or run Tracee.</p> <p>By default, Vagrant will share Tracee project directory (the directory with the <code>Vagrantfile</code>) to <code>/vagrant</code>. To get started list files:</p> <pre><code>ls -l\n</code></pre> <pre><code>total 648\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 3rdparty\n-rw-r--r-- 1 vagrant vagrant  11358 Mar 18 14:45 LICENSE\n-rw-r--r-- 1 vagrant vagrant  21821 Mar 27 13:40 Makefile\n-rw-r--r-- 1 vagrant vagrant    133 Mar 18 14:45 NOTICE\n-rw-r--r-- 1 vagrant vagrant   2643 Mar 29 18:30 RELEASING.md\n-rw-r--r-- 1 vagrant vagrant   2238 Mar 22 23:43 Readme.md\n-rw-r--r-- 1 vagrant vagrant   3337 Mar 22 23:43 Vagrantfile\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 29 18:05 brand\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 builder\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 cmd\n-rw-r--r-- 1 vagrant vagrant 415013 Mar 28 23:17 coverage.txt\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 18 14:45 deploy\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 29 18:15 dist\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 docs\n-rw-r--r-- 1 vagrant vagrant    164 Mar 18 14:45 embedded-ebpf.go\n-rw-r--r-- 1 vagrant vagrant    101 Mar 18 14:45 embedded.go\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 27 12:08 examples\n-rw-r--r-- 1 vagrant vagrant   5599 Mar 29 17:22 go.mod\n-rw-r--r-- 1 vagrant vagrant  77170 Mar 29 17:22 go.sum\n-rw-r--r-- 1 vagrant vagrant  40206 Mar 22 23:43 mkdocs.yml\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 packaging\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 pkg\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 18 14:45 signatures\n-rw-r--r-- 1 vagrant vagrant    157 Mar 22 23:43 staticcheck.conf\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 24 15:44 tests\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 types\n</code></pre> <p>As you can see the <code>/vagrant</code> directory contains source code of Tracee cloned from GitHub.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#build-and-run-tracee","title":"Build and Run Tracee","text":"<p>To build tracee executable binary, run the default make target:</p> <pre><code>make\n</code></pre> <p>Build targets are saved in the <code>/vagrant/dist</code> directory:</p> <pre><code>ls -l dist/\n</code></pre> <pre><code>total 161096\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:06 btfhub\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:06 libbpf\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:08 signatures\n-rwxr-xr-x 1 vagrant vagrant 62619312 Mar 29 19:08 tracee\n-rw-r--r-- 1 vagrant vagrant 10753624 Mar 29 19:06 tracee.bpf.o\n</code></pre> <p>You can now run Tracee and see events printed to the standard output in a tabular format:</p> <pre><code>sudo ./dist/tracee\n</code></pre> <pre><code>TIME             UID    COMM             PID     TID     RET              EVENT                     ARGS\n19:10:09:453832  0      coredns          1       8       0                security_socket_connect   sockfd: 13, remote_addr: map[sa_family:AF_INET sin_addr:0.0.0.0 sin_port:8080]\n19:10:09:454179  0      coredns          1       9       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:09:454265  0      coredns          1       9       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:09:454478  0      coredns          1       14      0                net_packet_http_request   metadata: {127.0.0.1 127.0.0.1 43306 8080 6 144 any}, http_request: &amp;{GET HTTP/1.1 :8080 /health map[Accept-Encoding:[gzip] User-Agent:[Go-http-client/1.1]] 0}\n19:10:09:454774  0      coredns          1       14      0                net_packet_http_response  metadata: {127.0.0.1 127.0.0.1 8080 43306 6 170 any}, http_response: &amp;{200 OK 200 HTTP/1.1 map[Content-Length:[2] Content-Type:[text/plain; charset=utf-8] Date:[Wed, 29 Mar 2023 19:10:09 GMT]] 2}\n19:10:10:452992  0      coredns          1       14      0                security_socket_connect   sockfd: 13, remote_addr: map[sa_family:AF_INET sin_addr:0.0.0.0 sin_port:8080]\n19:10:10:453850  0      coredns          1       1       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:10:453983  0      coredns          1       1       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:10:454612  0      coredns          1       9       0                net_packet_http_request   metadata: {127.0.0.1 127.0.0.1 43318 8080 6 144 any}, http_request: &amp;{GET HTTP/1.1 :8080 /health map[Accept-Encoding:[gzip] User-Agent:[Go-http-client/1.1]] 0}\n19:10:10:455114  0      coredns          1       9       0                net_packet_http_response  metadata: {127.0.0.1 127.0.0.1 8080 43318 6 170 any}, http_response: &amp;{200 OK 200 HTTP/1.1 map[Content-Length:[2] Content-Type:[text/plain; charset=utf-8] Date:[Wed, 29 Mar 2023 19:10:10 GMT]] 2}\n</code></pre>"},{"location":"contributing/setup-development-machine-with-vagrant/#switch-between-co-re-and-non-co-re-linux-distribution","title":"Switch Between CO-RE and non CO-RE Linux Distribution","text":"<p>By default, the development machine is running Ubuntu Linux 22.04 Jammy Jellyfish. You can see that it has a BTF-enabled kernel by checking the existence of the <code>/sys/kernel/btf/vmlinux</code> file.</p> <pre><code>Vagrant.configure(\"2\") do |config|\n  # config.vm.box = \"ubuntu/focal64\"     # Ubuntu 20.04 Focal Fossa (non CO-RE)\n  # config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n  # config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\n  config.vm.box = \"ubuntu/jammy64\"       # Ubuntu 22.04 Jammy Jellyfish (CO-RE)\n...\n</code></pre> <p>Sometimes you may want to test Tracee with a non CO-RE distribution. You can do that by editing the Vagrantfile and modifying the <code>config.vm.box</code> property. For example, you can switch to Ubuntu Linux 20.04 Focal Fossa as follows:</p> <pre><code>Vagrant.configure(\"2\") do |config|\n  config.vm.box = \"ubuntu/focal64\"       # Ubuntu 20.04 Focal Fossa (non CO-RE)\n  # config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n  # config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\n  # config.vm.box = \"ubuntu/jammy64\"     # Ubuntu 22.04 Jammy Jellyfish (CO-RE)\n...\n</code></pre> <p>This change requires re-provisioning the development machine:</p> <pre><code>vagrant destroy\nvagrant up\n</code></pre> <p>Attention</p> <p>Ubuntu Focal distribution has introduced BTF information to their recent kernels, allowing eBPF CO-RE capable code to run. If you're willing to test non CO-RE kernels, make sure to use an older kernel that does not provide the <code>/sys/kernel/btf/vmlinux</code> file.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#deploy-tracee-with-postee-on-kubernetes","title":"Deploy Tracee with Postee on Kubernetes","text":"<p>The development machine described by Vagrantfile pre-installs MicroK8s Kubernetes cluster, which is suitable for testing Tracee.</p> <pre><code>microk8s status\n</code></pre> <pre><code>microk8s is running\nhigh-availability: no\n  datastore master nodes: 127.0.0.1:19001\n  datastore standby nodes: none\n...\n</code></pre> <p>There's also the kubectl command installed and configured to communicate with the cluster:</p> <pre><code>kubectl get nodes -o wide\n</code></pre> <pre><code>NAME           STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\nubuntu-jammy   Ready    &lt;none&gt;   40m   v1.26.1   10.0.2.15     &lt;none&gt;        Ubuntu 22.04.2 LTS   5.15.0-69-generic   containerd://1.6.8\n</code></pre> <p>Create a new namespace called <code>tracee-system</code>:</p> <pre><code>kubectl create ns tracee-system\n</code></pre> <p>Create Postee Persistent Volumes and StatefulSet in the <code>tracee-system</code> namespace:</p> <pre><code>kubectl apply -n tracee-system \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/hostPath/postee-pv.yaml \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/postee.yaml\n</code></pre> <p>Create Tracee DaemonSet in the <code>tracee-system</code>, configuring it to send  detections to the standard output and send them over to Postee webhook on http://postee-svc:8082:</p> <pre><code>helm install tracee ./deploy/helm/tracee \\\n  --namespace tracee-system \\\n  --set hostPID=true \\\n  --set webhook=http://postee-svc:8082\n</code></pre> <p>Tip</p> <p>To test code that hasn't been released yet do the following:</p> <ol> <li>Build the <code>tracee:latest</code> container image from the current Git revision:    <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre></li> <li>Import the container image to MicroK8s registry:    <pre><code>docker image save -o /tmp/tracee-latest.tar tracee:latest\nmicrok8s ctr images import /tmp/tracee-latest.tar\nrm /tmp/tracee-latest.tar\n</code></pre></li> <li>Create Tracee DaemonSet using <code>tracee:latest</code> as container image:    <pre><code>kubectl apply -n tracee-system -k deploy/kubernetes/tracee\n</code></pre></li> </ol> <p>While Tracee pod is running, run <code>strace ls</code> command and observe detection printed to the standard output.</p> <pre><code>kubectl logs -n tracee-system -f daemonset/tracee\n</code></pre> <pre><code>INFO: probing tracee capabilities...\nINFO: starting tracee...\n{\"timestamp\":1680119087787203746,\"threadStartTime\":1680119087787109775,\"processorId\":0,\"processId\":95599,\"cgroupId\":9789,\"threadId\":95599,\"parentProcessId\":95597,\"hostProcessId\":95599,\"hostThreadId\":95599,\"hostParentProcessId\":95597,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-jammy\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"podSandbox\":false,\"eventId\":\"6018\",\"eventName\":\"Anti-Debugging detected\",\"matchedScopes\":1,\"argsNum\":0,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"1\",\"Description\":\"A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior.\",\"Tags\":null,\"Properties\":{\"Category\":\"defense-evasion\",\"Kubernetes_Technique\":\"\",\"Severity\":1,\"Technique\":\"Debugger Evasion\",\"external_id\":\"T1622\",\"id\":\"attack-pattern--e4dc8c01-417f-458d-9ee0-bb0617c1b391\",\"signatureID\":\"TRC-102\",\"signatureName\":\"Anti-Debugging detected\"}}}\n</code></pre> <p>If everything is configured properly, you can find the same detection in Postee logs:</p> <pre><code>kubectl -n tracee-system logs -f postee-0\n</code></pre> <pre><code>2023/03/29 19:44:47 {\"timestamp\":1680119087787203746,\"threadStartTime\":1680119087787109775,\"processorId\":0,\"processId\":95599,\"cgroupId\":9789,\"threadId\":95599,\"parentProcessId\":95597,\"hostProcessId\":95599,\"hostThreadId\":95599,\"hostParentProcessId\":95597,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-jammy\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"podSandbox\":false,\"eventId\":\"6018\",\"eventName\":\"Anti-Debugging detected\",\"matchedScopes\":1,\"argsNum\":0,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"1\",\"Description\":\"A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior.\",\"Tags\":null,\"Properties\":{\"Category\":\"defense-evasion\",\"Kubernetes_Technique\":\"\",\"Severity\":1,\"Technique\":\"Debugger Evasion\",\"external_id\":\"T1622\",\"id\":\"attack-pattern--e4dc8c01-417f-458d-9ee0-bb0617c1b391\",\"signatureID\":\"TRC-102\",\"signatureName\":\"Anti-Debugging detected\"}}}\n</code></pre>"},{"location":"contributing/setup-development-machine-with-vagrant/#access-kubernetes-dashboard","title":"Access Kubernetes Dashboard","text":"<p>Use the following command to get the token required to log in to the Kubernetes Dashboard:</p> <pre><code>kubectl -n kube-system describe secret \\\n  $(kubectl -n kube-system get secret | grep default-token | cut -d \" \" -f1)\n</code></pre> <p>Forward port 10443 in the development machine to the Kubernetes Dashboard's pod:</p> <pre><code>kubectl port-forward --address 0.0.0.0 -n kube-system service/kubernetes-dashboard 10443:443\n</code></pre> <p>Since port 10443 is forwarded to port 10443 on your host, you can open your browser to https://localhost:10443 and access Kubernetes Dashboard.</p> <p>Warning</p> <p>Modern browser usually block insecure localhost TLS connections. For Google Chrome you may allow insecure TLS connections at chrome://flags/#allow-insecure-localhost.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#preview-tracee-documentation","title":"Preview Tracee Documentation","text":"<p>You can run MkDocs server and preview documentation on your host:</p> <pre><code>make -f builder/Makefile.mkdocs\n</code></pre> <p>The development machine is running the MkDocs server listening on port 8000, which is forwarded to port 8000 on your host. Therefore, you can open your browser to http://localhost:8000 and access documentation pages.</p>"},{"location":"contributing/building/building/","title":"Building from the source","text":"<p>Note</p> <p>Consider also visiting the following instructions: 1. docker container as building environment 2. building tracee container images </p> <ol> <li> <p>Supported Architectures</p> <ol> <li>x86_64 (amd64)</li> <li>aarch64 (arm64)</li> </ol> </li> <li> <p>Building dependencies</p> <ol> <li>clang &amp;&amp; llvm (12, 13 or 14)</li> <li>golang (1.21)</li> <li>libelf and libelf-dev    (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and zlib1g-dev    (or zlib and zlib-devel)</li> <li>clang-format-12 (specific version) for <code>fix-fmt</code></li> </ol> <p>You might take a look at the following files to understand how to have a building environment:</p> <ol> <li>.github/actions/build-dependencies/action.yaml</li> <li>packaging/Dockerfile.ubuntu-packaging</li> <li>packaging/Dockerfile.fedora-packaging</li> </ol> <p>Those are very good examples for you to replicate a working environment.</p> </li> <li> <p>Clone tracee repository</p> <pre><code>git clone git@github.com:aquasecurity/tracee\n</code></pre> <pre><code>Cloning into 'tracee'...\nremote: Enumerating objects: 13251, done.\nremote: Counting objects: 100% (555/555), done.\nremote: Compressing objects: 100% (240/240), done.\nremote: Total 13251 (delta 343), reused 369 (delta 280), pack-reused 12696\nReceiving objects: 100% (13251/13251), 11.75 MiB | 8.62 MiB/s, done.\nResolving deltas: 100% (8105/8105), done.\n</code></pre> </li> <li> <p>All makefiles have a help target to give you needed instructions</p> <pre><code>make help\n</code></pre> <pre><code># environment\n\n    $ make env                      # show makefile environment/variables\n\n# build\n\n    $ make all                      # build tracee-ebpf, tracee-rules &amp; signatures\n    $ make bpf                      # build ./dist/tracee.bpf.o\n    $ make tracee-ebpf              # build ./dist/tracee-ebpf\n    $ make tracee-rules             # build ./dist/tracee-rules\n    $ make tracee-bench             # build ./dist/tracee-bench\n    $ make signatures               # build ./dist/signatures\n    $ make e2e-net-signatures       # build ./dist/e2e-net-signatures\n    $ make e2e-inst-signatures      # build ./dist/e2e-inst-signatures\n    $ make tracee                   # build ./dist/tracee\n\n# clean\n\n    $ make clean                    # wipe ./dist/\n    $ make clean-bpf                # wipe ./dist/tracee.bpf.o\n    $ make clean-tracee-ebpf        # wipe ./dist/tracee-ebpf\n    $ make clean-tracee-rules       # wipe ./dist/tracee-rules\n    $ make clean-tracee-bench       # wipe ./dist/tracee-bench\n    $ make clean-signatures         # wipe ./dist/signatures\n    $ make clean-tracee             # wipe ./dist/tracee\n\n# test\n\n    $ make test-unit                # run unit tests\n    $ make test-types               # run unit tests for types module\n    $ make test-integration         # run integration tests\n    $ make test-signatures          # opa test (tracee-rules)\n\n# flags\n\n    $ STATIC=1 make ...             # build static binaries\n    $ BTFHUB=1 STATIC=1 make ...    # build static binaries, embed BTF\n    $ DEBUG=1 make ...              # build binaries with debug symbols\n</code></pre> </li> <li> <p>Build all targets at once</p> <pre><code>make all\n</code></pre> <pre><code>Submodule 'libbpf' (https://github.com/libbpf/libbpf.git) registered for path '3rdparty/libbpf'\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/libbpf'...\nmkdir -p dist/signatures\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS= CGO_LDFLAGS= go build \\\n    --buildmode=plugin \\\n    -o dist/signatures/builtin.so \\\n    signatures/golang/export.go signatures/golang/kubernetes_api_connection.go signatures/golang/stdio_over_socket.go\n</code></pre> </li> <li> <p>Build a static binary by setting <code>STATIC=1</code></p> <pre><code>STATIC=1 make all\n</code></pre> <pre><code>CC=\"clang\" \\\n    CFLAGS=\"\"-fPIC\"\" \\\n    LD_FLAGS=\"\" \\\n    make \\\n    -C ./3rdparty/libbpf/src \\\n    BUILD_STATIC_ONLY=1 \\\n    DESTDIR=/home/rafaeldtinoco/tracee/dist/libbpf \\\n    OBJDIR=/home/rafaeldtinoco/tracee/dist/libbpf/obj \\\n    INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \\\n    install install_uapi_headers\n...\n</code></pre> </li> <li> <p>Build a static binary with BTFHUB Support</p> <pre><code>BTFHUB=1 STATIC=1 make all\n</code></pre> <pre><code>Cloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub'...\nremote: Enumerating objects: 205, done.\nremote: Counting objects: 100% (16/16), done.\nremote: Compressing objects: 100% (12/12), done.\nremote: Total 205 (delta 4), reused 10 (delta 3), pack-reused 189\nReceiving objects: 100% (205/205), 10.59 MiB | 7.56 MiB/s, done.\nResolving deltas: 100% (73/73), done.\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub-archive'...\nremote: Enumerating objects: 1993, done.\nremote: Counting objects: 100% (28/28), done.\nremote: Compressing objects: 100% (23/23), done.\nReceiving objects:  15% (301/1993), 154.97 MiB | 15.72 MiB/s\n</code></pre> <p>Note</p> <p>BTFHUB support will embed several very small files (BTF files) into your final binary. Those files will allow tracee binary to be executed in kernels that doesn't have embedded BTF information (the ones described at the BTFHUB repository)</p> <p>Attention</p> <p>compiling <code>tracee-rules</code> with STATIC=1 won't allow you to use golang based signatures as plugins, only as built-ins:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/signatures/builtin.so:\nplugin.Open(\"/tracee/dist/signatures/builtin.so\"): Dynamic loading not supported\n</code></pre> </li> <li> <p>Build a debugable binary with DWARF generation by setting <code>DEBUG=1</code></p> <pre><code>DEBUG=1 make\n</code></pre> <pre><code>GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/gg/code/tracee/dist/libbpf\" CGO_LDFLAGS=\"-lelf  -lz  /home/gg/code/tracee/dist/libbpf/libbpf.a\" go build \\\n    -tags core,ebpf \\\n    -ldflags=\" \\\n         -extldflags \\\"\\\" \\\n         -X main.version=\\\"v0.8.0-107-g121efeb\\\" \\\n        \" \\\n    -v -o dist/tracee \\\n   ./cmd/tracee\n</code></pre> </li> </ol>"},{"location":"contributing/building/containers/","title":"Creating Tracee Container Images","text":"<p>These instructions are meant to describe how to build the official tracee container image, instead of just downloading it from the Docker Hub.</p> <p>If you would like to have a local building and execution environment, read this instead.</p>"},{"location":"contributing/building/containers/#using-tracee-container-image-from-docker-hub","title":"Using Tracee Container Image from Docker Hub","text":"<p>Before moving on to how to build Tracee container, it is important to know the published container images and their tag meanings. Here is the current list of docker container images being published during a release (or a snapshot release):</p> <ol> <li> <p>SNAPSHOT (development) container images:</p> <p>These container images are built daily and its tags always point to the  latest daily built container images (based on the version currently being  developed).</p> <ul> <li>aquasec/tracee:dev</li> </ul> </li> <li> <p>RELEASE (official versions) container images:</p> <p>Preferable alias for latest released image:</p> <ul> <li>aquasec/tracee:latest</li> </ul> <p>And the container images for each released version of Tracee:</p> <ul> <li>aquasec/tracee:VERSION</li> </ul> </li> </ol>"},{"location":"contributing/building/containers/#generating-tracee-container-images","title":"Generating Tracee Container Images","text":"<ol> <li> <p>tracee:latest</p> <p>Contains an executable binary with an embedded and CO-RE enabled eBPF object that makes it portable against multiple Linux and kernel versions.</p> <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre> <p>Note</p> <p><code>BTFHUB=1</code> adds support to some older kernels.</p> <pre><code>BTFHUB=1 make -f builder/Makefile.tracee-container build-tracee\n</code></pre> </li> </ol>"},{"location":"contributing/building/containers/#running-generated-tracee-container-image","title":"Running Generated Tracee Container Image","text":"<p>Tracee container is supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute the recently generated container image with correct arguments, mostly to see if the image is working.</p> <p>User may execute built containers through <code>Makefile.tracee-container</code> file with the \"run\" targets:</p> <ol> <li> <p>To run recently generated tracee:latest container:</p> <pre><code>make -f builder/Makefile.tracee-container run-tracee\n</code></pre> <p>Note</p> <p>Tracee arguments are passed through the <code>ARG</code> variable: <pre><code>make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\"\n</code></pre></p> </li> </ol>"},{"location":"contributing/building/environment/","title":"Creating a local building environment","text":"<p>These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead.</p> <p>Note</p> <p>A building environment will let you build and execute tracee inside a docker container, containing all needed tools to build and execute it. If you're using an OSX environment, for example, you can install gmake (<code>brew install gmake</code>) and configure such environment by using Docker.</p> <p>Attention</p> <p>If you want to build tracee on your local machine read this.</p>"},{"location":"contributing/building/environment/#quick-steps-impatient-readers","title":"Quick steps (impatient readers)","text":"<p>Example</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <p>and inside the container:</p> <pre><code>make clean\nmake tracee\nsudo ./dist/tracee \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout.</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <p>and inside the container:</p> <pre><code>make clean\nmake all\nsudo ./dist/tracee \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow \n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute: <code>sudo strace /bin/ls</code> and observe tracee warning you about a possible risk (with its Anti-Debugging signature).</p> <p>Now, for more patient readers ...</p>"},{"location":"contributing/building/environment/#how-to-build-and-use-the-environment","title":"How to build and use the environment","text":"<p>In order to have a controlled building environment for tracee, tracee provides a <code>Makefile.tracee-make</code> file that allows you to create and use a docker container environment to build &amp; test tracee. </p> <p>Two different environments are maintained for building tracee:</p> <ul> <li>Alpine</li> <li>Ubuntu</li> </ul> <p>The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc. By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments.</p> <p>Attention</p> <p>Locally created containers, called <code>alpine-tracee-make</code> or <code>ubuntu-tracee-make</code>, share the host source code directory. This means that, if you build tracee binary using <code>alpine</code> distribution, the binary might not be compatible to the Linux distribution from your host OS.</p>"},{"location":"contributing/building/environment/#creating-a-builder-environment","title":"Creating a builder environment","text":"<ul> <li> <p>To create an alpine-tracee-make container:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\n</code></pre> </li> <li> <p>To create an ubuntu-tracee-make container:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-prepare\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#executing-a-builder-environment","title":"Executing a builder environment","text":"<ul> <li> <p>To execute an alpine-tracee-make shell:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> </li> <li> <p>To execute an ubuntu-tracee-make shell:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#using-build-environment-as-a-make-replacement","title":"Using build environment as a make replacement","text":"<p>Instead of executing a builder shell, you may use <code>alpine-tracee-make</code>, or <code>ubuntu-tracee-make</code>, as a replacement for the <code>make</code> command:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-prepare\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\"\n</code></pre> <p>And, after the compilation, run the commands directly in your host:</p> <pre><code>sudo ./dist/tracee \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow\n</code></pre> <p>Note: the generated binary must be compatible to your host (depending on glibc version, for example).</p> <p>If you don't want to depend on host's libraries versions, or if you are using the <code>alpine-tracee-make</code> container as a replacement for <code>make</code>, and your host is not an Alpine Linux, then you may set <code>STATIC=1</code> variable so you can run compiled binaries in your host:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-make ARG=\"help\"\nSTATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\"\n</code></pre> <p>and execute the static binary from your host:</p> <pre><code>ldd dist/tracee\n</code></pre> <pre><code>not a dynamic executable\n</code></pre> <p>Attention</p> <p>compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/signatures/builtin.so:\nplugin.Open(\"/tracee/dist/signatures/builtin.so\"): Dynamic loading not supported\n</code></pre>"},{"location":"docs/overview/","title":"Docs","text":"<p>In this section you can find the complete reference documentation for all of the different features and settings that Tracee has to offer.</p> <p>Note</p> <p>We have recently transitioned to a new architecture and user-experience, as detailed here, and the documentation has been updated accordingly.  </p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"docs/advanced/caching-events/","title":"Special: Caching Events","text":"<p>Tracee has an events caching (in-memory) mechanism. In order to check latest caching options you may execute:</p> <pre><code>./dist/tracee man cache\n</code></pre> <p></p> <p>The caching happens in userland, it is an in-memory caching, and it helps with workload bursts: if kernel produces more events than userland is capable of processing then the events are kept in a sizeable cache (defined by user) so they're not lost (if cache isn't full).</p> <p>The effects of this are the following:</p> <ol> <li> <p>Detections might be delayed because of workload bursts, but not lost (if    cache isn't full).</p> </li> <li> <p>Event losses from the kernel perf/ring buffer will only happen when    cache is full.</p> </li> <li> <p>Any difference in ratio production:consumption can be mitigated temporarily.</p> </li> </ol>"},{"location":"docs/advanced/caching-events/#use-caching","title":"Use caching","text":"<p>Example using 1GB cache:</p> <pre><code>sudo ./dist/tracee \\\n    --cache cache-type=mem \\\n    --cache mem-cache-size=1024 \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    -trace container \\\n    --cri docker:/var/run/docker.sock\n</code></pre> <p>Attention</p> <p>If you pipe tracee output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee is capable of writing events to it.</p>"},{"location":"docs/advanced/dropping-capabilities/","title":"Special: Environment Capabilities","text":""},{"location":"docs/advanced/dropping-capabilities/#introduction-to-capabilities-quoting-parts-of-kernel-docs","title":"Introduction to Capabilities (quoting parts of kernel docs)","text":"<p>For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (whose effective user ID is 0, referred to as superuser or root), and unprivileged processes (whose effective UID is nonzero).</p> <p>Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).</p> <p>Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute.</p> <p>Thread capability sets:</p> <ul> <li> <p>Permitted: This is a limiting superset for the effective capabilities that the thread may assume. It is also a limiting superset for the capabilities that may be added to the inheritable set by a thread that does not have the CAP_SETPCAP capability in its effective set.</p> </li> <li> <p>Inheritable: This is a set of capabilities preserved across an execve(2). Inheritable capabilities remain inheritable when executing any program, and inheritable capabilities are added to the permitted set when executing a program that has the corresponding bits set in the file inheritable set.</p> </li> <li> <p>Effective: This is the set of capabilities used by the kernel to perform permission checks for the thread.</p> </li> <li> <p>Bounding: The capability bounding set is a mechanism that can be used to limit the capabilities that are gained during execve(2).</p> </li> </ul>"},{"location":"docs/advanced/dropping-capabilities/#tracee-and-capabilities","title":"Tracee and capabilities","text":"<p>tracee tries to reduce its capabilities during its execution. The way it does is through different \"execution protection rings\":</p> <ul> <li>Full:     All capabilities are effective (less secure)</li> <li>EBPF:     eBPF needed capabilities + Base capabilities</li> <li>Specific: Specific capabilities (from time to time) + Base Capabilities</li> <li>Base:     None or Some capabilities always effective (more secure)</li> </ul>"},{"location":"docs/advanced/dropping-capabilities/#listing-available-capabilities","title":"Listing available capabilities","text":"<p>You may see all available capabilities in the running environment by running:</p> <pre><code>capsh --print\n</code></pre>"},{"location":"docs/advanced/dropping-capabilities/#bypass-capabilities-dropping-feature","title":"Bypass capabilities dropping feature","text":"<p>Attention</p> <p>This session is important if you're facing errors related to tracee dropping its capabilities OR any other permission related errors.</p> <p>Some environments won't allow capabilities dropping because of permission issues (for example - AWS Lambdas).</p> <p>It might be a result of seccomp filter for example, restricting syscalls access.</p> <p>Failure in capabilities dropping will result tracee's exit with a matching error, to guarantee that tracee isn't running with excess capabilities without the user agreement.</p> <p>To allow tracee to run with high capabilities, and prevent those errors, the <code>--capabilities bypass=true</code> flag can be used. For the docker container users, the environment variable <code>CAPABILITIES_BYPASS=0|1</code> will have the same effect.</p> <p>Note</p> <p>Bypassing the capabilities drop will run tracee with all capabilities set as Effective and it is only recommended if you know what you are doing.</p>"},{"location":"docs/advanced/dropping-capabilities/#capabilities-errors-missing-or-too-permissive","title":"Capabilities Errors (Missing or Too Permissive)","text":"<p>During development, tracee might have bugs related to capabilities dropping feature: one event might not have its needed capabilities set as a dependency, for example, and you might still want to use that event.</p> <p>One way to have fine grained control of \"execution time\" effective capabilities is to rely on following 2 command line flags:</p> <ul> <li><code>--capabilities add=cap_X,cap_Y</code> (docker env variable CAPABILITIES_ADD)</li> <li><code>--capabilities drop=cap_Y,capZ</code> (docker env variable CAPABILITIES_DROP)</li> </ul> <p>The first will add given capabilities to the Base ring, the ring that describe capabilities that will always be effective while tracee is running, so events might be able to work. The last will remove the capabilities from that same ring.</p>"},{"location":"docs/advanced/forensics/","title":"Getting Started with Forensics","text":"<p>Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the <code>--capture</code> flag.</p> <pre><code>./dist/tracee man capture\n</code></pre> <pre><code>sudo ./dist/tracee --capture xxx\n</code></pre> <p>Tip</p> <p>All captured artifacts are saved in Tracee's \"output directory\", which can be configured using <code>--capture dir:/path/to/dir</code>. You may also use <code>--capture clear-dir</code> if you want contents of the destination directory to be cleared every time you execute tracee.</p>"},{"location":"docs/advanced/forensics/#artifacts-types","title":"Artifacts Types","text":"<p>Tracee can capture the following types of artifacts:</p> <ol> <li> <p>I/O Files</p> <p>Anytime a file is being written to and/or read from, the contents of the file will be captured. I/O files can be filtered using 3 optional filters: 1. path - prefix of the file written/read. Up to 3 path filters can be    provided per capture type. 2. type - file's type can be <code>pipe</code>, <code>socket</code>, <code>elf</code> or <code>regular</code>. 3. fd - standard FD, one of the following: <code>stdin</code>, <code>stdout</code> and <code>stderr</code>.</p> <p>write example <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture write='/tmp/*'\n</code></pre></p> <p>Note</p> <p>Using file capture without filter name will be path by default. Hence, <code>--capture write='/tmp/*</code> is the same as <code>--capture write:path='/tmp/*</code>.</p> <pre><code>echo write testing 123 &gt; /tmp/testing.txt\n</code></pre> <pre><code>{\"timestamp\":1657321167356748797,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":6,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":1966101},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1657321027326584850},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"}]}\n{\"timestamp\":1657321167356729582,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC\"},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":438}]}\n</code></pre> <p>Note</p> <p>You can read captured files written at <code>/tmp/tracee/out</code>: <pre><code>sudo cat /tmp/tracee/out/host/write.dev-271581185.inode-1966101\n</code></pre></p> <pre><code>write testing 123\n</code></pre> <p>read example</p> <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture read:type=pipe \\\n   --capture read:fd=stdin'\n</code></pre> <pre><code>echo read testing 123 | cat\n</code></pre> <pre><code>{\"timestamp\":1685285181028166900,\"threadStartTime\":1685285181026565700,\"processorId\":1,\"processId\":182934,\"cgroupId\":1,\"threadId\":182934,\"parentProcessId\":147428,\"hostProcessId\":184128,\"hostThreadId\":184128,\"hostParentProcessId\":148293,\"userId\":0,\"mountNamespace\":4026532277,\"pidNamespace\":4026532279,\"processName\":\"cat\",\"hostName\":\"Alon-Zivony\",\"container\":{},\"kubernetes\":{},\"eventId\":\"720\",\"eventName\":\"vfs_read\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":17,\"syscall\":\"read\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":12},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":174033},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072},{\"name\":\"pos\",\"type\":\"off_t\",\"value\":0}]}\n{\"timestamp\":1685285181028267200,\"threadStartTime\":1685285181026565700,\"processorId\":1,\"processId\":182934,\"cgroupId\":1,\"threadId\":182934,\"parentProcessId\":147428,\"hostProcessId\":184128,\"hostThreadId\":184128,\"hostParentProcessId\":148293,\"userId\":0,\"mountNamespace\":4026532277,\"pidNamespace\":4026532279,\"processName\":\"cat\",\"hostName\":\"Alon-Zivony\",\"container\":{},\"kubernetes\":{},\"eventId\":\"720\",\"eventName\":\"vfs_read\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"read\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":12},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":174033},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072},{\"name\":\"pos\",\"type\":\"off_t\",\"value\":0}]}\n</code></pre> </li> </ol> <p>!!! Note        You can read captured files read at <code>/tmp/tracee/out</code>:        <pre><code>sudo cat /tmp/tracee/out/host/read.dev-12.inode-176203\n</code></pre></p> <pre><code>    ```text\n    read testing 123\n    ```\n</code></pre> <ol> <li> <p>Executed Files</p> <p>Anytime a binary is executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once.</p> <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture exec\n</code></pre> <pre><code>/bin/ls\n</code></pre> <pre><code>{\"timestamp\":1657322300531713371,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"56\",\"eventName\":\"clone\",\"argsNum\":5,\"returnValue\":3331757,\"stackAddresses\":null,\"syscall\":\"clone\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"flags\",\"type\":\"string\",\"value\":\"CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID\"},{\"name\":\"stack\",\"type\":\"void*\",\"value\":\"0x0\"},{\"name\":\"parent_tid\",\"type\":\"int*\",\"value\":\"0x0\"},{\"name\":\"child_tid\",\"type\":\"int*\",\"value\":\"0x7fd7ce0d3a10\"},{\"name\":\"tls\",\"type\":\"unsigned long\",\"value\":0}]}\n{\"timestamp\":1657322300534562489,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"3\",\"eventName\":\"close\",\"argsNum\":1,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"close\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":3}]}\n</code></pre> <p>Note</p> <p>You will have a copy of each executed file written at <code>/tmp/tracee/out</code>: <pre><code>ldd /bin/ls\n</code></pre></p> <pre><code>linux-vdso.so.1 (0x00007ffca632c000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9a930d5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a92ead000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f9a92e16000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f9a93136000)\n</code></pre> <pre><code>ldd /tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre> <pre><code>linux-vdso.so.1 (0x00007ffe337fb000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007feeb1fa5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007feeb1d7d000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007feeb1ce6000)\n/lib64/ld-linux-x86-64.so.2 (0x00007feeb2006000)\n\n```console\nsudo chmod +x /tmp/tracee/out/host/exec.1657322052835478987.ls\n/tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre> </li> <li> <p>Memory Files</p> <p>Anytime a memory unpacker is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write.</p> <pre><code>sudo ./dist/tracee \\\n   --output none \\\n   --scope comm=bash \\\n   --scope follow \\\n   --capture dir:/tmp/tracee/ \\\n   --capture mem\n</code></pre> <p>Note</p> <p>You may opt not to have any output from tracee with <code>--output none</code> command flag is given. This makes tracee to work in capture mode only.</p> </li> <li> <p>Network PCAP Files</p> <p>Anytime a network packet is delivered to a process, traced by tracee, this packet might be captured into one or multiple pcap files.</p> <p>Attention</p> <p>The default behavior when capturing network traffic is to capture ALL traffic, despite given event filters. If you want to make capture feature to follow the given event filters, like for example capturing DNS events only, then you have to provide <code>--capture pcap-options:filtered</code> argument in the command line. Then only net_packet_XXX events will be captured (IPv4, IPv6, TCP, UDP, ICMP, ICMPv6, DNS, HTTP, etc).</p> <p>A good way to test this behavior is to execute:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_ipv4 \\\n    --capture network \\\n    --capture pcap-options:filtered\n</code></pre> <p>and observe a single pcap file for all ipv4 packets created:</p> <pre><code>find /tmp/tracee/out/pcap/\n</code></pre> <pre><code>/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n</code></pre> <p>You can select only dns packets, for example:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_dns \\\n    --capture network \\\n    --capture pcap-options:filtered\n</code></pre> <p>and the file <code>/tmp/tracee/out/pcap/single.pcap</code> would only contain DNS related packets:</p> <pre><code>find /tmp/tracee/out/pcap/\n</code></pre> <pre><code>/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n</code></pre> <pre><code>sudo tcpdump -n -r /tmp/tracee/out/pcap/single.pcap | head -2\n</code></pre> <pre><code>reading from file /tmp/tracee/out/pcap/single.pcap, link-type NULL (BSD loopback), snapshot length 262144\n16:53:48.870629 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 33361+ [1au] A? www.uol.com.br. (43)\n16:53:48.870690 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 25943+ [1au] AAAA? www.uol.com.br. (43)\n</code></pre> <p>A great thing is that you may have multiple pcap files, divided by:</p> <ol> <li>single: a single pcap file containing all packets (the default)</li> <li>process: one file per process executed, ordered by host and container</li> <li>container: one file for the host and one pcap file per container</li> <li>per-command: one file per command executed (even if multiple times)</li> </ol> <p>and you can even have multiple ways at the same time. Example: a ping command is executed inside a container. You want to summarize captured traffic per container and per command. You will find the same captured data for that ping command inside <code>commands/container_id/ping.pcap</code> and inside <code>containers/container_id.pcap</code>.</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_icmp \\\n    --capture network \\\n    --capture pcap-options:filtered \\\n    --capture pcap:process,container,command\n</code></pre> <pre><code>cd /tmp/tracee/out\nfind pcap\n</code></pre> <pre><code>pcap\npcap/commands\npcap/commands/b86533d11f3\npcap/commands/b86533d11f3/ping.pcap\npcap/commands/host\npcap/commands/host/sshd.pcap\npcap/commands/host/zerotier-one.pcap\npcap/commands/host/node.pcap\npcap/commands/fd95a035ce5\npcap/commands/fd95a035ce5/ping.pcap\npcap/processes\npcap/processes/b86533d11f3\npcap/processes/b86533d11f3/ping_1261180_1663772450241192.pcap\npcap/processes/host\npcap/processes/host/node_186708_1573567360495399.pcap\npcap/processes/host/node_1196826_1662656211119567.pcap\npcap/processes/host/zerotier-one_7882_137007714376.pcap\npcap/processes/host/sshd_1196773_1662654999660718.pcap\npcap/processes/fd95a035ce5\npcap/processes/fd95a035ce5/ping_1261163_1663769383806467.pcap\npcap/containers\npcap/containers/host.pcap\npcap/containers/b86533d11f3.pcap\npcap/containers/fd95a035ce5.pcap\n</code></pre> <p>you can see the packets by executing tcpdump on any pcap file:</p> <pre><code>tcpdump -r pcap/containers/b86533d11f3.pcap\n</code></pre> <pre><code>reading from file pcap/containers/b86533d11f3.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n</code></pre> <pre><code>tcpdump -r pcap/commands/b86533d11f3/ping.pcap\n</code></pre> <pre><code>reading from file pcap/commands/b86533d11f3/ping.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n</code></pre> <p>Note</p> <p>Note that the same packets were written to 2 different pcap files: the pcap file describing the container <code>b86533d11f3</code> (because it was executing a single process: ping) and the pcap file describing ANY ping command executed in that container (commands/b86533d11f3/ping.pcap).</p> <p>The format for the pcap filenames inside <code>output_dir</code> is the following:</p> <ol> <li>single:    ./pcap/single.pcap</li> <li>processes:    ./pcap/processes/<code>container_id</code>/<code>process_comm</code>/<code>host_tid</code>/<code>task_starttime</code>.pcap</li> <li>containers:    ./pcap/containers/<code>container_id</code>.pcap</li> <li>commands:    ./pcap/commands/<code>container_id</code>/<code>process_comm</code>.pcap</li> </ol> <p>Attention</p> <p>By default, all pcap files will contain packets with headers only. That might too little for introspection, since sometimes one might be interested in a few bytes of the captured packet (or event it all). Next item shows how to capture a specific packet payload size.</p> <p>In order to capture a specific payload size you may specify:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_tcp \\\n    --capture network \\\n    --capture pcap-options:filtered \\\n    --capture pcap:single,command \\\n    --capture pcap-snaplen:default\n</code></pre> <p>To capture packet headers + 96 bytes of payload. Or replace <code>default</code> by:</p> <ol> <li>headers: capture up to L4 headers only</li> <li>max: full sized packets into pcap. WARNING: big pcap files.</li> <li>256b, 512b, 1024b, ... (any number plus \"b\")</li> <li>16kb, 32kb, 64kb,  ... (any number plus \"kb\")</li> </ol> <p>when specifying a payload size, it refers to the payload AFTER the layer4 headers (and not the entire packet length).</p> </li> <li> <p>Loaded Kernel Modules</p> <p>Anytime a kernel module is loaded, the binary file will be captured. If the same binary is loaded multiple times, it will be captured just once.</p> <pre><code>sudo ./dist/tracee \\\n    --output none \\\n    --scope comm=bash \\\n    --scope follow \\\n    --capture clear-dir \\\n    --capture module\n</code></pre> <p>Captured module will be found in tracee destination directory, just like any other captured file would be:</p> <pre><code>sudo ls /tmp/tracee/out/host\n</code></pre> <pre><code>module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <p>AND, the captured module is an exact copy of the loaded module:</p> <pre><code>sudo rmmod lkm_example\nsudo insmod /tmp/tracee/out/host/module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <pre><code>lsmod | grep example\n\n```text\nlkm_example            16384  0\n</code></pre> <pre><code>sudo rmmod lkm_example\n</code></pre> <p>you can even load/unload it.</p> <p>Note</p> <p>Example kernel module taken from this blog</p> </li> <li> <p>BPF programs</p> <p>Wheneber a BPF program is loaded, the BPF bytecode will be captured. This captured bytecode represents the BPF program as it was loaded by the loading process. It is basically the BPF section of the compiled ELF that loads the BPF program, which contains the program instructions themselves. You can disassemble the bytecode with the help of <code>binutils-bpf</code> package and the following command line: <code>objdump -D -b binary -m bpf &lt;path&gt;</code></p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --scope comm=bash \\\n   --scope follow \\\n   --capture clear-dir \\\n   --capture bpf\n</code></pre> <p>Captured bpf bytecode will be found in tracee destination directory, just like any other captured file would be:</p> <p><pre><code>$ sudo ls /tmp/tracee/out/host\n  bpf.name-test_prog.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre>    The hex value after the last \".\" is the hash of the bpf bytecode.</p> </li> </ol>"},{"location":"docs/advanced/ksyms/","title":"About Kernel symbols","text":"<p>As explained in the prerequisites doc, Tracee  needs the kernel symbol table for some operations.</p> <p>A Linux kernel might lack the <code>/proc/kallsyms</code> file due to:</p> <p>Kernel Configuration: If compiled without <code>CONFIG_KALLSYMS</code>, the kernel won't have this file. This option enables the kernel symbol table, used mainly for debugging.</p> <p>Security Protocols: Some systems might hide kernel symbols to prevent potential exploits. The <code>/proc/kallsyms</code> file could appear incomplete or even empty to non-root users. The <code>CONFIG_KALLSYMS_ALL</code> option ensures all symbols are visible.</p> <p>The Linux kernel also offers a setting, <code>/proc/sys/kernel/kptr_restrict</code>, to control kernel symbol visibility:</p> <ul> <li>0: No restrictions.</li> <li>1: Hide from non-privileged users.</li> <li>2: Hide from all users.</li> </ul>"},{"location":"docs/advanced/mac/","title":"Tracee on Apple Mac FAQ","text":""},{"location":"docs/advanced/mac/#does-tracee-run-on-macos","title":"Does Tracee run on MacOS?","text":"<p>No. Tracee runs only on Linux operating system. But you can run a Linux VM on your Mac, and then run Tracee in it. Please note though, that with this setup Tracee will only have visibility to the Linux VM it is running in, and not the host Mac machine.</p>"},{"location":"docs/advanced/mac/#does-tracee-run-on-apple-silicon","title":"Does Tracee run on Apple Silicon?","text":"<p>Apple Silicon (a.k.a <code>M#</code> CPUs) utilizes the ARM64 CPU architecture. Given that Tracee is compatible with ARM64, it should run on Apple Silicon as well.</p>"},{"location":"docs/advanced/mac/#does-tracee-run-in-a-linux-container-on-macos","title":"Does Tracee run in a Linux container on MacOS?","text":"<p>Yes. It is very common to install a container engine (e.g Docker Desktop) on MacOS and still be able to run Linux containers. This works by creating a Linux virtual machine inside your MacOS and running the container engine and all your containers from inside it. Note that with this setup Tracee will only have visibility to that Linux VM which is dedicated for the container engine, and not to your Mac machine. If you wanted to run something and see how Tracee reacts to it, you can run it as another container which should be visible to Tracee.</p>"},{"location":"docs/advanced/mac/#linuxkit","title":"Linuxkit","text":"<p>linuxkit is a popular Linux distribution used by Docker Desktop and other solutions. Linux kit does not have the Kernel Symbols Table feature properly configured by default, which is a prerequisite for running Tracee. It is technically possible to enable kernel symbols in linuxkit but an easier solution would be to  disable those Tracee events that depend on kernel symbols.</p>"},{"location":"docs/advanced/ordering-events/","title":"Special: Ordering Events","text":"<p>Package sorting feature is responsible for sorting incoming events from the BPF programs chronologically.</p> <pre><code>sudo ./dist/tracee \\\n    -o json \\\n    -o option:parse-arguments \\\n    -o option:sort-events\n</code></pre> <p>Information</p> <p>There are 3 known sources to events sorting issues:</p> <ol> <li> <p>In perf buffer, events are read in round robing order from CPUs buffers      (and not according to invocation time).</p> </li> <li> <p>Syscall events are invoked after internal events of the syscall (though      the syscall happened before the internal events).</p> </li> <li> <p>Virtual CPUs might enter sleep mode by host machine scheduler and send      events after some delay.</p> </li> </ol>"},{"location":"docs/advanced/ordering-events/#deep-dive-into-sorting-feature","title":"Deep Dive Into Sorting Feature","text":"<p>To address the events perf buffers issue, the events are divided to queues according to the source CPU. This way the events are almost ordered (except for syscalls). The syscall events are inserted to their right chronological place manually.</p> <p>This way, all events which occurred before the last event of the most delaying CPU could be sent forward with guaranteed order.</p> <p>To make sure syscall events are not missed when sending, a small delay is needed. Lastly, to address the vCPU sleep issue (which might cause up to 2 events received in a delay), the events need to be sent after a delay which is bigger than max possible vCPU sleep time (which is just an increase of the syscall events delay sending).</p>"},{"location":"docs/advanced/ordering-events/#algorithm-for-nerds-d","title":"Algorithm for Nerds =D","text":"<p>To summarize the algorithm main logic, here is textual simulation of the operation (assume that 2 scheduler ticks are larger than max possible vCPU sleep time):  </p> <p>Tn = Timestamp (n == TOD) #m = Event's Source CPU  </p> <ol> <li> <p>Initial State</p> <pre><code>       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5\n          T6\n  TAIL    T8\n</code></pre> </li> <li> <p>Scheduler Tick #1</p> <pre><code>Incoming events: T9#1, T11#2, T13#1, T10#2, T12#2\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5           T10 +\n          T6           T9  +        T11 +\n  TAIL    T8           T13 +        T12 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T8 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T8.\n  - Bigger timestamps than T8 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #2</p> <pre><code>Incoming events: T7#0, T22#1, T23#2, T20#0, T25#1, T24#2, T21#0\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1  ^        T2  ^        T4  ^\n          T3  ^        T5  ^        T10\n          T6  ^        T9           T11\n          T7  +^       T13          T12\n          T8  ^        T22 +        T23 +\n          T20 +        T25 +        T24 +\n  TAIL    T21 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T21 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T21.\n  - T8 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T8.\n  - Bigger timestamps than T21 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #3</p> <pre><code>Incoming events: T30#0, T34#1, T35#2, T31#0, T36#2, T32#0, T37#2, T33#0, T38#2, T50#1, T51#1\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T20 ^        T9  ^        T10 ^\n          T21 ^        T13 ^        T11 ^\n          T30 +        T22          T12 ^\n          T31 +        T23          T24\n          T32 +        T25          T35 +\n          T33 +        T34 +        T36 +\n                       T50 +        T37 +\n   TAIL                T51 +        T38 +\n\n  - Max sent timestamp = T8.\n  - Oldest timestamp = T9.\n  - T33 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T33.\n  - T21 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T21.\n  - Bigger timestamps than T33 (+) will be sent in future scheduling.\n</code></pre> </li> </ol>"},{"location":"docs/advanced/os-info/","title":"Special: Overriding OS needed files","text":"<p>Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config).</p> <p>Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed.</p>"},{"location":"docs/advanced/os-info/#os-release","title":"OS-RELEASE","text":"<p>Tracee will show you collected information about the running Linux OS with the <code>--log debug</code> argument:</p> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976393.7308447,\"msg\":\"osinfo\",\"ARCH\":\"x86_64\",\"PRETTY_NAME\":\"\\\"Manjaro Linux\\\"\",\"ID\":\"manjaro\",\"ID_LIKE\":\"arch\",\"BUILD_ID\":\"rolling\",\"KERNEL_RELEASE\":\"5.15.81-1-MANJARO\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670976393.73088,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.730894,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7309017,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7310617,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670976393.733237,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":true,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670976393.7332687,\"msg\":\"BPF: using embedded BPF object\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":69}\n{\"level\":\"debug\",\"ts\":1670976393.7355402,\"msg\":\"unpacked CO:RE bpf object file into memory\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":144}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n21:06:35:386730  1000   gio-launch-desk  743960  743960  0                execve               pathname: /home/gg/.local/bin/gnome-terminal, argv: [gnome-terminal]\n...\n</code></pre> <p>BUT os-release file might not exist:</p> <p>Because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face the following error:</p> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976530.5685039,\"msg\":\"osinfo\", \"warning: os-release file could not be found\",\"error\",\"open /etc/os-release: no such file or directory\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":33}\n...\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n\nEnd of events stream\nStats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> <p>Note</p> <p>But do note that tracee shall continue working (informing only the KERNEL_RELEASE OSInfo option).</p> <p>If you need to override the underlying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee by using LIBBPFGO's environment variable <code>LIBBPFGO_OSRELEASE_FILE</code>:</p> <pre><code>sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee --scope uid=1000 --scope pid=new --events execve\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount <code>/etc/os-release</code> from the host as <code>/etc/os-release-host</code> into the guest.</p>"},{"location":"docs/advanced/os-info/#kconfig","title":"KCONFIG","text":"<p>Tracee needs access to kconfig file (/proc/config.gz OR /boot/config-$(uname -r)) in order to:</p> <ol> <li>Check if the kernel of your running environment supports needed eBPF features</li> <li>Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions)</li> </ol> <p>Warning</p> <p>Tracee should NOT fail when it cannot find a kconfig file or needed options:</p> <ul> <li>missing kconfig file</li> </ul> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976875.7735798,\"msg\":\"osinfo\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n...\n{\"level\":\"warn\",\"ts\":1670976875.7762284,\"msg\":\"KConfig: could not check enabled kconfig features\",\"error\":\"could not read /boot/config-5.4.0-91-generic: stat /boot/config-5.4.0-91-generic: no such file or directory\"}\n{\"level\":\"warn\",\"ts\":1670976875.7762842,\"msg\":\"KConfig: assuming kconfig values, might have unexpected behavior\"}\n...\n{\"level\":\"debug\",\"ts\":1670976876.0801573,\"msg\":\"KConfig: warning: assuming kconfig values, might have unexpected behavior\",\"pkg\":\"initialization\",\"file\":\"kconfig.go\",\"line\":30}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <ul> <li>missing kconfig options</li> </ul> <pre><code>{\"level\":\"warn\",\"ts\":1698759121.4432194,\"msg\":\"KConfig: could not detect kconfig options\",\"options\":[...]}\n</code></pre> <p>But do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies.</p> <p>If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable:</p> <pre><code>sudo LIBBPFGO_KCONFIG_FILE=/boot/config-other -E ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670979362.3586345,\"msg\":\"osinfo\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670979362.358663,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586702,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"docker\",\"error\":\"failed to register runtime socket stat /var/run/docker.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586755,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586833,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3588264,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670979362.3639433,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670979362.363965,\"msg\":\"BPF: no BTF file was found or provided\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":108}\n{\"level\":\"debug\",\"ts\":1670979362.3639715,\"msg\":\"BPF: trying non CO-RE eBPF\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-365-g0bac8f68.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":109}\n{\"level\":\"debug\",\"ts\":1670979362.4866858,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime containerd\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":64}\n{\"level\":\"debug\",\"ts\":1670979362.486713,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime crio\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":68}\n{\"level\":\"debug\",\"ts\":1670979362.486717,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime docker\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":72}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable.</p> <p>Attention</p> <p>In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors.</p>"},{"location":"docs/advanced/secure-tracing/","title":"FAQ - Frequently Asked Questions","text":"<ol> <li> <p>Secure tracing</p> <p>When tracee reads information from user programs, it is subject to a race condition where the user program might be able to change the arguments after tracee read them.</p> <p>For example, a program invoked:</p> <pre><code>execve(\"/bin/ls\", NULL, 0)\n</code></pre> <p>Tracee picked that up and will report that, then the program changed the first argument from <code>/bin/ls</code> to <code>/bin/bash</code>, and this is what the kernel will execute.</p> <p>To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the <code>bprm_check</code> event which can be reported by Tracee and cross-referenced with the reported regular syscall event.</p> </li> </ol>"},{"location":"docs/advanced/data-sources/custom/","title":"Custom data sources","text":"<p>Custom data sources are currently supported through the plugin mechanism.</p> <p>Attention</p> <p>Eventually you will find out that Golang Plugins aren't very useful if you consider all the problems that emerge from using it:</p> <ol> <li> <p>Can't use different go versions (need to compile the go plugin     with the exact same version that was used to build Tracee).</p> </li> <li> <p>Both Tracee and your golang plugin data source must be built with the     exact same GOPATH or you will get a \"plugin was built with a     different version of package XXX\" error.</p> </li> <li> <p>Any dependency you have in your plugin should be of the same     version with the dependencies of Tracee.</p> </li> <li> <p>Compiling tracee statically is sometimes useful to have a complete     portable eBPF tracing/detection solution. One good example when     statically compiling tracee is a good idea is to have a single     binary capable of running in GLIBC (most of them) and MUSL (Alpine)     powered Linux distros.</p> </li> </ol> <p>At the end, creating a golang data source plugin won't have the practical effects as a plugin mechanism should have, so it is preferred to have built-in data source (re)distributed with newer binaries (when you need to add/remove data sources from your environment) FOR NOW.</p> <p>There are two main reasons to write your own data source:</p> <ol> <li>To provide a stable \"tracee-native\" querying API for some externally owned data you need in a signature (for example some DB access)</li> <li>To provide an externally writable and internally readable data source in a data source (for example configuration)</li> </ol> <p>An example for an implementation of the latter is given here.</p>"},{"location":"docs/advanced/data-sources/custom/#integrating-into-a-plugin","title":"Integrating into a plugin","text":"<p>Since Data Sources should usually be supplied alongside a relevant data source, providing them is as easy as using another symbol in the plugin.</p> <p>Simply add the following symbol in your plugin entrypoint: <pre><code>    var ExportedDataSources = []detect.DataSource{\n        ...\n        mydatasource.New(someDependency),\n    }\n</code></pre></p> <p>And the data source will be available in data sources through the specified namespace and id given in your code.</p>"},{"location":"docs/advanced/data-sources/overview/","title":"Data Sources (Experimental)","text":"<p>Data sources are a new feature, which will be the base of allowing access to dynamic data stores in signature writing (currently only available in golang).</p> <p>Data sources are currently an experimental feature and in active development, and usage is opt-in.</p>"},{"location":"docs/advanced/data-sources/overview/#why-use-data-sources","title":"Why use data sources?","text":"<p>Signatures should opt for data sources when they need access to data beyond what is provided by the events they process.</p> <p>For instance, a signature may need access to data about the container where the event being processed was generated. With Tracee's integrated container data source, this can be achieved without the signature having to separately monitor container lifecycle events.</p>"},{"location":"docs/advanced/data-sources/overview/#what-data-sources-can-i-use","title":"What data sources can I use","text":"<p>Tracee offer three built-in data sources out of the box. There is also support for plugging in external data sources through the golang  plugin mechanism, similar to how signatures are currently supplied (see here).  However, there are known technical limitation to this approach, and the aim is to replace it in the future.</p> <p>Currently, the following data source are provided out of the box:</p> <ol> <li>Containers: Provides metadata about containers given a container id.</li> <li>Process Tree: Provides access to a tree of ever existing processes and threads.</li> <li>DNS Cache: Provides access to relaated DNS queries of a given address (IP or domain).</li> </ol> <p>This list will be expanded as other features are developed.</p>"},{"location":"docs/advanced/data-sources/overview/#how-to-use-data-sources","title":"How to use data sources","text":"<p>In order to use a data source in a signature you must request access to it in the <code>Init</code> stage. This can be done through the <code>SignatureContext</code> passed at that stage as such:</p> <pre><code>func (sig *mySig) Init(ctx detect.SignatureContext) error {\n    ...\n    containersData, ok := ctx.GetDataSource(\"tracee\", \"containers\")\n if !ok {\n  return fmt.Errorf(\"containers data source not registered\")\n }\n    if containersData.Version() &gt; 1 {\n  return fmt.Errorf(\"containers data source version not supported, please update this signature\")\n }\n sig.containersData = containersData\n}\n</code></pre> <p>As you can see, access to the data source has been requested using two keys: a namespace and a data source ID. Namespaces are employed to prevent name conflicts in the future when integrating custom data sources. All built-in data sources from Tracee will be available under the \"tracee\" namespace.</p> <p>After verifying the data source's availability, it's suggested to include a version check against the data source. This approach ensures that outdated signatures aren't run with a newer data source schema.</p> <p>Now, in the <code>OnEvent</code> function, you may use the data source like so:</p> <pre><code>container, err := sig.containersData.Get(containerId)\nif !ok {\n    return fmt.Errorf(\"failed to find container in data source: %v\", err)\n}\n\ncontainerName := container[\"container_name\"].(string)\n</code></pre> <p>Each Data source provides a querying method <code>Get(key any) map[string]any</code>. In the provided example, type validation is omitted during key verification. This omission is safe when adhering to the schema (provided by the <code>Schema()</code> method), considering the JSON representation of the returned map, and after an initial check of the data source version.</p>"},{"location":"docs/advanced/data-sources/write/","title":"Writable Data Sources","text":"<p>Since v0.20.0 tracee includes a new <code>DataSourceService</code> in its gRPC server. This service includes the ability to write generic data into a specified data source, both through streaming and unary methods.  However, in order to utilize this feature, a speciailized <code>WritableDataSource</code> must be specified in the RPC arguments. These data sources are currently only available through custom data sources, meaning that no built-in data sources support this feature.</p>"},{"location":"docs/advanced/data-sources/write/#how-to-use","title":"How to use","text":""},{"location":"docs/advanced/data-sources/write/#implementing-a-writable-data-source","title":"Implementing a writable data source","text":"<p>Let us implement an example data source which will give us a configurable threshold for reporting some finding.</p> <p>Start by adding a file <code>threshold_datasource.go</code>: <pre><code>    package datasourcetest\n\n    import (\n        \"encoding/json\"\n\n        \"github.com/aquasecurity/tracee/types/detect\"\n    )\n\n    type thresholdDataSource struct {\n        threshold int\n    }\n\n    func (ctx *e2eWritable) Get(key interface{}) (map[string]interface{}, error) {\n        keyVal, ok := key.(string)\n        if !ok {\n            return nil, detect.ErrKeyNotSupported\n        }\n\n        if keyVal != \"threshold\" {\n            return nil, detect.ErrKeyNotSupported\n        }\n\n        return map[string]interface{}{\n            \"threshold\": ctx.threshold,\n        }, nil\n    }\n\n    func (ctx *e2eWritable) Version() uint {\n        return 1\n    }\n\n    func (ctx *e2eWritable) Keys() []string {\n        return []string{\"string:\\\"threshold\\\"\"}\n    }\n\n    func (ctx *e2eWritable) Schema() string {\n        schema := map[string]interface{}{\n            \"threshold\": \"int\",\n        }\n\n        s, _ := json.Marshal(schema)\n        return string(s)\n    }\n\n    func (ctx *e2eWritable) Namespace() string {\n        return \"my_namespace\"\n    }\n\n    func (ctx *e2eWritable) ID() string {\n        return \"threshold_datasource\"\n    }\n\n    func (ctx *e2eWritable) Write(data map[interface{}]interface{}) error {\n        threshold, ok := data[\"threshold\"]\n        if !ok {\n            return detect.ErrFailedToUnmarshal\n        }\n\n        // Currently we pass the gRPC values directly, so numbers are sent as float64\n        thresholdFloat, ok := threshold.(float64)\n        if !ok {\n            return detect.ErrFailedToUnmarshal\n        }\n\n        ctx.threshold = int(thresholdFloat)\n        return nil\n    }\n\n    func (ctx *e2eWritable) Values() []string {\n        return []string{\"string\"}\n    }\n</code></pre></p> <p>Note</p> <p>Unpacking values from the given data dictionary has a specific quirk about value unwrapping. Currently only the gRPC API is given for writing to data sources, which uses the struct.proto package for passing generic values.  There is currently no abstraction layer over it, which is why we unpacked the threshold value as float64 in the example, despite wanting  it as an int in the end.</p>"},{"location":"docs/advanced/data-sources/write/#using-in-a-signature","title":"Using in a signature","text":"<p>Now we can use this data source just like we would any other in a signature through the following code: <pre><code>    func (sig *mySig) Init(ctx detect.SignatureContext) error {\n    ...\n    thresholdDataSource, ok := ctx.GetDataSource(\"my_namespace\", \"threshold_datasource\")\n    if !ok {\n        return fmt.Errorf(\"threshold data source not registered\")\n    }\n    if thresholdDataSource.Version() &gt; 1 {\n        return fmt.Errorf(\"threshold data source version not supported, please update this signature\")\n    }\n    sig.thresholdData = thresholdDataSource\n    }\n</code></pre></p>"},{"location":"docs/advanced/data-sources/write/#writing-to-the-data-source","title":"Writing to the data source","text":"<p>The following is a short example for a go program which will implement a client for out threshold data source. Note that this is a minimal outline, and you should modify it based on your specific usecase: <pre><code>package main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"os\"\n\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n    \"google.golang.org/protobuf/types/known/structpb\"\n\n    \"github.com/aquasecurity/tracee/api/v1beta1\"\n)\n\nfunc printAndExit(msg string, args ...any) {\n    fmt.Printf(msg, args...)\n    os.Exit(1)\n}\n\nfunc main() {\n    traceeAddressPtr := flag.String(\"key\", \"\", \"key to set in the data source\")\n    thresholdPtr := flag.Int(\"value\", \"\", \"key to set in the data source\")\n    flag.Parse()\n\n    traceeAddress := *traceeAddressPtr\n    threshold := *thresholdPtr\n\n    if traceeAddress == \"\" {\n        printAndExit(\"empty address given\\n\")\n    }\n    if threshold == 0 {\n        printAndExit(\"empty threshold given\\n\")\n    }\n    if threshold &lt; 0 {\n        printAndExit(\"negative threshold given\\n\")\n    }\n\n    conn, err := grpc.Dial(\n        traceeAddress,\n        grpc.WithTransportCredentials(insecure.NewCredentials()),\n    )\n    if err != nil {\n        printAndExit(\"failed to dial tracee grpc server: %v\\n\", err)\n    }\n    client := v1beta1.NewDataSourceServiceClient(conn)\n    _, err = client.Write(context.Background(), &amp;v1beta1.WriteDataSourceRequest{\n        Id:        \"my_namespace\",\n        Namespace: \"threshold_datasource\",\n        Key:       structpb.NewStringValue(\"threshold\"),\n        Value:     structpb.NewNumberValue(float64(threshold)),\n    })\n\n    if err != nil {\n        printAndExit(\"failed to write to data source: %v\\n\", err)\n    }\n}\n</code></pre></p> <p>With all these steps completed, you are ready to impelement and use your own writable data source!</p>"},{"location":"docs/advanced/data-sources/builtin/containers/","title":"Containers Data Source","text":"<p>The container enrichment feature gives Tracee the ability to extract details about active containers and link this information to the events it captures.</p> <p>The data source feature makes the information gathered from active containers accessible to signatures. When an event is captured and triggers a signature, that signature can retrieve information about the container using its container ID, which is bundled with the event being analyzed by the signature.</p>"},{"location":"docs/advanced/data-sources/builtin/containers/#internal-data-organization","title":"Internal Data Organization","text":"<p>From the data-sources documentation, you'll see that searches use keys. It's a bit like looking up information with a specific tag (or a key=value storage).</p> <p>The <code>containers data source</code> operates straightforwardly. Using <code>string</code> keys, which represent the container IDs, you can fetch <code>map[string]string</code> values as shown below:</p> <pre><code>    schemaMap := map[string]string{\n        \"container_id\":      \"string\",\n        \"container_name\":    \"string\",\n        \"container_image\":   \"string\",\n        \"k8s_pod_id\":        \"string\",\n        \"k8s_pod_name\":      \"string\",\n        \"k8s_pod_namespace\": \"string\",\n        \"k8s_pod_sandbox\":   \"bool\",\n    }\n</code></pre> <p>From the structure above, using the container ID lets you access details like the originating Kubernetes pod name or the image utilized by the container.</p>"},{"location":"docs/advanced/data-sources/builtin/containers/#using-the-containers-data-source","title":"Using the Containers Data Source","text":"<p>Make sure to read Golang Signatures first.</p>"},{"location":"docs/advanced/data-sources/builtin/containers/#signature-initialization","title":"Signature Initialization","text":"<p>During the signature initialization, get the containers data source instance:</p> <pre><code>type e2eContainersDataSource struct {\n    cb             detect.SignatureHandler\n    containersData detect.DataSource\n}\n\nfunc (sig *e2eContainersDataSource) Init(ctx detect.SignatureContext) error {\n    sig.cb = ctx.Callback\n    containersData, ok := ctx.GetDataSource(\"tracee\", \"containers\")\n    if !ok {\n        return fmt.Errorf(\"containers data source not registered\")\n    }\n    sig.containersData = containersData\n    return nil\n}\n</code></pre> <p>Then, to each event being handled, you will <code>Get()</code>, from the data source, the information needed.</p>"},{"location":"docs/advanced/data-sources/builtin/containers/#on-events","title":"On Events","text":"<p>Given the following example:</p> <pre><code>func (sig *e2eContainersDataSource) OnEvent(event protocol.Event) error {\n    eventObj, ok := event.Payload.(trace.Event)\n    if !ok {\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    switch eventObj.EventName {\n    case \"sched_process_exec\":\n        containerId := eventObj.Container.ID\n        if containerId == \"\" {\n            return fmt.Errorf(\"received non container event\")\n        }\n\n        container, err := sig.containersData.Get(containerId)\n        if !ok {\n            return fmt.Errorf(\"failed to find container in data source: %v\", err)\n        }\n\n        containerImage, ok := container[\"container_image\"].(string)\n        if !ok {\n            return fmt.Errorf(\"failed to obtain the container image name\")\n        }\n\n        m, _ := sig.GetMetadata()\n\n        sig.cb(detect.Finding{\n            SigMetadata: m,\n            Event:       event,\n            Data:        map[string]interface{}{},\n        })\n    }\n\n    return nil\n}\n</code></pre> <p>You may see that, through the <code>event object container ID</code> information, you may query the data source and obtain the <code>container name</code> or any other information listed before.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/","title":"DNS Cache Data Source","text":"<p>The <code>DNS Cache</code> feature allows to tracee build an accurate image of dns and ip relations. These relations can be queried in signatures through a data source.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#enabling-the-feature","title":"Enabling the Feature","text":"<p>To switch on the <code>DNS Cache</code> feature, run the command:</p> <pre><code>sudo tracee --output option:sort-events --output json --output option:parse-arguments --dnscache enable --events &lt;event_type&gt;\n</code></pre> <p>The underlying structure is populated using the core net_packet_dns event and its payload.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#command-line-option","title":"Command Line Option","text":"<pre><code>$ tracee --dnscache help\nSelect different options for the DNS cache.\n\nExample:\n  --dnscache enable  | enable with default values (see below).\n  --dnscache size=X  | will cache up to X dns query trees - further queries may be cached regardless (default: 5000).\n\nUse comma OR use the flag multiple times to choose multiple options:\n  --dnscache size=A\n  --dnscache enable\n</code></pre> <p>Consider for your usecase, how many query trees would you like to store? If you will frequently check only a few addresses, consider lowering the size.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#internal-data-organization","title":"Internal Data Organization","text":"<p>From the data-sources documentation, you'll see that searches use keys. It's a bit like looking up information with a specific tag (or a key=value storage).</p> <p>The <code>dns data source</code> operates straightforwardly. Using <code>string</code> keys, which represent some network address (a domain or IP), you can fetch <code>map[string]string</code> values as shown below:</p> <pre><code>    schemaMap := map[string]string{\n        \"ip_addresses\": \"[]string\",\n        \"dns_queries\":  \"[]string\",\n        \"dns_root\":     \"string\",\n    }\n</code></pre> <p>Any address found in the cache, and other related addresses, will be returned in the above structure. Particulary useful is the <code>dns_root</code> field, which will store the initial dns query which all other addresses derive from.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#using-the-containers-data-source","title":"Using the Containers Data Source","text":"<p>Make sure to read Golang Signatures first.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#signature-initialization","title":"Signature Initialization","text":"<p>During the signature initialization, get the containers data source instance:</p> <pre><code>type e2eDnsDataSource struct {\n    cb      detect.SignatureHandler\n    dnsData detect.DataSource\n}\n\nfunc (sig *e2eDnsDataSource) Init(ctx detect.SignatureContext) error {\n    sig.cb = ctx.Callback\n    dnsData, ok := ctx.GetDataSource(\"tracee\", \"dns\")\n    if !ok {\n        return fmt.Errorf(\"dns data source not registered\")\n    }\n    if dnsData.Version() &gt; 1 {\n        return fmt.Errorf(\"dns data source version not supported, please update this signature\")\n    }\n    sig.dnsData = dnsData\n    return nil\n}\n</code></pre> <p>Then, to each event being handled, you will <code>Get()</code>, from the data source, the information needed.</p>"},{"location":"docs/advanced/data-sources/builtin/dns/#on-events","title":"On Events","text":"<p>Given the following example:</p> <pre><code>func (sig *e2eDnsDataSource) OnEvent(event protocol.Event) error {\n    eventObj, ok := event.Payload.(trace.Event)\n    if !ok {\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    switch eventObj.EventName {\n    case \"sched_process_exit\":\n        if eventObj.Executable.Path != \"/usr/bin/ping\" {\n            return nil // irrelevant code path\n        }\n\n        dns, err := sig.dnsData.Get(\"google.com\")\n        if err != nil {\n            return fmt.Errorf(\"failed to find dns data in data source: %v\", err)\n        }\n\n        ipResults, ok := dns[\"ip_addresses\"].([]string)\n        if !ok {\n            return fmt.Errorf(\"failed to extract ip results\")\n        }\n        if len(ipResults) &lt; 1 {\n            return fmt.Errorf(\"ip results were empty\")\n        }\n\n        dnsResults, ok := dns[\"dns_queries\"].([]string)\n        if !ok {\n            return fmt.Errorf(\"failed to extract dns results\")\n        }\n        if len(dnsResults) &lt; 1 {\n            return fmt.Errorf(\"dns results were empty\")\n        }\n        if dnsResults[0] != \"google.com\" {\n            return fmt.Errorf(\"bad dns query: %s\", dnsResults[0])\n        }\n\n        m, _ := sig.GetMetadata()\n\n        sig.cb(detect.Finding{\n            SigMetadata: m,\n            Event:       event,\n            Data:        map[string]interface{}{},\n        })\n    }\n\n    return nil\n}\n</code></pre> <p>The above signatures shows usage of the feature in a test signature found in our own e2e tests. The test validates a ping command sent to <code>google.com</code>.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/","title":"Process Tree Data","text":"<p>The <code>Process Tree</code> feature offers a structured view of processes and threads active in the system where Tracee is deployed. This setup facilitates quick access, updates, and tracking of processes, child processes, and related threads. All relationship and metadata data points for processes and threads are versioned, so you can pull data snapshots from a precise timestamp.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#enabling-the-feature","title":"Enabling the Feature","text":"<p>To switch on the <code>Process Tree</code> feature, run the command:</p> <pre><code>sudo tracee --output option:sort-events --output json --output option:parse-arguments --proctree source=both --events &lt;event_type&gt;\n</code></pre> <p>The underlying structure is populated using the core <code>sched_process_fork</code>, <code>sched_process_exec</code>, and <code>sched_process_exit</code> events and their args. There's also an option to bootstrap the process tree through a secondary route using internal signal events.</p> <p>Introducing this secondary event source is strategic: it reduces interference with actively traced events, leading to more accurate and granular updates in the process tree.</p> <p>The number of processes retained in the tree hinges on cache size. We have two separate caches at play: one for processes and another for threads. Both default to a size of 32K, supporting tracking for up to 32,768 processes and the same number of threads. It's worth noting that these are LRU caches: once full, they'll evict the least recently accessed entries to accommodate fresh ones.</p> <p>The process tree query the procfs upon initialization and during runtime to fill missing data: * During initialization, it runs over all procfs to fill all existing processes and threads * During runtime, it queries specific processes in the case of missing information caused by missing events. </p> <p>[!CAUTION] The procfs query might increase the feature toll on CPU and memory. The runtime query might have a snowball effect on lost events, as it will reduce the system resources in the processes of filling missing information.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#command-line-option","title":"Command Line Option","text":"<pre><code>$ tracee --proctree help\nExample:\n  --proctree source=[none|events|signals|both]\n      none         | process tree is disabled (default).\n      events       | process tree is built from events.\n      signals      | process tree is built from signals.\n      both         | process tree is built from both events and signals.\n  --proctree process-cache=8192   | will cache up to 8192 processes in the tree (LRU cache).\n  --proctree thread-cache=4096    | will cache up to 4096 threads in the tree (LRU cache).\n  --proctree disable-procfs-query | Will disable procfs quering during runtime\n\nUse comma OR use the flag multiple times to choose multiple options:\n  --proctree source=A,process-cache=B,thread-cache=C\n  --proctree process-cache=X --proctree thread-cache=Y\n</code></pre>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#internal-data-organization","title":"Internal Data Organization","text":"<p>For those looking to develop signatures or simply understand the underpinnings of the <code>Process Tree</code> feature, a grasp on its internal data organization is invaluable. At its core, the system is structured for fast access, updating, and tracking.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#hash-indexing","title":"Hash Indexing","text":"<p>Every entity in the <code>Process Tree</code>, be it a process or thread, is indexed using a distinctive hash, formulated by combining a task's <code>start time</code> and <code>thread id</code>. Events in the system come attached with this hash in their context under the <code>EntityID</code> label.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#core-components","title":"Core Components","text":"<ol> <li> <p>ProcessTree: A macro view of all the processes and threads active in the system.</p> <ul> <li>Processes: Defined either as a single-threaded application or the lead thread in a multi-thread application where the PID and TID are identical.</li> <li>Threads: Also known as Light-Weight Processes by the kernel, they include both separate threads and the thread group leader. Threads under the same leader share a PID but possess distinct TIDs.</li> </ul> </li> <li> <p>Process: A representation of individual processes. It contains:</p> <ul> <li>The process metadata using the <code>TaskInfo</code> structure.</li> <li>Information on its executable and interpreter using the <code>FileInfo</code> structure.</li> <li>References to its parent, child processes, and sibling threads within the same thread group.</li> </ul> </li> <li> <p>Thread: A representation of system threads. It contains:</p> <ul> <li>The thread metadata using the <code>TaskInfo</code> structure.</li> <li>Links to its parent and the its thread group leader.</li> </ul> </li> <li> <p>TaskInfo: From task names, PIDs, TIDs, PPIDs, ownership details, to start and end timestamps, it's all cataloged here. As tasks evolve, certain properties might shift. These changes are recorded using changelogs.</p> </li> <li> <p>TaskInfo: Acts as the central repository for task-specific attributes, including task names, PIDs (Process IDs), TIDs (Thread IDs), PPIDs (Parent Process IDs), and ownership UID/GID specifications. As task states transition within the kernel space, certain properties are subject to modification; such alterations are persistently tracked using changelogs.</p> </li> <li> <p>FileInfo: This structure aggregates file metadata, capturing attributes like path, device, and inode details. In the realm of processes, <code>FileInfo</code> is responsible for maintaining records of binaries and interpreters, with alterations being tracked in changelogs.</p> </li> </ol>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#process-tree-artifacts","title":"Process Tree Artifacts","text":"<p>In an upcoming update, the process tree will be enhanced with the addition of <code>artifacts</code>. Each process within the tree will be augmented with these \"artifacts\" to denote a task's various interactions and operations within the system. These artifacts, sourced from the tracing events provided by Tracee, offer a detailed depiction of a process's activities at the system level. Potential artifacts encompass:</p> <ul> <li>File Operations: Opened files, read/write activities, file deletion, and attribute changes.</li> <li>Network Activities: Sockets created, inbound/outbound connections, transmitted/received data packets, and protocol-specific operations (like TCP handshakes or UDP transmissions).</li> <li>System Calls: Executed syscalls, their arguments, and return values.</li> <li>Memory Activities: Memory allocation, deallocation, and page faults.</li> <li>Device Interactions: I/O operations on devices, device mounting/unmounting.</li> <li>Kernel Module Activities: Module load and unload operations.</li> <li>Security-Related Activities: Capabilities changes, SELinux operations, and AppArmor profile transitions.</li> </ul> <p>This enhancement aims to offer developers and sysadmins a more detailed and granular view of task behaviors, paving the way for better system monitoring, diagnostics, and potential threat detection.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#using-the-process-tree","title":"Using the Process Tree","text":"<p>The process tree is only available internally, to tracee's components, but, through the datasource mechanism, signatures are able to query the tree data using the data source process tree API.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#accessing-the-process-tree-data-source","title":"Accessing the Process Tree Data Source","text":"<p>Make sure to read Golang Signatures first.</p> <p>During the signature initialization, get the process tree data source instance:</p> <pre><code>type e2eProcessTreeDataSource struct {\n    cb            detect.SignatureHandler\n    processTreeDS detect.DataSource\n}\n\n// Init is called once when the signature is loaded.\nfunc (sig *e2eProcessTreeDataSource) Init(ctx detect.SignatureContext) error {\n    sig.cb = ctx.Callback\n\n    processTreeDataSource, ok := ctx.GetDataSource(\"tracee\", \"process_tree\")\n    if !ok {\n        return fmt.Errorf(\"data source tracee/process_tree is not registered\")\n    }\n\n    sig.processTreeDS = processTreeDataSource\n\n    return nil\n}\n</code></pre> <p>Then, to each event being handled, you will <code>Get()</code>, from the data source, the information needed. There are 3 types of information that can be requested:</p> <ol> <li>datasource.ProcKey: for process information retrieval.</li> <li>datasource.ThreadKey: for thread information retrieval.</li> <li>datasource.LineageKey: for process lineage information retrieval.</li> </ol> <p>Before explaining each request type and how to use them, consider the following signature <code>OnEvent()</code> handler example:</p> <pre><code>// OnEvent is called when a subscribed event occurs.\nfunc (sig *e2eProcessTreeDataSource) OnEvent(event protocol.Event) error {\n    eventObj, ok := event.Payload.(trace.Event)\n    if !ok {\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    switch eventObj.EventName {\n    case \"sched_process_exec\":\n        err = sig.check(&amp;eventObj)\n        if err != nil {\n            return err\n        }\n    }\n\n    // If all checks passed, send a finding\n    m, _ := sig.GetMetadata()\n\n    sig.cb(detect.Finding{\n        SigMetadata: m,\n        Event:       event,\n        Data:        map[string]interface{}{},\n    })\n\n    return nil\n}\n</code></pre> <p>Where the <code>check()</code> method will either be:</p> <ul> <li>checkProcess()</li> <li>checkThread()</li> <li>checkLineage()</li> </ul> <p>You can check related data structures directly in the source code for more information. Below you will find easy to understand examples.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#processes-information-retrieval","title":"Processes Information Retrieval","text":"<p>Utilize the data source instance object saved from the <code>Init()</code> method, and use the information from the current event to query the process tree for details about the process that triggered the event.</p> <pre><code>func (sig *e2eProcessTreeDataSource) checkProcess(eventObj *trace.Event) error {\n    // Pick the process info from the data source\n    procQueryAnswer, err := sig.processTreeDS.Get(\n        datasource.ProcKey{\n            EntityId: eventObj.ProcessEntityId,\n            Time:     time.Unix(0, int64(eventObj.Timestamp)),\n        })\n    if err != nil {\n        return fmt.Errorf(debug(\"could not find process\"))\n    }\n    processInfo, ok := procQueryAnswer[\"process_info\"].(datasource.ProcessInfo)\n    if !ok {\n        return fmt.Errorf(debug(\"could not extract info\"))\n    }\n\n    // Compare PID, NS PID and PPID\n    if processInfo.Pid != eventObj.HostProcessID {\n        return fmt.Errorf(debug(\"no match for pid\"))\n    }\n    if processInfo.NsPid != eventObj.ProcessID {\n        return fmt.Errorf(debug(\"no match for ns pid\"))\n    }\n    if processInfo.Ppid != eventObj.HostParentProcessID {\n        return fmt.Errorf(debug(\"no match for ppid\"))\n    }\n\n    // Check if the process lists itself in the list of its threads\n    threadExist := false\n    for tid := range processInfo.ThreadsIds {\n        if tid == eventObj.HostThreadID {\n            threadExist = true\n            break\n        }\n    }\n    if !threadExist {\n        return fmt.Errorf(debug(\"process not listed as thread\"))\n    }\n</code></pre> <p>From the data-sources documentation, you'll see that searches use keys. It's a bit like looking up information with a specific tag (or a key=value storage).</p> <p>In the provided example, the <code>eventObj.ProcessEntityId</code> key (which is the process hash accompanying the event being handled) is utilized alongside the <code>datasource.ProcKey{}</code> argument to search for a process in the process tree. The resulting process is the one associated with the event under consideration.</p> <p>Keep in mind that users can specify a time to retrieve the information. By using the event timestamp, you obtain data available up to that specific moment.</p> <p>Within the retrieved process object, you can find essential information about the running process. This includes details such as the binary associated with the executing program, the interpreter used for that program (either ld.so for ELF files or the relevant interpreters responsible for execution). In the near future, you can expect to see additional data related to the process, such as open files and sockets, known hosts and resolved names, utilized protocols, and more.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#threads-information-retrieval","title":"Threads Information Retrieval","text":"<pre><code>// checkThread checks if thread info in the data source matches the info from the event.\nfunc (sig *e2eProcessTreeDataSource) checkThread(eventObj *trace.Event) error {\n    // Pick the thread info from the data source\n    threadQueryAnswer, err := sig.processTreeDS.Get(\n        datasource.ThreadKey{\n            EntityId: eventObj.ThreadEntityId,\n            Time:     time.Unix(0, int64(eventObj.Timestamp)),\n        },\n    )\n    if err != nil {\n        return fmt.Errorf(debug(\"could not find thread\"))\n    }\n    threadInfo, ok := threadQueryAnswer[\"thread_info\"].(datasource.ThreadInfo)\n    if !ok {\n        return fmt.Errorf(debug(\"could not extract info\"))\n    }\n\n    // Compare TID, NS TID and PID\n    if threadInfo.Tid != eventObj.HostThreadID {\n        return fmt.Errorf(debug(\"no match for tid\"))\n    }\n    if threadInfo.NsTid != eventObj.ThreadID {\n        return fmt.Errorf(debug(\"no match for ns tid\"))\n    }\n    if threadInfo.Pid != eventObj.HostProcessID {\n        return fmt.Errorf(debug(\"no match for pid\"))\n    }\n\n    return nil\n}\n</code></pre> <p>In the example, the <code>eventObj.ThreadEntityId</code> key is used alongside the <code>datasource.ThreadKey{}</code> argument to search for a thread in the process tree. For applications that use only one thread, or the primary thread in multi-threaded applications, you'll find entries in both the processes and threads sections of the process tree. However, for simpler threads (commonly referred to as regular threads), they appear solely in the threads section.</p>"},{"location":"docs/advanced/data-sources/builtin/process-tree/#lineage-information-retrieval","title":"Lineage Information Retrieval","text":"<p>Using the <code>eventObj.ProcessEntityId</code> key (the process hash from the current event) in conjunction with the <code>datasource.LineageKey{}</code> argument allows retrieval of not just a singular process but multiple processes up the chain of ancestry: process, its parent, the parent's parent, and so forth. This capability is crucial for signatures that require analysis of process lineage and the associated artifacts of each process in that lineage.</p> <pre><code>func (sig *e2eProcessTreeDataSource) checkLineage(eventObj *trace.Event) error {\n    maxDepth := 5 // up to 5 ancestors + process itself\n\n    // Pick the lineage info from the data source.\n    lineageQueryAnswer, err := sig.processTreeDS.Get(\n        datasource.LineageKey{\n            EntityId: eventObj.ProcessEntityId,\n            Time:     time.Unix(0, int64(eventObj.Timestamp)),\n            MaxDepth: maxDepth,\n        },\n    )\n    if err != nil {\n        return fmt.Errorf(debug(\"could not find lineage\"))\n    }\n    lineageInfo, ok := lineageQueryAnswer[\"process_lineage\"].(datasource.ProcessLineage)\n    if !ok {\n        return fmt.Errorf(\"failed to extract ProcessLineage from data\")\n    }\n\n    compareMaps := func(map1, map2 map[int]uint32) bool {\n        return true // (or false)\n    }\n\n    // First ancestor is the process itself: lineageInfo[0] (ProcessInfo object)\n\n    for _, ancestor := range lineageInfo[1:] {\n        // do something with \"ancestor\" ProcessInfo\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"docs/events/","title":"Events","text":"<p>Events refer to the system activity that tracee monitors. There are two types of events, built-in events that are part of Tracee and custom events, which are user defined events. </p> <p>As part of built-in events, there are six types of events:</p> <ul> <li>syscalls </li> <li>network </li> <li>security </li> <li>lsm </li> <li>containers </li> <li>misc</li> </ul> <p>This section documents all of the different events that Tracee exposes.</p>"},{"location":"docs/events/#configuring-tracee-events","title":"Configuring Tracee Events","text":"<p>Events are defined in the Policy YAML manifest. </p> <p>Tracing the <code>execve</code> events in a policy:</p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: sample-policy\n    annotations:\n        description: traces execve events\nspec:\n    scope:\n      - global\n    rules:\n      - event: execve\n</code></pre> <p>If no event is passed with [filters] or [policies], tracee will start with a set of default events.</p> <p>Please head over to the Tracee usage documentation for more information on configuring events.</p>"},{"location":"docs/events/#event-sets","title":"Event Sets","text":"<p>Events can be part of a set. For example, <code>default</code>, <code>network_events</code>, <code>syscalls</code>.  We can ask Tracee to trace a full set, or sets, instead of passing event by event, for example:</p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: sample-policy\n    annotations:\n        description: traces execve events\nspec:\n    scope:\n      - global\n    rules:\n      - event: syscalls\n</code></pre>"},{"location":"docs/events/#video-content","title":"Video Content","text":"<p>If you are curious to learn more about the Tracee Events architecture and related decision making, then have a look at the following video Q&amp;A:</p> <p>Everything is an Event in Tracee    </p>"},{"location":"docs/events/builtin/extra/bpf_attach/","title":"bpf_attach","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#intro","title":"Intro","text":"<p>bpf_attach - a BPF program is attached to a probe (kprobe/uprobe/tracepoint/raw_tracepoint)</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#description","title":"Description","text":"<p>An event marking that a BPF program was attached to a probe in the system. It occurs whenever a BPF program is attached to an instrumentation probe - either a  raw_tracepoint or perf event of the types kprobe, uprobe or tracepoint. The purpose of the event is to give the user information about the BPF program,  as well as information about the probe itself.</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#arguments","title":"Arguments","text":"<ul> <li><code>prog_type</code>:<code>int</code>[K] - the BPF program type.</li> <li><code>prog_name</code>:<code>const char*</code>[K] - the BPF program name (first 16 bytes only, as this is how it is saved in the kernel).</li> <li><code>prog_id</code>:<code>u32</code>[K] - the BPF program ID as set by the kernel.</li> <li><code>prog_helpers</code>:<code>unsigned long[]</code>[K] - list of all BPF helpers being used by the BPF program.</li> <li><code>symbol_name</code>:<code>const char*</code>[K] - name/path of the symbol the BPF program is being attached to.</li> <li><code>symbol_addr</code>:<code>u64</code>[K] - address/offset of the symbol the BPF program is being attached to.</li> <li><code>attach_type</code>:<code>int</code>[K] - the probe's type.</li> </ul>"},{"location":"docs/events/builtin/extra/bpf_attach/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#security_file_ioctl","title":"security_file_ioctl","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#security_bpf","title":"security_bpf","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_1","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#security_bpf_prog","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_2","title":"Purpose","text":"<p>save data of the BPF program for when we output the event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#tracepoint_probe_register_prio_may_exist","title":"tracepoint_probe_register_prio_may_exist","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_3","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_3","title":"Purpose","text":"<p>Catch the attachment of the BPF program to a raw_tracepoint</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#check_helper_call","title":"check_helper_call","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_4","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_4","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#check_map_func_compatibility","title":"check_map_func_compatibility","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_5","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_5","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e bpf_attach\n</code></pre>"},{"location":"docs/events/builtin/extra/bpf_attach/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/cgroup_mkdir/","title":"cgroup_mkdir","text":""},{"location":"docs/events/builtin/extra/cgroup_mkdir/#intro","title":"Intro","text":"<p>cgroup_mkdir - An event that gets triggered every time a new cgroup *directory is created.</p>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#description","title":"Description","text":"<p>The <code>cgroup_mkdir</code> event is designed to track the creation of new directories within the cgroup filesystem. Given that containers utilize control groups (<code>cgroup</code>) for resource management, the creation of a new directory can often signal the initiation or termination of a container.</p> <p>Thus, by monitoring these directory creation events through <code>cgroup_mkdir</code>, one can gain valuable insights into container operations, resource allocations, and overall container activity within the system.</p> <p>This event serves as a valuable tool for both observing container lifecycle events and understanding the broader container orchestration dynamics.</p>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#arguments","title":"Arguments","text":"<ul> <li>cgroup_id (<code>u64</code>): The unique identifier for the cgroup.</li> <li>cgroup_path (<code>const char*</code>): The file system path to the cgroup directory.</li> <li>hierarchy_id (<code>u32</code>): An identifier that indicates the hierarchy level of the cgroup.</li> </ul>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/cgroup_mkdir/#tracepoint__cgroup__cgroup_mkdir","title":"tracepoint__cgroup__cgroup_mkdir","text":""},{"location":"docs/events/builtin/extra/cgroup_mkdir/#type","title":"Type","text":"<p>Raw tracepoint (using <code>raw_tracepoint/cgroup_mkdir</code>).</p>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#purpose","title":"Purpose","text":"<p>To observe and capture details every time a new <code>cgroup</code> directory is created. Information about the cgroup's unique identifier, its file system path, and its hierarchy level is captured.</p>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#example-use-case","title":"Example Use Case","text":"<ol> <li>Monitoring container activities: By observing cgroup directory creations, a system can detect when new containers are spun up, potentially identifying unexpected or malicious activity.</li> <li>Resource accounting: Track the creation of new cgroups to better understand resource utilization on a per-container basis.</li> </ol>"},{"location":"docs/events/builtin/extra/cgroup_mkdir/#related-events","title":"Related Events","text":"<ul> <li>container_create: This derived event provides detailed information about the container that corresponds to the created cgroup directory.</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/","title":"cgroup_rmdir","text":""},{"location":"docs/events/builtin/extra/cgroup_rmdir/#intro","title":"Intro","text":"<p>cgroup_rmdir - An event that is triggered whenever a cgroup directory is removed.</p>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#description","title":"Description","text":"<p>The <code>cgroup_rmdir</code> event is intricately crafted to monitor the removal of directories within the cgroup filesystem. As containers are orchestrated and managed using control groups (<code>cgroup</code>), the removal of a directory often indicates the termination or scaling down of a container instance.</p> <p>By keeping tabs on these directory removal events with <code>cgroup_rmdir</code>, operators can capture crucial insights into container terminations, resource deallocations, and other significant container lifecycle events within the system.</p> <p>This event is pivotal for administrators looking to scrutinize container lifecycle events and for understanding the orchestration dynamics in complex containerized environments.</p>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#arguments","title":"Arguments","text":"<ul> <li>cgroup_id (<code>u64</code>): The unique identifier associated with the cgroup being removed.</li> <li>cgroup_path (<code>const char*</code>): The file system path pointing to the cgroup directory that's being removed.</li> <li>hierarchy_id (<code>u32</code>): Denotes the hierarchy level of the cgroup that's being removed.</li> </ul>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/cgroup_rmdir/#tracepoint__cgroup__cgroup_rmdir","title":"tracepoint__cgroup__cgroup_rmdir","text":""},{"location":"docs/events/builtin/extra/cgroup_rmdir/#type","title":"Type","text":"<p>Raw tracepoint (utilizing <code>raw_tracepoint/cgroup_rmdir</code>).</p>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#purpose","title":"Purpose","text":"<p>To keenly observe and capture details each time a <code>cgroup</code> directory is removed. Information related to the cgroup's unique identifier, its file system path, and its hierarchy level is collected.</p>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#example-use-case","title":"Example Use Case","text":"<ol> <li>Container Termination Monitoring**: By tracing cgroup directory removals, the system can identify when containers are terminated, offering a perspective into system scaling dynamics and potential anomalies.</li> <li>Resource Cleanup: Keeping track of the removal of cgroups helps in understanding resource deallocations and ensuring efficient resource usage across the infrastructure.</li> </ol>"},{"location":"docs/events/builtin/extra/cgroup_rmdir/#related-events","title":"Related Events","text":"<ul> <li>container_remove: A derived event that focuses on providing detailed insights about the container corresponding to the removed cgroup directory.</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/container_create/","title":"container_create","text":""},{"location":"docs/events/builtin/extra/container_create/#intro","title":"Intro","text":"<p>container_create - A derived event that signifies the creation of a new *container.</p>"},{"location":"docs/events/builtin/extra/container_create/#description","title":"Description","text":"<p>The <code>container_create</code> event is intricately linked to container orchestration and offers a precise method to monitor the initiation of containers.</p> <p>Every container initiation spawns a new directory within the <code>cgroupfs</code>. By leveraging the <code>cgroup_mkdir</code> event and examining the metadata within the <code>cgroupfs</code> subdirectories, the <code>container_create</code> event is able to discern if the new directory corresponds to a freshly instantiated container.</p> <p>As a result, it gathers detailed information about the container, including its runtime, image details, and related pod data. This gives a clear view of how containers are set up and run within the system.</p>"},{"location":"docs/events/builtin/extra/container_create/#arguments","title":"Arguments","text":"<ul> <li>runtime (<code>const char*</code>): The container runtime used (e.g., Docker, containerd, etc.).</li> <li>container_id (<code>const char*</code>): The unique identifier for the container.</li> <li>ctime (<code>unsigned long</code>): Creation timestamp of the container.</li> <li>container_image (<code>const char*</code>): Image used to create the container.</li> <li>container_image_digest (<code>const char*</code>): Digest of the container image.</li> <li>container_name (<code>const char*</code>): Name of the container.</li> <li>pod_name (<code>const char*</code>): Name of the pod that this container belongs to (if applicable).</li> <li>pod_namespace (<code>const char*</code>): Namespace of the pod.</li> <li>pod_uid (<code>const char*</code>): Unique identifier for the pod.</li> <li>pod_sandbox (<code>bool</code>): Indicates if the pod is acting as a sandbox.</li> </ul>"},{"location":"docs/events/builtin/extra/container_create/#derivation-logic","title":"Derivation Logic","text":"<p>The <code>container_create</code> event is derived from the <code>cgroup_mkdir</code> event. First, it checks if the cgroup event belongs to a container root directory being created. It then uses the <code>cgroup_id</code>, from the cgroup directory inode, to retrieve container-specific information (enriched by tracee when talking to runtime daemons).</p>"},{"location":"docs/events/builtin/extra/container_create/#example-use-case","title":"Example Use Case","text":"<ol> <li>Security Monitoring: Detecting the creation of unexpected or malicious containers.</li> <li>Compliance Audits: Ensuring that only approved container images are used in production environments.</li> <li>Performance Monitoring: Identifying newly created containers that may consume significant resources.</li> </ol>"},{"location":"docs/events/builtin/extra/container_create/#related-events","title":"Related Events","text":"<ul> <li>cgroup_mkdir: The primary event from which <code>container_create</code> is derived. It provides details about the creation of cgroup directories.</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/container_remove/","title":"container_remove","text":""},{"location":"docs/events/builtin/extra/container_remove/#intro","title":"Intro","text":"<p>container_remove - A derived event that signifies the termination of an existing container.</p>"},{"location":"docs/events/builtin/extra/container_remove/#description","title":"Description","text":"<p>The <code>container_remove</code> event indicates when a container is terminated, making it easier to track container activities.</p> <p>Each container's life cycle is tied to its respective directory within the <code>cgroupfs</code>. By harnessing the data from the <code>cgroup_rmdir</code> event and delving into the associated metadata within the <code>cgroupfs</code> subdirectories, the <code>container_remove</code> event determines if a directory's removal correlates with a container's termination.</p> <p>Consequently, it captures vital information about the terminated container, such as its runtime and unique identifier. This aids administrators and operators in comprehending container lifecycle dynamics and ensuring system reliability.</p>"},{"location":"docs/events/builtin/extra/container_remove/#arguments","title":"Arguments","text":"<ul> <li>runtime (<code>const char*</code>): The runtime employed by the container, such as Docker, containerd, etc.</li> <li>container_id (<code>const char*</code>): The distinct identifier allocated to the container.</li> </ul>"},{"location":"docs/events/builtin/extra/container_remove/#derivation-logic","title":"Derivation Logic","text":"<p>The genesis of the <code>container_remove</code> event is from the <code>cgroup_rmdir</code> event. Initially, it assesses whether the cgroup event pertains to the root directory of a terminating container. Subsequently, utilizing the <code>cgroup_id</code> - originating from the cgroup directory inode - it garners container-centric information, a capability augmented by tracee interactions with runtime daemons.</p>"},{"location":"docs/events/builtin/extra/container_remove/#example-use-case","title":"Example Use Case","text":"<ol> <li>Security Monitoring: Scrutinizing container terminations to identify potential security breaches or anomalous activities.</li> <li>Resource Management: Monitoring container terminations to manage and reclaim system resources efficiently.</li> <li>System Reliability: Keeping track of container terminations to ensure stable and expected operations within the infrastructure.</li> </ol>"},{"location":"docs/events/builtin/extra/container_remove/#related-events","title":"Related Events","text":"<ul> <li>cgroup_rmdir: The foundational event from which <code>container_remove</code> is derived. It offers insights into the removal of cgroup directories.</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/do_sigaction/","title":"do_sigaction","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#intro","title":"Intro","text":"<p>do_sigaction - register new signal handler or get information about current one</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#description","title":"Description","text":"<p>The event marks that an attempt to get current task signal handler or to change the signal handler of the current task for a specific signal occurred. Signal handler change mark the change of the program behavior, and might indicate an attempt to defy expected signal behavior. This event is relevant for each syscall related to signal handling - <code>rt_sigaction</code>, <code>sigaction</code> and <code>signal</code>.</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>sig</code>:<code>int</code>[K] - the signal that its handler is inspected or changed.</li> <li><code>is_sa_initialized</code>:<code>bool</code>[K] - is a new signal handler given. If not, this event marks only inspection of data. If given, this will be the new handler for the event.</li> <li><code>sa_flags</code>:<code>unsigned long</code>[K,OPT] - the flags given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_mask</code>:<code>unsigned long</code> [K,OPT] - the mask given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handle_method</code>:<code>u8</code>[K,OPT] - the handling method of the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handler</code>:<code>void*</code>[K,OPT] - the address of the new signal handling function if method is SIG_HND. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>is_old_sa_initialized</code>:<code>bool</code>[K] - is an old signal handler given. If given, the old signal handler will be copied back to the caller.</li> <li><code>old_sa_flags</code>:<code>unsigned long</code>[K] - the flags of the old signal handler</li> <li><code>old_sa_mask</code>:<code>unsigned long</code>[K] - the mask of the old signal handler</li> <li><code>old_sa_handle_method</code>:<code>u8</code>[K] - the handling method of the old signal handler</li> <li><code>old_sa_handler</code>:<code>void*</code>[K] - the address of the old signal handling function if method was SIG_HND</li> </ul>"},{"location":"docs/events/builtin/extra/do_sigaction/#handle-method","title":"Handle Method","text":"<p>In the kernel, the handle method and the handler are united to one field. To make it more accessible to the user, Tracee split the two apart. Normally, the value can be one of the following: <code>SIG_DFL</code>(0), <code>SIG_IGN</code>(1) or pointer to user-mode handler function. To deal with the case of a user-mode handler, the value <code>SIG_HND</code>(2) is created to specify that the method is by handler.</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#do_sigaction_1","title":"do_sigaction","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#purpose","title":"Purpose","text":"<p>The function implementing the signal handler inspection/modification for syscalls</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#related-events","title":"Related Events","text":"<p><code>rt_sigaction</code>,<code>sigaction</code>,<code>signal</code></p>"},{"location":"docs/events/builtin/extra/file_modification/","title":"file_modification","text":""},{"location":"docs/events/builtin/extra/file_modification/#intro","title":"Intro","text":"<p>file_modification - a file was changed by a process</p>"},{"location":"docs/events/builtin/extra/file_modification/#description","title":"Description","text":"<p>An event marking that a file was modified. This event is only submitted once between the open and close of the file by a process.</p>"},{"location":"docs/events/builtin/extra/file_modification/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code>:<code>const char*</code>[K] - the path of the file that was changed.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device of which this file belongs to.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode number of this file.</li> <li><code>old_ctime</code>:<code>unsigned long</code>[K] - the ctime of the file before the change.</li> <li><code>new_ctime</code>:<code>unsigned long</code>[K] - the ctime of the file after the change.</li> </ul>"},{"location":"docs/events/builtin/extra/file_modification/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/file_modification/#fd_install","title":"fd_install","text":""},{"location":"docs/events/builtin/extra/file_modification/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose","title":"Purpose","text":"<p>Catch the open of a file and set the event of file_modification to be submitted for it</p>"},{"location":"docs/events/builtin/extra/file_modification/#filp_close","title":"filp_close","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_1","title":"Purpose","text":"<p>Catch the close of a file and remove it from cache of files t submit the event for</p>"},{"location":"docs/events/builtin/extra/file_modification/#file_update_time","title":"file_update_time","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_2","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_2","title":"Purpose","text":"<p>Catch the file ctime change and submit the event if marked to be submitted</p>"},{"location":"docs/events/builtin/extra/file_modification/#file_modified","title":"file_modified","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_3","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_3","title":"Purpose","text":"<p>Catch the file ctime change and submit the event if marked to be submitted</p>"},{"location":"docs/events/builtin/extra/file_modification/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e file_modification\n</code></pre>"},{"location":"docs/events/builtin/extra/file_modification/#note","title":"Note","text":"<p>Only the first event of file modification is submitted between the open and the close of a file by a process.  This is to reduce the amount of file modification events on a file which might be a lot.  That means that the event is not submitted for each write to the file.</p>"},{"location":"docs/events/builtin/extra/file_modification/#issues","title":"Issues","text":"<p>The file_modification event could be submitted more than once between the open and the close of a file by a process. This is due to the use of an LRU map, which acts as a cache of files that the event should be submitted on. Entries of the map are evicted when it is full, thus information about whether an event should be submitted for a  specific file might be lost, and a new event would be submitted even though such an event was submitted before. </p>"},{"location":"docs/events/builtin/extra/file_modification/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/format/","title":"","text":""},{"location":"docs/events/builtin/extra/format/#intro","title":"Intro","text":"<p> - one sentence description of the event"},{"location":"docs/events/builtin/extra/format/#description","title":"Description","text":"<p>Detailed description of the event. Should include:</p> <ul> <li>What is the purpose of the event?</li> <li>Are there any edge-cases, drawbacks or advantages of using it?</li> </ul>"},{"location":"docs/events/builtin/extra/format/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;arg#1&gt;</code>:<code>&lt;type&gt;</code>[] - short description of the argument value. If the type or value might change (like with the <code>parse-arguments</code> flag) it should be elaborated here. <li><code>&lt;arg#2&gt;</code>:<code>&lt;type&gt;</code>[] - ..."},{"location":"docs/events/builtin/extra/format/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/extra/format/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/format/#_2","title":"","text":""},{"location":"docs/events/builtin/extra/format/#type","title":"Type","text":"<p>Type of probes or hooks used to hook this function. If include more than one, should be in the form of  + ."},{"location":"docs/events/builtin/extra/format/#purpose","title":"Purpose","text":"<p>Why was this function hooked?</p>"},{"location":"docs/events/builtin/extra/format/#_3","title":"<p>...</p>","text":""},{"location":"docs/events/builtin/extra/format/#example-use-case","title":"Example Use Case","text":"<p>Example of a case where this event could be used.</p>"},{"location":"docs/events/builtin/extra/format/#issues","title":"Issues","text":"<p>If there is an issue with this event, this is the place to write it.</p>"},{"location":"docs/events/builtin/extra/format/#related-events","title":"Related Events","text":"<p>Events connected by logic or interesting to be used in the context of the event.</p>"},{"location":"docs/events/builtin/extra/ftrace_hook/","title":"ftrace_hook","text":""},{"location":"docs/events/builtin/extra/ftrace_hook/#intro","title":"Intro","text":"<p>ftrace_hook - an ftrace hook was detected.</p>"},{"location":"docs/events/builtin/extra/ftrace_hook/#description","title":"Description","text":"<p>An event marking that an ftrace hook was detected on your system.</p>"},{"location":"docs/events/builtin/extra/ftrace_hook/#arguments","title":"Arguments","text":"<ul> <li><code>symbol</code>:<code>const char*</code>[K] - the symbol that is being hooked. </li> <li><code>trampoline</code>:<code>const char*</code>[K] - the name/address of the ftrace trampoline.</li> <li><code>callback</code>:<code>const char*</code>[K] - the callback name/address that will be called once the symbol is being executed.</li> <li><code>callback_offset</code>:<code>off_t</code>[K] - the callback offset (inside the function).</li> <li><code>callback_owner</code>:<code>const char*</code>[K] - the owner of the callback (kernel module name if applicable etc)</li> <li><code>flags</code>:<code>const char*</code>[K] - the flags for ftrace. R: registers are passed to the callback; I: callback can change the RIP register value; D: direct call to the function; O: callsite-specific ops; M: the function had I or D.</li> <li><code>count</code>:<code>unsigned long</code>[K] - the number of callbacks registered with the symbol.</li> </ul>"},{"location":"docs/events/builtin/extra/ftrace_hook/#hooks","title":"Hooks","text":"<p>Self-triggered hook.</p>"},{"location":"docs/events/builtin/extra/ftrace_hook/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e ftrace_hook\n</code></pre>"},{"location":"docs/events/builtin/extra/ftrace_hook/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/ftrace_hook/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/hidden_kernel_module/","title":"hidden_kernel_module","text":""},{"location":"docs/events/builtin/extra/hidden_kernel_module/#intro","title":"Intro","text":"<p>hidden_kernel_module - a linux kernel module that is hidden was detected.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#description","title":"Description","text":"<p>An event marking that a loaded hidden kernel module was detected on your system. This event helps in providing a strong indication that your system is compromised. It periodically checks for a hidden module.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#arguments","title":"Arguments","text":"<ul> <li><code>address</code>:<code>const char*</code>[K] - the memory address of the hidden kernel module. </li> <li><code>name</code>:<code>const char*</code>[K] - the name of the hidden kernel module.</li> </ul>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#hooks","title":"Hooks","text":"<p>Self-triggered hook by uprobing itself.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e hidden_kernel_module\n</code></pre>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/hidden_kernel_module/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/hooked_syscall/","title":"hooked_syscall","text":""},{"location":"docs/events/builtin/extra/hooked_syscall/#intro","title":"Intro","text":"<p><code>hooked_syscall</code> is an event that checks syscall table for any syscall hooking.</p>"},{"location":"docs/events/builtin/extra/hooked_syscall/#description","title":"Description","text":"<p>The purpose of the <code>hooked_syscall</code> event is to monitor for system call hooking in the Linux kernel. It verifies each sys call points to its corresponding sys call function symbol. This helps identify instances of kernel code modifications, often used for malicious activities such as hiding processes, files, or network connections.</p>"},{"location":"docs/events/builtin/extra/hooked_syscall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/hooked_syscall/#various-system-calls","title":"Various system calls","text":""},{"location":"docs/events/builtin/extra/hooked_syscall/#type","title":"Type","text":"<p>Uprobe</p>"},{"location":"docs/events/builtin/extra/hooked_syscall/#purpose","title":"Purpose","text":"<p>Detection of syscall hooking.</p>"},{"location":"docs/events/builtin/extra/hooked_syscall/#example-use-case","title":"Example Use Case","text":"<p>The <code>hooked_syscall</code> event could be used as part of a broader system integrity monitoring solution. For example, a security engineer could use it to raise alerts or run further investigations if unexpected syscall hooking activities are detected. This could aid in the early detection and mitigation of malware or rootkit infections.</p> <pre><code>tracee -e hooked_syscall\n</code></pre>"},{"location":"docs/events/builtin/extra/hooked_syscall/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/hooked_syscall/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/","title":"kallsyms_lookup_name","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#intro","title":"Intro","text":"<p>kallsyms_lookup_name - lookup the address for a symbol</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#description","title":"Description","text":"<p>This event is invoked when the 'kallsyms_lookup_name()' kernel function returns.  It suggests a lookup of kernel symbol address. This function is used mainly by external kernel extensions like kernel modules or BPF programs. It might be interesting in cases where a sensitive kernel symbol is looked-up.</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#arguments","title":"Arguments","text":"<ul> <li><code>symbol_name</code>:<code>const char*</code>[K] - the symbol that is being looked-up.</li> <li><code>symbol_address</code>:<code>void*</code>[K] - the address of the symbol returned by the function. 0 if not found.</li> </ul>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#kallsyms_lookup_name_1","title":"kallsyms_lookup_name","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#purpose","title":"Purpose","text":"<p>tracing the kallsyms_lookup_name event</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#example-use-case","title":"Example Use Case","text":"<pre><code>./dist/tracee -e kallsyms_lookup_name\n</code></pre>"},{"location":"docs/events/builtin/extra/magic_write/","title":"magic_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#intro","title":"Intro","text":"<p>magic_write - write operation to a file which changed the file's headers</p>"},{"location":"docs/events/builtin/extra/magic_write/#description","title":"Description","text":"<p>An event marking that a new file is written, or an existing file header changed. The event occurs whenever a write operation to a file in offset 0 is done. The purpose of the event is to give the user information about the file's type and other meta-data needed to understand if the file is a threat.</p>"},{"location":"docs/events/builtin/extra/magic_write/#note","title":"Note","text":"<p>The event doesn't occur for FIFO files or other files with no persistent offsets, to reduce spam events.</p>"},{"location":"docs/events/builtin/extra/magic_write/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file written.</li> <li><code>bytes</code>:<code>bytes</code>[U,TOCTOU] - the first 20 bytes of the file.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the FS.</li> </ul>"},{"location":"docs/events/builtin/extra/magic_write/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/magic_write/#vfs_write","title":"vfs_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose","title":"Purpose","text":"<p>Catch write operations to a file using the <code>write</code> syscall</p>"},{"location":"docs/events/builtin/extra/magic_write/#vfs_writev","title":"vfs_writev","text":""},{"location":"docs/events/builtin/extra/magic_write/#type_1","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose_1","title":"Purpose","text":"<p>Catch write operations to a file using the <code>writev</code> syscall</p>"},{"location":"docs/events/builtin/extra/magic_write/#__kernel_write","title":"__kernel_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#type_2","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose_2","title":"Purpose","text":"<p>Catch write operations to a file from within the kernel (written buffer resides in kernel space)</p>"},{"location":"docs/events/builtin/extra/magic_write/#example-use-case","title":"Example Use Case","text":""},{"location":"docs/events/builtin/extra/magic_write/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/magic_write/#related-events","title":"Related Events","text":"<p>write, writev, vfs_write, vfs_writev, __kernel_write, security_file_open</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/","title":"mem_prot_alert","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#intro","title":"Intro","text":"<p>mem_prot_alert - access protection change of some memory region is suspicious for malicious activity or leave it exposed to one.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#description","title":"Description","text":"<p>An event marking that a memory region protection access change is suspicious for malicious activity. Memory access protection changes might expose writeable memory to execution, or hide its possible execution. The specific alert is passed through the event arguments.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#arguments","title":"Arguments","text":"<ul> <li><code>alert</code>:<code>u32</code>[K] - the specific alert rose. Will be changed to a meaningful string with the <code>parse-args</code> flag on.</li> <li><code>addr</code>:<code>void*</code>[K] - the start address of the memory region the alert is on.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory region the alert is on.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region.</li> <li><code>prev_prot</code>:<code>int</code> [K] - the previous access protection of the memory region.</li> <li><code>pathname</code>:<code>const char*</code>[K,OPT] - the path of the file related to the memory region, if there is a related file.</li> <li><code>dev</code>:<code>dev_t</code>[K,OPT] - the device of the file related to the memory region, if there is a related file.</li> <li><code>inode</code>:<code>unsigned long</code>[K,OPT] - the inode of the file related to the memory region, if there is a related file.</li> <li><code>ctime</code>:<code>u64</code>[K,OPT] - the last change time of the file related to the memory region, if there is a related file.</li> </ul>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#alert-argument-values","title":"Alert argument values","text":"<p>The value given can be translated to a meaningful string using the parsing function in the <code>trace</code> package. Here are the current possible values: * \"Mmaped region with W+E permissions!\" - a mmap operation creating a memory that is exposed to dynamic code execution. * \"Protection changed to Executable!\" - the access protection of the memory region expose it to execution, after some different access protection in the past. * \"Protection changed from E to W+E!\" - the access protection of the memory region now enable dynamic modification and execution, enabling dynamic code execution. * \"Protection changed from W to E!\" - the access protection of the memory region reduced from dynamic code execution, but still exposed to execution of pre-written code. Might be some evasion attempt.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#security_mmap_addr","title":"security_mmap_addr","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose","title":"Purpose","text":"<p>Catch the mmap of a memory, getting access to its access protection.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#security_file_mprotect","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type_1","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose_1","title":"Purpose","text":"<p>Catch the change of access protection of a memory.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#sys_enter","title":"sys_enter","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type_2","title":"Type","text":"<p>raw tracepoint</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose_2","title":"Purpose","text":"<p>Extraction information from syscall arguments for deeper hooks oeration.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#related-events","title":"Related Events","text":"<p><code>security_mmap_addr</code>,<code>security_file_mprotect</code>,<code>security_mmap_file</code>,<code>mmap</code>,<code>mprotect</code></p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/","title":"NetTCPConnect","text":""},{"location":"docs/events/builtin/extra/net_tcp_connect/#intro","title":"Intro","text":"<p>NetTCPConnect - An event that monitors the <code>connect()</code> system call, providing detailed information about destination addresses including DNS resolutions.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#description","title":"Description","text":"<p><code>NetTCPConnect</code> is a high-level event derived from the underlying <code>security_socket_connect</code> LSM (Linux Security Module) hook. This event is triggered whenever the <code>connect()</code> system call is invoked in the system, capturing attempts by sockets to establish a connection.</p> <p>Unlike direct kernel probes, this LSM-based approach is not susceptible to Time-Of-Check to Time-Of-Use (TOCTOU) race conditions, making it a reliable source for monitoring socket connections.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#arguments","title":"Arguments","text":"<ol> <li>dstIP (<code>string</code>): The destination IP address to which the socket is attempting to connect.  2. dstPort (<code>int</code>): The port number at the destination.</li> <li>results (<code>[]string</code>): DNS resolutions made to the destination IP, providing contextual information about the connection attempt.</li> </ol>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#origin","title":"Origin","text":""},{"location":"docs/events/builtin/extra/net_tcp_connect/#derived-from-security_socket_connect","title":"Derived from <code>security_socket_connect</code>","text":""},{"location":"docs/events/builtin/extra/net_tcp_connect/#source","title":"Source","text":"<p>This event is derived from the <code>security_socket_connect</code> LSM hook. The LSM framework provides a way to track and control various aspects of system behavior, and <code>security_socket_connect</code> specifically monitors socket connection attempts.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#purpose","title":"Purpose","text":"<p>The purpose of deriving <code>NetTCPConnect</code> from <code>security_socket_connect</code> is to provide a more user-friendly and context-enriched view of socket connection attempts. This includes not only the basic connection details but also DNS resolution information, offering a comprehensive overview of network activities for security monitoring.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#example-use-case","title":"Example Use Case","text":"<p><code>NetTCPConnect</code> can be used by security applications to monitor and log all outbound connection attempts in a system. It is particularly useful for detecting unusual network patterns or connections to suspicious endpoints, playing a crucial role in intrusion detection and network behavior analysis.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#issues","title":"Issues","text":"<p>While <code>NetTCPConnect</code> offers detailed information about connection attempts, it's important to consider the volume of data generated, especially in systems with high network activity. Efficient data handling and analysis are key to leveraging the full potential of this event without overwhelming system resources or analysts.</p>"},{"location":"docs/events/builtin/extra/net_tcp_connect/#related-events","title":"Related Events","text":"<ul> <li><code>net_flow_tcp_begin</code> - similar event, based on network packet flows.</li> <li><code>security_socket_connect</code></li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/","title":"process_execute_failed","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#intro","title":"Intro","text":"<p>process_execute_failed - a failed process execution occurred.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#description","title":"Description","text":"<p>An event marking that a process execution failure has occurred. This event helps in  monitoring failed executions, with the ability to access (mostly - see below) kernel provided arguments. This is a high-level event, planned to include all the failure cases of process execution,  while providing as much as possible the arguments as used by the kernel.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - the path to the file as provided by the user. </li> <li><code>binary.path</code>:<code>const char*</code>[K] - the binary path being executed.</li> <li><code>binary.device_id</code>:<code>dev_t</code>[K] - the device id of the binary being executed.</li> <li><code>binary.inode_number</code>:<code>unsigned long</code>[K] - the inode number of the binary being executed.</li> <li><code>binary.ctime</code>:<code>unsigned long</code>[K] - the change time (ctime) of the binary being executed.</li> <li><code>binary.inode_mode</code>:<code>u64</code>[K] - the inode mode of the binary being executed.</li> <li><code>interpreter_path</code>:<code>const char*</code>[K] - the path to the interpreter used.</li> <li><code>stdin_type</code>:<code>umode_t</code>[K] - the stdin type.</li> <li><code>stdin_path</code>:<code>char*</code>[K] - the stdin path.</li> <li><code>kernel_invoked</code>:<code>int</code>[K] - whether this execution was initiated by the kernel (or user-space).</li> <li><code>environment</code>:<code>const char*const*</code>[U,TOCTOU] - the environment variables of this execution.</li> <li><code>arguments</code>:<code>const char*const*</code>[U,TOCTOU] - the arguments of this execution.</li> </ul>"},{"location":"docs/events/builtin/extra/process_execute_failed/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#exec_binprm","title":"exec_binprm","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose","title":"Purpose","text":"<p>To retrieve the arguments of exec_binprm. Used for kernels older than 5.8.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#exec_binprm_1","title":"exec_binprm","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type_1","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose_1","title":"Purpose","text":"<p>To retrieve the return value of exec_binprm and generate the event. Used for kernels older than 5.8.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#security_bprm_creds_for_exec","title":"security_bprm_creds_for_exec","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose_2","title":"Purpose","text":"<p>To retrieve the arguments for the event. Relevant from kernel version 5.8 onwards, as the function was added in that kernel.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#sys_enter","title":"sys_enter","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type_3","title":"Type","text":"<p>tracepoint</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose_3","title":"Purpose","text":"<p>To obtain the return code of the execution, determining whether to generate the event. For a failed execution, an event will be generated using the information from the <code>security_bprm_creds_for_exec</code> hook. Relevant from kernel version 5.8 onwards, matching the <code>security_bprm_creds_for_exec</code> hook.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e process_execution_failed\n</code></pre>"},{"location":"docs/events/builtin/extra/process_execute_failed/#issues","title":"Issues","text":"<p>The <code>exec_binprm</code> symbol is not available in some systems, potentially resulting in the failure to load the event in kernels older than 5.8. For kernels older than 5.8, the event only encompasses failed executions occurring within <code>exec_binprm</code>. Other failures may occur at an earlier stage. Newer versions do not account for failures before <code>security_bprm_creds_for_exec</code>, which precedes <code>exec_binprm</code>.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#related-events","title":"Related Events","text":"<p>execve,execveat,bprm_check,sched_process_exec</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/","title":"sched_process_exec","text":""},{"location":"docs/events/builtin/extra/sched_process_exec/#intro","title":"Intro","text":"<p>sched_process_exec - An event that captures details when a new process is executed.</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#description","title":"Description","text":"<p>This event is triggered every time a new process is executed.</p> <p>The eBPF program attached to this event extracts various attributes related to the executed process, such as multiple attributes related to the binary being executed, its interpreter, and the standard input.</p> <p>The main purpose of this event is to provide granular information about each executed process, which can be used for various use-cases like monitoring, security, and auditing.</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#arguments","title":"Arguments","text":"<ol> <li>cmdpath (<code>const char*</code>): The path of the command being executed.</li> <li>pathname (<code>const char*</code>): Path to the executable binary.</li> <li>dev (<code>dev_t</code>): Device number associated with the executable.</li> <li>inode (<code>unsigned long</code>): Inode number of the executable.</li> <li>ctime (<code>unsigned long</code>): Creation time of the executable.</li> <li>inode_mode (<code>umode_t</code>): Mode of the inode for the executable.</li> <li>interpreter_pathname (<code>const char*</code>): Path of the interpreter for the executable.</li> <li>interpreter_dev (<code>dev_t</code>): Device number associated with the interpreter.</li> <li>interpreter_inode (<code>unsigned long</code>): Inode number of the interpreter.</li> <li>interpreter_ctime (<code>unsigned long</code>): Creation time of the interpreter.</li> <li>argv (<code>const char**</code>): Array of arguments passed to the binary during execution.</li> <li>interp (<code>const char*</code>): Specifies the interpreter of the binary.</li> <li>stdin_type (<code>umode_t</code>): Mode of the standard input.</li> <li>stdin_path (<code>char*</code>): Path of the standard input.</li> <li>invoked_from_kernel (<code>int</code>): Flag to determine if the process was initiated by the kernel.</li> <li>env (<code>const char**</code>): Environment variables associated with the process.</li> </ol>"},{"location":"docs/events/builtin/extra/sched_process_exec/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/sched_process_exec/#sched_process_exec_signal","title":"sched_process_exec_signal","text":""},{"location":"docs/events/builtin/extra/sched_process_exec/#type","title":"Type","text":"<p>Raw tracepoint (using <code>raw_tracepoint/sched_process_exec</code>).</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#purpose","title":"Purpose","text":"<p>To capture and extract detailed information every time a new process is executed in the system. This hook provides a rich set of attributes that can be used to understand the context and nature of the executed process.</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#example-use-case","title":"Example Use Case","text":"<p>Monitoring executed processes in real-time for security or auditing purposes, ensuring that no unexpected or malicious processes are being run on the system.</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#issues","title":"Issues","text":"<p>This program captures a vast amount of data for each executed process, which can introduce overhead, especially on systems with a high frequency of process creation. It's crucial to weigh the benefits of the data collected against the potential performance impact.</p>"},{"location":"docs/events/builtin/extra/sched_process_exec/#related-events","title":"Related Events","text":"<ul> <li>sched_process_fork</li> <li>sched_process_exit</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#intro","title":"Intro","text":"<p>security_bpf_prog - Do a check when the kernel generate and return a file descriptor for BPF programs.</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#description","title":"Description","text":"<p>This event marks the act of getting a file descriptor of a BPF program. It is triggered when the BPF program is being  loaded, or when the user asks for it explicitly. This event is of type LSM hook. The event contains data about the BPF program, and whether it is currently being loaded or not. </p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>int</code>[K] - the BPF program type.</li> <li><code>name</code>:<code>const char*</code>[K] - the BPF program name (first 16 bytes only, as this is how it is saved in the kernel).</li> <li><code>helpers</code>:<code>unsigned long[]</code>[K] - list of all BPF helpers being used by the BPF program.</li> <li><code>id</code>:<code>u32</code>[K] - the BPF program ID as set by the kernel.</li> <li><code>load</code>:<code>bool</code>[K] - whether this BPF program is currently being loaded.</li> </ul>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#security_bpf_prog_1","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose","title":"Purpose","text":"<p>The LSM hook of getting a file descriptor of a BPF program. This hook triggers the event. </p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#bpf_check","title":"bpf_check","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_1","title":"Purpose","text":"<p>Save data of whether this BPF program is currently being loaded.</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#check_helper_call","title":"check_helper_call","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_2","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#check_map_func_compatibility","title":"check_map_func_compatibility","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_3","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_3","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e security_bpf_prog\n</code></pre>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/security_bprm_check/","title":"security_bprm_check","text":""},{"location":"docs/events/builtin/extra/security_bprm_check/#intro","title":"Intro","text":"<p>security_bprm_check - verify permissions prior to initiating the binary handler search in the execution flow.</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#description","title":"Description","text":"<p>This event signifies an attempt to execute a binary via execve or execveat, occurring just before the kernel starts searching for the specific binary handler. During this stage, numerous new process attributes are set, and although the context remains that of the pre-execution process, the event is valuable when that context holds significance. It's a preferred choice over syscall events due to its resolved path and binary details. However, if you need more extensive information and the process context is less crucial, you might find the sched_process_exec event to be a better fit.</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the resolved path of the file executed.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device of the executed file.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode number of the executed file.</li> <li><code>argv</code>:<code>const char*</code>[U,TOCTOU] - the arguments given by the user during execution.</li> <li><code>envp</code>:<code>const char*</code>[U,TOCTOU,OPT] - the environment variable passed by the user during execution. Will be filled only if requested by the configuration.</li> </ul>"},{"location":"docs/events/builtin/extra/security_bprm_check/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_bprm_check/#security_bprm_check_1","title":"security_bprm_check","text":""},{"location":"docs/events/builtin/extra/security_bprm_check/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#purpose","title":"Purpose","text":"<p>The LSM hook for the execution phase before context changing.</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#sys_enter","title":"sys_enter","text":""},{"location":"docs/events/builtin/extra/security_bprm_check/#type_1","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#purpose_1","title":"Purpose","text":"<p>Used to save the argv of the execution from the syscall arguments.</p>"},{"location":"docs/events/builtin/extra/security_bprm_check/#related-events","title":"Related Events","text":"<p><code>sched_process_exec</code>,<code>execve</code>,<code>execveat</code></p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#intro","title":"Intro","text":"<p>security_file_mprotect - check permissions before changing the memory access protection of some memory region</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#description","title":"Description","text":"<p>The event marks an attempt to change the access protection of some memory region, probably by the <code>mprotect</code> or <code>pkey_mprotect</code> syscalls. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight on the new access protection, as well as information on the memory addresses the attempt operation is on. This is a useful event to tracee memory protection changes originated by a user. Notice that the change of protection is applied to the pages containing the address range given, not only for given range.</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file associated with the memory region.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>ctime</code>:<code>unsigned long</code>[K] - the creation time of the file associated with the memory region.</li> <li><code>prev_prot</code>:<code>int</code>[K] - the previous access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>addr</code>:<code>void*</code>[K] - the start of virtual memory address to change its access protection.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory to apply the new protection on.</li> <li><code>pkey</code>:<code>int</code>[K,OPT] - the protection key used for the operation. Available only if invoking syscall is <code>pkey_mprotect</code>.</li> </ul>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#security_file_mprotect_1","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#purpose","title":"Purpose","text":"<p>The LSM hook for the <code>mprotect</code> related syscalls - <code>mprotect</code> and <code>pkey_mprotect</code>.</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#related-events","title":"Related Events","text":"<p><code>mprotect</code>,<code>pkey_mprotect</code></p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/","title":"security_inode_unlink","text":""},{"location":"docs/events/builtin/extra/security_inode_unlink/#intro","title":"Intro","text":"<p>security_inode_unlink - An event that captures details when an inode is unlinked.</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#description","title":"Description","text":"<p>This event is triggered when an inode is unlinked, representing file or directory deletion. The eBPF program attached to this event extracts various attributes related to the unlinked inode, primarily focusing on the path, inode number, device number, and creation time of the file or directory.</p> <p>The main purpose of this event is to monitor and log file or directory deletions, which can be critical for security, monitoring, or auditing use cases, especially when tracking changes in critical directories or files.</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#arguments","title":"Arguments","text":"<ol> <li>pathname (<code>const char*</code>): The path to the file or directory being unlinked.</li> <li>inode (<code>unsigned long</code>): Inode number of the file or directory.</li> <li>dev (<code>dev_t</code>): Device number associated with the inode.</li> <li>ctime (<code>u64</code>): Creation time of the file or directory.</li> </ol>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_inode_unlink/#trace_security_inode_unlink","title":"trace_security_inode_unlink","text":""},{"location":"docs/events/builtin/extra/security_inode_unlink/#type","title":"Type","text":"<p>Kprobe (using <code>kprobe/security_inode_unlink</code>).</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#purpose","title":"Purpose","text":"<p>To capture and extract detailed information whenever an inode gets unlinked. This hook provides a set of attributes that can be used to understand the context and specifics of the unlinked file or directory.</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#example-use-case","title":"Example Use Case","text":"<p>Security applications might use this event to track and monitor deletions of sensitive files or directories. It can also be employed for auditing purposes, ensuring that no unexpected file removal operations are conducted, especially in critical system directories.</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#issues","title":"Issues","text":"<p>This eBPF program captures details on each unlinked inode, which might introduce some overhead, especially in systems where files are frequently created and deleted. It's essential to consider the potential performance implications and adjust the monitoring frequency or scope if needed.</p>"},{"location":"docs/events/builtin/extra/security_inode_unlink/#related-events","title":"Related Events","text":"<ul> <li>security_inode_unlink</li> <li>security_inode_mknod</li> <li>security_inode_symlink</li> <li>security_inode_rename</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/extra/security_path_notify/","title":"security_path_notify","text":""},{"location":"docs/events/builtin/extra/security_path_notify/#intro","title":"Intro","text":"<p>security_path_notify - An event capturing the registration of filesystem notifications.</p>"},{"location":"docs/events/builtin/extra/security_path_notify/#description","title":"Description","text":"<p>This event captures all attempts to register a filesystem notification. Filesystem notifications allow a user to receive information about events occurring in the filesystem, by specifying a filesystem object and a set of events to monitor.</p> <p>This is done using any of 3 filesystem notification APIs: <code>dnotify</code>, <code>inotify</code> and <code>fanotify</code>. <code>fanotify</code> even allows responding to filesystem operations by deciding if they should pass or fail. All 3 APIs use the underlying <code>fsnotify</code> system in the kernel. While registering a filesystem watch (request for notification), these APIs call <code>security_path_notify</code> to determine if any LSM hooks want to block the operation.</p> <p>By hooking <code>security_path_notify</code>, this program can capture any attempt to register a filesystem watch. The event includes details on the filesystem path for which the watch is being registered and the requested filesystem events to monitor.</p>"},{"location":"docs/events/builtin/extra/security_path_notify/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - filesystem path for which the watch is being registered.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - inode of the filesystem object</li> <li><code>dev</code>:<code>dev_t</code>[K] - device of the filesystem object</li> <li><code>mask</code>:<code>u64</code>[K] - mask representing the filesystem events which should be monitored. These flags are parsed if the <code>parse-arguments</code> option is specified.</li> <li><code>obj_type</code>:<code>unsigned int</code>[K] - the type of filesystem object to be watched. This value is parsed if the <code>parse-argumetns</code> option is specified.</li> </ul>"},{"location":"docs/events/builtin/extra/security_path_notify/#_1","title":"security_path_notify","text":""},{"location":"docs/events/builtin/extra/security_path_notify/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_path_notify/#security_path_notify_1","title":"security_path_notify","text":""},{"location":"docs/events/builtin/extra/security_path_notify/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_path_notify/#purpose","title":"Purpose","text":"<p>Catch security checks for registering a filesystem notification.</p>"},{"location":"docs/events/builtin/extra/security_path_notify/#example-use-case","title":"Example Use Case","text":"<p>Can be used to catch attempts to register filesystem notifications for a certain filesystem object using any of <code>dnotify</code>, <code>inotify</code> or <code>fanotify</code> APIs.</p>"},{"location":"docs/events/builtin/extra/security_path_notify/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/security_path_notify/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/security_sb_mount/","title":"security_sb_mount","text":""},{"location":"docs/events/builtin/extra/security_sb_mount/#intro","title":"Intro","text":"<p>security_sb_mount - An event capturing the details when a file system is mounted.</p>"},{"location":"docs/events/builtin/extra/security_sb_mount/#description","title":"Description","text":"<p>The event gets triggered whenever a file system is mounted in the system, which could be a significant action from both a system administration and security perspective.</p> <p>By hooking into the kernel's <code>security_sb_mount</code> function, this eBPF program captures details such as the device name, the path where the filesystem will be mounted, the type of the file system, and the flags provided for the mount operation.</p> <p>Monitoring such mount events can provide a deep understanding of system operations and potential anomalies. For example, if an unexpected device or file system gets mounted, it could be indicative of a security breach or system misconfiguration.</p>"},{"location":"docs/events/builtin/extra/security_sb_mount/#arguments","title":"Arguments","text":"<ol> <li>dev_name (<code>const char*</code>): The name of the device being mounted.</li> <li>path (<code>const char*</code>): The destination path in the file system where the device will be mounted.</li> <li>type (<code>const char*</code>): The type of the file system being mounted (e.g., <code>ext4</code>, <code>nfs</code>, etc.).</li> <li>flags (<code>unsigned long</code>): The flags that specify the mount options. </li> </ol>"},{"location":"docs/events/builtin/extra/security_sb_mount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_sb_mount/#trace_security_sb_mount","title":"trace_security_sb_mount","text":""},{"location":"docs/events/builtin/extra/security_sb_mount/#type","title":"Type","text":"<p>Kprobe (using <code>kprobe/security_sb_mount</code>).</p>"},{"location":"docs/events/builtin/extra/security_sb_mount/#purpose","title":"Purpose","text":"<p>To observe and gather data whenever a file system is mounted. The captured details include the device name, mounting path, file system type, and flags. All this information is saved into a buffer and is then submitted to user-space for further analysis or logging.</p>"},{"location":"docs/events/builtin/extra/security_sb_mount/#example-use-case","title":"Example Use Case","text":"<p>By tracking the <code>security_sb_mount</code> event, system administrators can gain insights about what devices or file systems are being mounted, ensuring that only authorized actions are taken and detecting unexpected mounts, which could be a potential sign of malicious activity or system misconfiguration.</p>"},{"location":"docs/events/builtin/extra/security_sb_mount/#related-events","title":"Related Events","text":"<p>To get a more comprehensive view of system operations related to storage, it's beneficial to monitor this event in conjunction with others, like file system unmounting or device initialization events.</p> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/","title":"security_socket_accept","text":""},{"location":"docs/events/builtin/extra/security_socket_accept/#intro","title":"Intro","text":"<p>security_socket_accept - An event capturing details when a socket accepts an incoming connection.</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/#description","title":"Description","text":"<p>This event is triggered whenever a socket accepts a connection request. The eBPF program hooks into the kernel's <code>security_socket_accept</code> function, extracting details about the socket involved and the accepted connection's local address.</p> <p>Monitoring the acceptance of incoming connections can provide insights into the activity of servers and applications, shedding light on potential threats or irregular behaviors.</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/#arguments","title":"Arguments","text":"<ol> <li>sockfd (<code>int</code>): The file descriptor referring to the socket accepting the connection.</li> <li>local_addr (<code>struct sockaddr*</code>): A pointer to the structure holding the local address details of the accepted connection.</li> </ol>"},{"location":"docs/events/builtin/extra/security_socket_accept/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_socket_accept/#trace_security_socket_accept","title":"trace_security_socket_accept","text":""},{"location":"docs/events/builtin/extra/security_socket_accept/#type","title":"Type","text":"<p>Kprobe (using <code>kprobe/security_socket_accept</code>).</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/#purpose","title":"Purpose","text":"<p>To observe and gather data whenever a socket accepts an incoming connection. The captured data gets saved into a buffer, which is subsequently submitted to user-space for further analysis or logging.</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/#example-use-case","title":"Example Use Case","text":"<p>A server application could utilize this event to maintain a log of all incoming connections, ensuring awareness of all entities connecting to the server. This can be crucial for security, especially in scenarios where unauthorized access might occur. Diagnostics tools might also employ this event to troubleshoot network connectivity issues.</p>"},{"location":"docs/events/builtin/extra/security_socket_accept/#related-events","title":"Related Events","text":"<ul> <li>security_socket_create</li> <li>security_socket_listen</li> <li>security_socket_connect</li> <li>security_socket_bind</li> <li>security_socket_setsockopt</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/","title":"security_socket_bind","text":""},{"location":"docs/events/builtin/extra/security_socket_bind/#intro","title":"Intro","text":"<p>security_socket_bind - An event capturing details when a socket is bound to an address and port.</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/#description","title":"Description","text":"<p>This event gets triggered whenever a socket is bound to a local address and port, a crucial step for setting up servers or defining source addresses for outgoing connections.i</p> <p>The eBPF program hooks into the kernel's <code>security_socket_bind</code> function, capturing details about the socket involved and the address to which it binds.</p> <p>Monitoring socket bindings can provide insights into the activities of servers, services, and applications, revealing which services are being started or if specific services are being bound to unexpected addresses.</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/#arguments","title":"Arguments","text":"<ol> <li>sockfd (<code>int</code>): The file descriptor referring to the socket that is being bound.</li> <li>local_addr (<code>struct sockaddr*</code>): A pointer to the structure holding the local address and port details to which the socket is binding.</li> </ol>"},{"location":"docs/events/builtin/extra/security_socket_bind/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_socket_bind/#trace_security_socket_bind","title":"trace_security_socket_bind","text":""},{"location":"docs/events/builtin/extra/security_socket_bind/#type","title":"Type","text":"<p>Kprobe (using <code>kprobe/security_socket_bind</code>).</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/#purpose","title":"Purpose","text":"<p>To observe and gather data whenever a socket is bound to a local address and port. The captured data, including the socket's descriptor and its binding address, gets saved into a buffer and is subsequently submitted to user-space for further processing, analysis, or logging.</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the <code>security_socket_bind</code> event can be of high value for server or network administrators. By observing this event, they can get insights about the services being initiated, ensuring that only authorized services are started and unexpected bindings are detected, which can be a sign of misconfiguration or a potential threat.</p>"},{"location":"docs/events/builtin/extra/security_socket_bind/#related-events","title":"Related Events","text":"<ul> <li>security_socket_accept</li> <li>security_socket_create</li> <li>security_socket_listen</li> <li>security_socket_connect</li> <li>security_socket_setsockopt</li> </ul> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/","title":"security_socket_connect","text":""},{"location":"docs/events/builtin/extra/security_socket_connect/#intro","title":"Intro","text":"<p>security_socket_connect - An event that captures details when a socket attempts to make a connection.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#description","title":"Description","text":"<p>This event is triggered when a socket tries to establish a connection. The eBPF program is attached to the kernel's <code>security_socket_connect</code> function and captures information about the socket, as well as the remote address it's trying to connect to.</p> <p>Given the importance of network communications for many applications, monitoring socket connections can be crucial for security, diagnostics, and compliance reasons.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#arguments","title":"Arguments","text":"<ol> <li>sockfd (<code>int</code>): The file descriptor referring to the socket attempting the connection.</li> <li>remote_addr (<code>struct sockaddr*</code>): A pointer to the structure that holds the remote address details. Depending on the address family (IPv4, IPv6, or UNIX), it can point to different specific structures (<code>struct sockaddr_in</code>, <code>struct sockaddr_in6</code>, or <code>struct sockaddr_un</code>).</li> </ol>"},{"location":"docs/events/builtin/extra/security_socket_connect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_socket_connect/#trace_security_socket_connect","title":"trace_security_socket_connect","text":""},{"location":"docs/events/builtin/extra/security_socket_connect/#type","title":"Type","text":"<p>Kprobe (using <code>kprobe/security_socket_connect</code>).</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#purpose","title":"Purpose","text":"<p>To monitor and extract data whenever a socket tries to connect. Depending on the address family of the socket, different pieces of data are saved to a buffer, which are then submitted to user-space for further processing or logging.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#example-use-case","title":"Example Use Case","text":"<p>A security application might leverage this event to track all outbound connections from a system. This can be vital for identifying potentially malicious communications or connections to unknown endpoints. Additionally, diagnostics tools can utilize this information to debug network-related issues in applications.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#issues","title":"Issues","text":"<p>Monitoring every socket connection might introduce overhead, especially in systems with frequent network communications. It's essential to balance the need for monitoring with potential performance implications.</p>"},{"location":"docs/events/builtin/extra/security_socket_connect/#related-events","title":"Related Events","text":"<ul> <li>security_socket_create</li> <li>security_socket_listen</li> <li>security_socket_accept</li> <li>security_socket_bind</li> <li>security_socket_setsockopt</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/","title":"security_socket_setsockopt","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#intro","title":"Intro","text":"<p>security_socket_setsockopt - check permissions before setting the options associated with socket</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#description","title":"Description","text":"<p>The event marks that an attempt to set a socket option occurred, probably by the <code>setsockopt</code> syscall. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight to the socket details (which differs from the <code>setsockopt</code> syscall event, that only pass the socket fd). However, unlike the <code>setsockopt</code> syscall event, the option value isn't passed.</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the socket.</li> <li><code>level</code>:<code>int</code>[K] - the level that the option should apply to. If the <code>parse-arguments</code> option is on, will be transformed to a string with the level name.</li> <li><code>optname</code>:<code>int</code>[K] - the option that is set. If the <code>parse-arguments</code> option is on, will be transformed to a string with the option name.</li> <li><code>local_addr</code>:<code>struct socketaddr*</code>[K] - the details of the socket (like socket type, local IP and port for TCP/UDP sockets, etc.).</li> </ul>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#security_socket_setsockopt_1","title":"security_socket_setsockopt","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#type","title":"Type","text":"<p>LSM Hook</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#purpose","title":"Purpose","text":"<p>The LSM hook of the <code>setsockopt</code> syscall implementation.</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#related-events","title":"Related Events","text":"<p><code>setsockopt</code>, <code>getsockopt</code></p>"},{"location":"docs/events/builtin/extra/set_fs_pwd/","title":"set_fs_pwd","text":""},{"location":"docs/events/builtin/extra/set_fs_pwd/#intro","title":"Intro","text":"<p>set_fs_pwd - An event capturing changes to the current working directory.</p>"},{"location":"docs/events/builtin/extra/set_fs_pwd/#description","title":"Description","text":"<p>This event captures any changes to the current working directory (typically by using the <code>chdir</code> and <code>fchdir</code> syscalls).</p>"},{"location":"docs/events/builtin/extra/set_fs_pwd/#arguments","title":"Arguments","text":"<ul> <li><code>unresolved_pathname</code>:<code>const char*</code>[K,TOCTOU,OPT] - unresolved, user-supplied path which the current working directory is being changed to (only relevant to directory changes using the <code>chdir</code> syscall).</li> <li><code>resolved_pathname</code>:<code>const char*</code>[K] - the fully resolved filesystem path which the current working directory is being changed to.</li> </ul>"},{"location":"docs/events/builtin/extra/set_fs_pwd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/set_fs_pwd/#set_fs_pwd_1","title":"set_fs_pwd","text":""},{"location":"docs/events/builtin/extra/set_fs_pwd/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/set_fs_pwd/#purpose","title":"Purpose","text":"<p>Catch changes to the current working directory.</p>"},{"location":"docs/events/builtin/extra/set_fs_pwd/#example-use-case","title":"Example Use Case","text":""},{"location":"docs/events/builtin/extra/set_fs_pwd/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/set_fs_pwd/#related-events","title":"Related Events","text":"<p><code>chdir</code>, <code>fchdir</code></p>"},{"location":"docs/events/builtin/extra/symbols_collision/","title":"symbols_collision","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#intro","title":"Intro","text":"<p>symbols_collision - a shared object loaded to a process has collisions in exported symbols with another loaded shared object.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#description","title":"Description","text":"<p>An event marking that a shared object loaded to current process, and have collisions of exported symbols with other shared object already loaded to the process. This event can help in inform on the  occasion that a shared object tries to override some symbol of another library.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#configuring-the-event","title":"Configuring the event","text":"<p>The event is configured using arguments filtering.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#symbols","title":"symbols","text":"<p>Configure the watched symbols that upon collision will trigger the event. Specify the full name of the symbol for each symbol. Notice that only watched symbols will be outputed by the event, and the default is watching all symbols. The use is only with the <code>=</code> or <code>!=</code> operators, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#arguments","title":"Arguments","text":"<ul> <li><code>loaded_path</code>:<code>const char*</code>[K] - the path of the file loaded.</li> <li><code>collision_path</code>:<code>const char*</code>[K,TOCTOU] - the path of the file already loaded, which has collision with the new loaded one.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - list of symbols collided between the files.</li> </ul>"},{"location":"docs/events/builtin/extra/symbols_collision/#dependency-events","title":"Dependency Events","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#shared_object_loaded","title":"shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its exported symbols.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#sched_process_exec","title":"sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system. Also, used to maintain the cache used by the event for performance improvement.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#example-use-case","title":"Example Use Case","text":"<p>Could be used for example to catch collision between a shared object and <code>libc.so</code>, overwriting libc symbols:</p> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6\n</code></pre> <p>Running this line will give a lot of spam symbols collision, for example collisions of <code>libc</code> with <code>libm</code>:</p> <pre><code>TIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n14:41:48:296325  1000   xfce4-panel      6808    6808    0                symbols_collision    loaded_path: /usr/lib/libc.so.6, collision_path: /usr/lib/libm.so.6, symbols: [finitel __signbitf finite frexpl frexp scalbn __finite copysignl scalbnf __signbitl scalbnl copysign copysignf ldexpf modff modf ldexp ldexpl finitef frexpf __finitel modfl __finitef __signbit]\n</code></pre> <p>To reduce the spam collisions, we can configure the event to not print the collision using two ways: 1. Whitelist the collided symbols:</p> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6 -e symbols_collision.args.symbols!=finitel,__signbitf,finite,frexpl,frexp,scalbn,__finite,copysignl,scalbnf,__signbitl,scalbnl,copysign,copysignf,ldexpf,modff,modf,ldexp,ldexpl,finitef,frexpf,__finitel,modfl,__finitef,__signbit\n</code></pre> <ol> <li>Whitelist the library <code>libm</code>:</li> </ol> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6 -e symbols_collision.args.collision_path!=/usr/lib/libm.so.6\n</code></pre> <p>The first approach is recommended when dealing with common symbols like 'setup_', 'finish_' etc. because it will reduce the overall noise and also reduce the event processing time, in contrast to the second filter which only works after processing the event.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#user-mode-event","title":"User Mode Event","text":"<p>Because the event is implemented in user-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#spam","title":"Spam","text":"<p>Notice that there are symbols which unintentionally exported by shared objects regularly. Moreover, there are times which the same ELF load multiple variations of the same shared object, or one shared object copies code from another (for example, <code>libm</code> and <code>libc</code>). This cases will cause unintended spam events, so use wisely.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#big-event-size","title":"Big Event Size","text":"<p>The event pass list of all collided symbols as an argument. The list might be very large, which will result large memory event resulting performance reduction and excess memory usage.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#related-events","title":"Related Events","text":"<p>shared_object_loaded, symbols_loaded</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/","title":"symbols_loaded","text":""},{"location":"docs/events/builtin/extra/symbols_loaded/#intro","title":"Intro","text":"<p>symbols_loaded - a shared object which exports a watched symbol was loaded.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#description","title":"Description","text":"<p>An event marking that a shared object, which export symbols configured to be watched, was loaded to current process. This event can help in identifying some shared object usage in the system, or inform on the occasion that a shared object tries to override some symbol of another library.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#configuring-the-event","title":"Configuring the event","text":"<p>The event is configured using arguments filtering. For each argument, a filter can be used to configure the operation:</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#symbols","title":"symbols","text":"<p>Configure the watched symbols by the event. Specify the full name of the symbol for each symbol. The use is only with the <code>=</code> operator, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#library_path","title":"library_path","text":"<p>Whitelist for shared object paths prefixes. The path can be absolute, or just a library name. If only a name is given, then any shared object inside the known libraries directories which starts with the prefix will be whitelisted. The use is only with the <code>!=</code> operator, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#arguments","title":"Arguments","text":"<ul> <li><code>library_path</code>:<code>const char*</code>[K] - the path of the shared object file loaded.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - the watched symbols exported by the shared object.</li> </ul>"},{"location":"docs/events/builtin/extra/symbols_loaded/#dependency-events","title":"Dependency Events","text":""},{"location":"docs/events/builtin/extra/symbols_loaded/#shared_object_loaded","title":"shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its shared objects.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#sched_process_exec","title":"sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#example-use-case","title":"Example Use Case","text":"<p>To catch SO which tries to override the <code>fopen</code> function of <code>libc</code>, we can use the event in the following way:</p> <pre><code>./dist/tracee -e symbols_loaded.args.symbols=fopen -e symbols_loaded.args.library_path!=libc\n</code></pre>"},{"location":"docs/events/builtin/extra/symbols_loaded/#issues","title":"Issues","text":"<p>Because the event is implemented in user-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#related-events","title":"Related Events","text":"<p>shared_object_loaded, symbols_collision</p>"},{"location":"docs/events/builtin/extra/vfs_read/","title":"vfs_read","text":""},{"location":"docs/events/builtin/extra/vfs_read/#intro","title":"Intro","text":"<p>vfs_read - generic FS file read to a buffer</p>"},{"location":"docs/events/builtin/extra/vfs_read/#description","title":"Description","text":"<p>An event indicating that a read from a file to a buffer was done. The event is not FS specific, and the hook is on the inner implementation of the <code>read</code> and other buffer read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_readv</code>, file mapping, etc.</p>"},{"location":"docs/events/builtin/extra/vfs_read/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>count</code>:<code>size_t</code>[K] - the size requested to be read by this operation</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"docs/events/builtin/extra/vfs_read/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/vfs_read/#vfs_read_1","title":"vfs_read","text":""},{"location":"docs/events/builtin/extra/vfs_read/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/vfs_read/#purpose","title":"Purpose","text":"<p>The implementation of the <code>read</code>, <code>readv</code> syscall after fd resolving.</p>"},{"location":"docs/events/builtin/extra/vfs_read/#related-events","title":"Related Events","text":"<p><code>read</code>,<code>vfs_readv</code>,<code>vfs_write</code></p>"},{"location":"docs/events/builtin/extra/vfs_readv/","title":"vfs_readv","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#intro","title":"Intro","text":"<p>vfs_readv - generic FS file read to a vector</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#description","title":"Description","text":"<p>An event indicating that a read from a file to a vector was done. The event is not FS specific, and the hook is on the inner implementation of the <code>readv</code> and other vector read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_read</code>, file mapping, etc.</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>vlen</code>:<code>unsigned long</code>[K] - the amount of buffers requested to be read by this operation to the vector</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"docs/events/builtin/extra/vfs_readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#vfs_readv_1","title":"vfs_readv","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#purpose","title":"Purpose","text":"<p>The implementation of the <code>readv</code>, <code>preadv</code> and <code>preadv2</code> syscall after fd resolving.</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#related-events","title":"Related Events","text":"<p><code>readv</code>,<code>vfs_read</code>,<code>vfs_writev</code></p>"},{"location":"docs/events/builtin/network/","title":"Overview","text":"<p>Tracee offers a set of network events that makes it easy to trace network activity in common protocols.</p>"},{"location":"docs/events/builtin/network/#available-network-events","title":"Available network events","text":"<ul> <li>net_packet_ipv4</li> <li>net_packet_ipv6</li> <li>net_packet_tcp</li> <li>net_packet_udp</li> <li>net_packet_icmp</li> <li>net_packet_icmpv6</li> <li>net_packet_dns</li> <li>net_packet_dns_request</li> <li>net_packet_dns_response</li> <li>net_packet_http</li> <li>net_packet_http_request</li> <li>net_packet_http_response</li> </ul>"},{"location":"docs/events/builtin/network/#network-event-filtering","title":"Network Event Filtering","text":"<p>Supported</p> <p>For now it is NOT possible to filter the events through the header fields, but it IS possible, and recommended, to filter the events through <code>src</code>, <code>dest</code> fields. Not filtering network events might be hard to consume because of the amount of traced events.</p> <p>Trace all TCP packets sent to port 80 anywhere, from any process:</p> <pre><code>tracee --output json --events net_packet_tcp.args.dst_port=80\n</code></pre> <pre><code>{\"timestamp\":1696255674450496178,\"threadStartTime\":1696249856019516599,\"processorId\":6,\"processId\":1014858,\"cgroupId\":5650,\"threadId\":1014989,\"parentProcessId\":1729,\"hostProcessId\":1014858,\"hostThreadId\":1014989,\"hostParentProcessId\":1729,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"vlc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"recvmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3489249124,\"processEntityId\":3999221038,\"parentEntityId\":3069802613,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"70.42.73.30\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":40020},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":40020,\"dstPort\":80,\"seq\":4173220235,\"ack\":2867625954,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":2766,\"checksum\":6218,\"urgent\":0}}]}\n{\"timestamp\":1696255674454872352,\"threadStartTime\":1696249856019516599,\"processorId\":6,\"processId\":1014858,\"cgroupId\":5650,\"threadId\":1014989,\"parentProcessId\":1729,\"hostProcessId\":1014858,\"hostThreadId\":1014989,\"hostParentProcessId\":1729,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"vlc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"recvmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3489249124,\"processEntityId\":3999221038,\"parentEntityId\":3069802613,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"70.42.73.30\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":40020},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":40020,\"dstPort\":80,\"seq\":4173220235,\"ack\":2867626999,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":2766,\"checksum\":6218,\"urgent\":0}}]}\n{\"timestamp\":1696255674459439720,\"threadStartTime\":1696249856019516599,\"processorId\":6,\"processId\":1014858,\"cgroupId\":5650,\"threadId\":1014989,\"parentProcessId\":1729,\"hostProcessId\":1014858,\"hostThreadId\":1014989,\"hostParentProcessId\":1729,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"vlc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"recvmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3489249124,\"processEntityId\":3999221038,\"parentEntityId\":3069802613,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"70.42.73.30\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":40020},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":40020,\"dstPort\":80,\"seq\":4173220235,\"ack\":2867628044,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":2766,\"checksum\":6218,\"urgent\":0}}]}\n{\"timestamp\":1696255674459993274,\"threadStartTime\":1696249856019516599,\"processorId\":6,\"processId\":1014858,\"cgroupId\":5650,\"threadId\":1014989,\"parentProcessId\":1729,\"hostProcessId\":1014858,\"hostThreadId\":1014989,\"hostParentProcessId\":1729,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"vlc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"recvmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3489249124,\"processEntityId\":3999221038,\"parentEntityId\":3069802613,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"70.42.73.30\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":40020},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":40020,\"dstPort\":80,\"seq\":4173220235,\"ack\":2867629089,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":2766,\"checksum\":6218,\"urgent\":0}}]}\n</code></pre> <p>Trace all DNS packets received ONLY from Google DNS server '8.8.8.8':</p> <pre><code>tracee --output json --events net_packet_dns.args.src=8.8.8.8\n</code></pre> <p>(only systemd-resolved, since all the other processes are resolving using local systemd-resolved server <code>127.0.1.1:53</code>):</p> <pre><code>{\"timestamp\":1696255744257383842,\"threadStartTime\":1695658999333342370,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":36031},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":57779,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"www.zip.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.zip.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":300,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"amazonas.uol.com.br\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[{\"name\":\"uol.com.br\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":600,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"a10-dns-uolcsfe1.host.intranet\",\"RName\":\"root.uol.com.br\",\"serial\":2016052887,\"refresh\":7200,\"retry\":3600,\"expire\":432000,\"minimum\":900},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696255744409156387,\"threadStartTime\":1695658999333342370,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":52190},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":57212,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":2,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"www.zip.net\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.zip.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":300,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"amazonas.uol.com.br\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"amazonas.uol.com.br\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"200.147.100.53\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696255744420477145,\"threadStartTime\":1695658999333342370,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":56275},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":54436,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"amazonas.uol.com.br\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[{\"name\":\"uol.com.br\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":518,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"a10-dns-uolcsfe1.host.intranet\",\"RName\":\"root.uol.com.br\",\"serial\":2016052887,\"refresh\":7200,\"retry\":3600,\"expire\":432000,\"minimum\":900},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696255744441387358,\"threadStartTime\":1695658999333342370,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":33877},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":20551,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":48,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"manualdaquimica.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"roteiroceara.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"roteirosincriveis.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"enem.club\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"brpaycard.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"200-147-100-53.static.uol.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhachip.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhashipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhaship.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhachipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhashipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhaship.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhachipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhashipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhaship.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhachipi.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhachip.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhashipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhaship.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhachipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhachip.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhashipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhaship.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minizinhachipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhashipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhaship.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhachipi.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minisinhachip.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"www.minnisinhachip.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"minnisinhachip.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"somostodosum.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"poderjp.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"tvpanico.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvweb.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvdigital.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvd.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jovempantv.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"tvjovempan.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"panicotv.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"tvpanico.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvweb.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvdigital.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jptvd.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jp.tv.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"jovempantv.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"tvjovempan.com.br\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"meunegocio.uol\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"53.100.147.200.in-addr.arpa\",\"type\":\"PTR\",\"class\":\"IN\",\"TTL\":16493,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"biologianet.com\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#network-based-signatures","title":"Network Based Signatures","text":"<p>It is possible to create Golang (or Rego) signatures for the network events. If you haven't read about how to create signatures, do it HERE.</p> <p>Examples</p> <p>Below is an example of how to create a signature for the <code>net_packet_dns</code> event. This same example is used by Tracee CI/CD tests and can be found at the GitHub repository, together with some other signatures for the network events.</p> <ol> <li>net_packet_dns signature example</li> </ol> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/aquasecurity/tracee/signatures/helpers\"\n    \"github.com/aquasecurity/tracee/types/detect\"\n    \"github.com/aquasecurity/tracee/types/protocol\"\n    \"github.com/aquasecurity/tracee/types/trace\"\n)\n\n//\n// HOWTO: The way to trigger this test signature is to execute:\n//\n//        nslookup -type=mx uol.com.br      and then\n//        nslookup -type=ns uol.com.br      and then\n//        nslookup -type=soa uol.com.br     and then\n//        nslookup -type=txt uol.com.br\n//\n//        This will cause it trigger once and reset it status.\n\ntype e2eDNS struct {\n    foundMX   bool\n    foundNS   bool\n    foundSOA  bool\n    foundTXTs bool\n    cb        detect.SignatureHandler\n}\n\nfunc (sig *e2eDNS) Init(cb detect.SignatureHandler) error {\n    sig.cb = cb\n    sig.foundMX = false   // proforma\n    sig.foundNS = false   // proforma\n    sig.foundSOA = false  // proforma\n    sig.foundTXTs = false // proforma\n    return nil\n}\n\nfunc (sig *e2eDNS) GetMetadata() (detect.SignatureMetadata, error) {\n    return detect.SignatureMetadata{\n        ID:          \"DNS\",\n        Version:     \"0.1.0\",\n        Name:        \"Network DNS Test\",\n        Description: \"Network E2E Tests: DNS\",\n        Tags:        []string{\"e2e\", \"network\"},\n    }, nil\n}\n\nfunc (sig *e2eDNS) GetSelectedEvents() ([]detect.SignatureEventSelector, error) {\n    return []detect.SignatureEventSelector{\n        {Source: \"tracee\", Name: \"net_packet_dns\"},\n    }, nil\n}\n\nfunc (sig *e2eDNS) OnEvent(event protocol.Event) error {\n    eventObj, ok := event.Payload.(trace.Event)\n    if !ok {\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    if eventObj.EventName == \"net_packet_dns\" {\n        dns, err := helpers.GetProtoDNSByName(eventObj, \"proto_dns\")\n        if err != nil {\n            return err\n        }\n\n        if len(dns.Answers) &gt; 0 {\n            for _, answer := range dns.Answers {\n                // check if MX works\n                if answer.MX.Name == \"mx.uol.com.br\" &amp;&amp; answer.MX.Preference == 10 {\n                    sig.foundMX = true\n                }\n                // check if NS works\n                if answer.NS == \"eliot.uol.com.br\" {\n                    sig.foundNS = true\n                }\n                // check if SOA works\n                if answer.SOA.RName == \"root.uol.com.br\" {\n                    sig.foundSOA = true\n                }\n                // check if TXTs works\n                if answer.TXTs != nil &amp;&amp; len(answer.TXTs) &gt; 0 {\n                    for _, txt := range answer.TXTs {\n                        if strings.Contains(txt, \"spf.uol.com.br\") {\n                            sig.foundTXTs = true\n                        }\n                    }\n                }\n            }\n        }\n\n        if !sig.foundMX || !sig.foundNS || !sig.foundSOA || !sig.foundTXTs {\n            return nil\n        }\n\n        if sig.foundMX &amp;&amp; sig.foundNS &amp;&amp; sig.foundSOA &amp;&amp; sig.foundTXTs { // reset signature state\n            sig.foundMX = false\n            sig.foundNS = false\n            sig.foundSOA = false\n            sig.foundTXTs = false\n        }\n\n        m, _ := sig.GetMetadata()\n\n        sig.cb(detect.Finding{\n            SigMetadata: m,\n            Event:       event,\n            Data:        map[string]interface{}{},\n        })\n    }\n\n    return nil\n}\n\nfunc (sig *e2eDNS) OnSignal(s detect.Signal) error {\n    return nil\n}\n\nfunc (sig *e2eDNS) Close() {}\n</code></pre>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/","title":"NetFlowTCPBegin","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#intro","title":"Intro","text":"<p>NetFlowTCPBegin - An event derived from a base network raw event, originated from cgroup skb eBPF programs, specifically designed to monitor the initiation of TCP flows by analyzing IP and TCP headers data.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#description","title":"Description","text":"<p><code>NetFlowTCPBegin</code> leverages cgroup skb eBPF programs to capture raw network events at the kernel level, focusing on the TCP protocol's initiation phase.</p> <p>This event parses IP and TCP headers, identifying the start of TCP communication flows based on SYN, ACK, and FIN flag statuses. By concentrating on these flags, <code>NetFlowTCPBegin</code> efficiently discerns the commencement of TCP connections, providing critical data for network monitoring and security analysis.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#arguments","title":"Arguments","text":"<ol> <li>connectionDirection (<code>string</code>): Classifies the connection as 'incoming' or 'outgoing', based on the packet's direction and SYN flag status.</li> <li>srcIP (<code>string</code>): The source IP address extracted directly from the IP header.</li> <li>dstIP (<code>string</code>): The destination IP address, ascertained from the IP header.</li> <li>srcPort (<code>uint16</code>): The source port, derived from the TCP header.</li> <li>dstPort (<code>uint16</code>): The destination port, obtained from the TCP header.</li> <li>srcDomains (<code>[]string</code>): Domain names related to the source IP, resolved through DNS cache.</li> <li>dstDomains (<code>[]string</code>): Domain names associated with the destination IP, also resolved via DNS cache.</li> </ol>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#origin","title":"Origin","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#derived-from-cgroup-skb-ebpf-programs","title":"Derived from cgroup skb eBPF Programs","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#source","title":"Source","text":"<p>The <code>NetFlowTCPBegin</code> event originates from cgroup skb eBPF programs, which capture and process raw network packets at the kernel level. This sophisticated capture mechanism is specifically tailored for dissecting and analyzing TCP traffic, particularly at the initiation stage of TCP connections.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#purpose","title":"Purpose","text":"<p>The event's primary goal is to provide in-depth visibility into the initiation of TCP connections. By focusing on SYN/ACK/FIN flags within TCP headers, <code>NetFlowTCPBegin</code> offers an efficient and accurate method for identifying the start of TCP communication flows, crucial for network security and performance analysis.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#example-use-case","title":"Example Use Case","text":"<p>Network administrators and security professionals can utilize <code>NetFlowTCPBegin</code> to track the initiation of TCP connections, aiding in the early detection of unusual traffic patterns or unauthorized communication attempts. This information is vital for maintaining network integrity and preempting potential security breaches.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#issues","title":"Issues","text":"<p>Although <code>NetFlowTCPBegin</code> is optimized for low overhead, its efficiency depends on the network traffic volume and the complexity of the TCP flows being monitored. Proper management and analysis of the generated data are essential to maximize the benefits of this event without impacting system performance.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_begin/#related-events","title":"Related Events","text":"<ul> <li><code>net_tcp_connect</code> - similar event, based on the <code>security_socket_connect</code> calls.</li> <li><code>security_socket_connect</code></li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/","title":"NetFlowTCPEnd","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_end/#intro","title":"Intro","text":"<p>NetFlowTCPEnd - An event derived from base network raw event, designed to monitor the termination of TCP flows. It leverages cgroup skb eBPF programs, focusing specifically on the TCP protocol's termination phase, and is instrumental in analyzing IP and TCP headers data to detect the end of TCP connections.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#description","title":"Description","text":"<p><code>NetFlowTCPEnd</code> utilizes cgroup skb eBPF programs to intercept and analyze raw network events at the kernel level, with a particular emphasis on the TCP protocol's termination phase. It processes IP and TCP headers to pinpoint the conclusion of TCP communication flows. The event identifies the termination of TCP connections by analyzing the status of TCP flags, primarily focusing on the FIN and RST flags.</p> <p>By examining these flags, <code>NetFlowTCPEnd</code> provides valuable insights into the end of TCP connections, a critical component for comprehensive network monitoring and security analysis.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#arguments","title":"Arguments","text":"<ol> <li>connectionDirection (<code>string</code>): Indicates whether the terminated connection was 'incoming' or 'outgoing'.</li> <li>srcIP (<code>string</code>): The source IP address, extracted from the IP header, from the side terminating the connection.</li> <li>dstIP (<code>string</code>): The destination IP address, obtained from the IP header, of the side receiving the termination.</li> <li>srcPort (<code>uint16</code>): The source port number, derived from the TCP header.</li> <li>dstPort (<code>uint16</code>): The destination port number, ascertained from the TCP header.</li> <li>srcDomains (<code>[]string</code>): Associated domain names for the source IP, resolved using DNS cache.</li> <li>dstDomains (<code>[]string</code>): Related domain names for the destination IP, determined through DNS cache.</li> </ol>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#origin","title":"Origin","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_end/#derived-from-cgroup-skb-ebpf-programs","title":"Derived from cgroup skb eBPF Programs","text":""},{"location":"docs/events/builtin/network/net_flow_tcp_end/#source","title":"Source","text":"<p><code>NetFlowTCPEnd</code> originates from cgroup skb eBPF programs, enabling the tracing of raw network packets at the kernel level. This advanced mechanism is adept at dissecting TCP traffic, particularly focusing on the termination stage of TCP connections.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#purpose","title":"Purpose","text":"<p>The primary aim of <code>NetFlowTCPEnd</code> is to provide detailed visibility into the termination of TCP connections. By concentrating on FIN and RST flags within TCP headers, it offers an effective and precise approach to identifying the conclusion of TCP communication flows, crucial for network security and performance monitoring.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#example-use-case","title":"Example Use Case","text":"<p>Network administrators and security experts can use <code>NetFlowTCPEnd</code> to monitor the termination of TCP connections. This capability is essential for detecting unusual traffic patterns, potential security threats, or abrupt end of communication, which are vital for ensuring network security and efficiency.</p>"},{"location":"docs/events/builtin/network/net_flow_tcp_end/#issues","title":"Issues","text":"<p>While <code>NetFlowTCPEnd</code> is designed to minimize system overhead, its performance may vary based on the volume of network traffic and the complexity of monitored TCP flows. Efficient data management and analysis are key to leveraging the full potential of this event without affecting system performance adversely.</p> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/network/net_packet_dns/","title":"net_packet_dns","text":""},{"location":"docs/events/builtin/network/net_packet_dns/#dns","title":"DNS","text":"<p>The Domain Name System (DNS) is a hierarchical and distributed naming system used on the Internet to translate human-friendly domain names (e.g., www.example.com) into IP addresses (e.g., 192.0.2.1) that computers use to identify each other on the network. The DNS operates using a client-server architecture, where DNS clients (usually resolvers) send DNS queries to DNS servers (often called name servers) to resolve domain names. The DNS header is a fundamental part of the DNS protocol, containing information about the DNS query or response being exchanged.</p> <p>Here's an overview of the DNS header and its significance:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Transaction ID (16 bits)                                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Flags (16 bits)                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Question Count (16 bits)                                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Answer Count (16 bits)                                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Authority Record Count (16 bits)                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Additional Record Count (16 bits)                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <p>The DNS header consists of several fields, each serving a specific purpose in the DNS query or response:</p> <ol> <li> <p>Transaction ID (16 bits): The Transaction ID is a unique identifier for each DNS query. It allows DNS clients to match responses to the corresponding queries.</p> </li> <li> <p>Flags (16 bits): The Flags field contains various control and configuration options, including:</p> <ul> <li>QR (1 bit): Indicates whether the message is a query (0) or a response (1).</li> <li>Opcode (4 bits): Specifies the type of query (e.g., standard query, inverse query, status request).</li> <li>AA (1 bit): Indicates if the responding name server is authoritative for the queried domain.</li> <li>TC (1 bit): Signifies if the message is truncated due to its size.</li> <li>RD (1 bit): Requests recursive resolution from the DNS server.</li> <li>RA (1 bit): Indicates that the DNS server supports recursive queries.</li> <li>Z (3 bits): Reserved for future use.</li> <li>RCODE (4 bits): Represents the response code, indicating the status of the query (e.g., success, name error, server failure).</li> </ul> </li> <li> <p>Question Count (16 bits): Specifies the number of questions (queries) in the DNS message.</p> </li> <li> <p>Answer Count (16 bits): Indicates the number of resource records in the answer section.</p> </li> <li> <p>Authority Record Count (16 bits): Specifies the number of authority resource records.</p> </li> <li> <p>Additional Record Count (16 bits): Indicates the number of additional resource records.</p> </li> </ol> <p>The DNS protocol is a critical component of Internet infrastructure, enabling users and applications to access websites and services using human-readable domain names. When a user enters a domain name into a web browser or other application, the DNS resolver on the user's device initiates a DNS query by creating a DNS message with the appropriate header fields.</p> <p>DNS queries are typically sent to a local DNS resolver (e.g., provided by an ISP), which may cache previous DNS resolutions or forward the query to authoritative name servers responsible for the queried domain. Recursive queries are used to navigate the DNS hierarchy until the final authoritative name server is reached, and an IP address is returned to the client.</p> <p>DNS responses include the IP address associated with the queried domain name, and optionally, additional information such as the Time-to-Live (TTL) value and other resource records (RRs) like IPv6 addresses or mail server details.</p> <p>The DNS header plays a crucial role in facilitating efficient and accurate DNS resolution. It helps identify the type of DNS message, the number of questions and resource records, and the status of the DNS query or response. The DNS protocol operates transparently for most users, but it is fundamental to the functioning of the Internet, making it possible for users to access websites and services using user-friendly domain names rather than raw IP addresses.</p>"},{"location":"docs/events/builtin/network/net_packet_dns/#net_packet_dns","title":"net_packet_dns","text":"<p>The <code>net_packet_dns</code> event provides one event for each existing DNS packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code>, <code>metadata</code> arguments and all <code>DNS header fields</code>.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_dns\n</code></pre> <pre><code>{\"timestamp\":1696259024822467299,\"threadStartTime\":1696259024820530450,\"processorId\":0,\"processId\":1053474,\"cgroupId\":5650,\"threadId\":1053476,\"parentProcessId\":1037836,\"hostProcessId\":1053474,\"hostThreadId\":1053476,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"sendmmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2326406626,\"processEntityId\":2231131033,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":44493},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":60318,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n{\"timestamp\":1696259024822806573,\"threadStartTime\":1695658999333342120,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":47508},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":62897,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696259024822893266,\"threadStartTime\":1695658999333342120,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"1.1.1.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":37385},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":35323,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696259024854662413,\"threadStartTime\":1695658999333342120,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":47508},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":62897,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":5,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.uol.com.br\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":49,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"dftex7xfha8fh.cloudfront.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.81\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.15\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.88\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1696259024855173520,\"threadStartTime\":1695658999333342120,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"sendmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44493},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":60318,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":5,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.uol.com.br\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":49,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"dftex7xfha8fh.cloudfront.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.81\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.15\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.88\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n{\"timestamp\":1696259024855201893,\"threadStartTime\":1696259024820530450,\"processorId\":4,\"processId\":1053474,\"cgroupId\":5650,\"threadId\":1053476,\"parentProcessId\":1037836,\"hostProcessId\":1053474,\"hostThreadId\":1053476,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2326406626,\"processEntityId\":2231131033,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44493},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":60318,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":5,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.uol.com.br\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":49,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"dftex7xfha8fh.cloudfront.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.81\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.15\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.88\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"108.139.182.16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n{\"timestamp\":1696259024855756036,\"threadStartTime\":1696259024820530450,\"processorId\":1,\"processId\":1053474,\"cgroupId\":5650,\"threadId\":1053476,\"parentProcessId\":1037836,\"hostProcessId\":1053474,\"hostThreadId\":1053476,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2006\",\"eventName\":\"net_packet_dns\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"sendmmsg\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2326406626,\"processEntityId\":2231131033,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53879},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":41668,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_dns_request/","title":"net_packet_dns_request","text":""},{"location":"docs/events/builtin/network/net_packet_dns_request/#dns-request","title":"DNS Request","text":"<p>Check net_packet_dns.md for more information on DNS. The DNS Request event shows DNS queries only.</p> <p>DNS queries come in various types, each serving a specific purpose in the domain name resolution process or in retrieving information from DNS servers.</p> <p>Here are some common types of DNS queries:</p> <ol> <li>Standard Query (A or AAAA): This is the most basic type of DNS query. It requests the IPv4 (A) or IPv6 (AAAA) address associated with a given domain name. For example, when you enter a domain like \"www.example.com\" in your web browser, it sends a standard A or AAAA query to resolve the IP address of the web server.</li> <li>Inverse Query (PTR): Inverse queries do the reverse of standard queries. Instead of providing a domain name and asking for an IP address, an inverse query provides an IP address and asks for the associated domain name (PTR record). PTR records are commonly used in reverse DNS lookups to map IP addresses to domain names.</li> <li>Mail Exchange Query (MX): MX queries are used to retrieve the mail exchange servers responsible for receiving email for a specific domain. These records specify the mail servers' priority and fully qualified domain names (FQDNs).</li> <li>Name Server Query (NS): An NS query is used to discover the authoritative name servers for a domain. These are the servers that hold the DNS records for that domain.</li> <li>Start of Authority Query (SOA): SOA queries retrieve the Start of Authority record for a domain. The SOA record contains essential information about the domain, such as the primary name server, contact information, and timing data for DNS updates.</li> <li>Service Query (SRV): SRV queries are used to locate services associated with a specific domain. These queries allow for the discovery of services like SIP, XMPP, or LDAP.</li> <li>Text Query (TXT): TXT queries retrieve text-based information associated with a domain. TXT records are versatile and can contain various types of data, including human-readable text and machine-readable data used for authentication and verification.</li> <li>Canonical Name Query (CNAME): CNAME queries are used to find the canonical (true) name of an alias domain. For example, they allow you to determine the actual domain pointed to by a CNAME record.</li> <li>Pointer Query (PTR) for IPv6: While PTR queries are commonly associated with reverse DNS lookups for IPv4 addresses, similar queries can be performed for IPv6 addresses to retrieve the reverse DNS mapping of IPv6 addresses to domain names.</li> <li>Wildcard Query: Wildcard queries use the '*' character as a wildcard to match multiple subdomains or hostnames within a domain. They are used to retrieve multiple DNS records that share a common pattern.</li> </ol> <p>These are some of the common DNS query types, each designed to serve a specific purpose in the DNS resolution process or in retrieving specific DNS information. DNS queries are an integral part of how the Internet functions, allowing users and applications to resolve domain names into IP addresses and access services and resources on the web.</p>"},{"location":"docs/events/builtin/network/net_packet_dns_request/#net_packet_dns_request","title":"net_packet_dns_request","text":"<p>The <code>net_packet_dns_request</code> provides one event for each existing DNS packet, containing a query, that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code> arguments and customized arguments showing important data about the query being made.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_dns_request\n</code></pre> <pre><code>{\"timestamp\":1696255905516744399,\"threadStartTime\":1695658999333342363,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2007\",\"eventName\":\"net_packet_dns_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"192.168.200.50\",\"dst_ip\":\"8.8.8.8\",\"src_port\":56650,\"dst_port\":53,\"protocol\":17,\"packet_len\":68,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.zip.net\",\"query_type\":\"AAAA\",\"query_class\":\"IN\"}]}]}\n{\"timestamp\":1696255905516817908,\"threadStartTime\":1695658999333342363,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2007\",\"eventName\":\"net_packet_dns_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"192.168.200.50\",\"dst_ip\":\"8.8.8.8\",\"src_port\":46530,\"dst_port\":53,\"protocol\":17,\"packet_len\":68,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.zip.net\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n{\"timestamp\":1696255905516899291,\"threadStartTime\":1695658999333342363,\"processorId\":4,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2007\",\"eventName\":\"net_packet_dns_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"192.168.200.50\",\"dst_ip\":\"1.1.1.1\",\"src_port\":36605,\"dst_port\":53,\"protocol\":17,\"packet_len\":68,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.zip.net\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_dns_response/","title":"net_packet_dns_response","text":""},{"location":"docs/events/builtin/network/net_packet_dns_response/#dns-response","title":"DNS Response","text":"<p>Check net_packet_dns.md for more information on DNS. The DNS Response event shows DNS answers only.</p> <p>DNS responses come in various types, corresponding to the different types of DNS queries and the information stored in DNS resource records (RRs).</p> <p>Here are some common types of DNS responses:</p> <ol> <li>Standard Response (A or AAAA): This is the most common type of DNS response. It contains the IPv4 (A) or IPv6 (AAAA) address associated with the queried domain name. For example, when you request the IP address of \"www.example.com,\" the DNS response contains the IP address.</li> <li>Inverse Response (PTR): Inverse responses provide reverse DNS mapping by associating an IP address with a domain name. This is often used in reverse DNS lookups to translate an IP address into a domain name.</li> <li>Mail Exchange Response (MX): MX responses provide information about the mail exchange servers responsible for receiving email for a specific domain. These responses include the priority and FQDN of the mail servers.</li> <li>Name Server Response (NS): NS responses specify the authoritative name servers for a domain. These are the servers that hold the DNS records for that domain.</li> <li>Start of Authority Response (SOA): SOA responses contain information about the primary name server, contact information, and timing data for DNS updates for a specific domain.</li> <li>Service Response (SRV): SRV responses provide information about services associated with a domain. These responses allow clients to discover services like SIP, XMPP, or LDAP and the associated server addresses and ports.</li> <li>Text Response (TXT): TXT responses contain text-based information associated with a domain. TXT records are versatile and can include various types of data, such as human-readable text and machine-readable data used for authentication, verification, or policy records.</li> <li>Canonical Name Response (CNAME): CNAME responses indicate that the queried domain name is an alias (canonical name) for another domain name. The response provides the canonical (true) name to which the alias points.</li> <li>Pointer Response (PTR) for IPv4: PTR responses provide the reverse DNS mapping for IPv4 addresses, associating an IP address with its corresponding domain name.</li> <li>Pointer Response (PTR) for IPv6: Similar to IPv4 PTR responses, PTR responses for IPv6 provide the reverse DNS mapping for IPv6 addresses, associating an IPv6 address with its domain name.</li> <li>Not Found Response (NXDOMAIN): This response indicates that the queried domain name does not exist in the DNS zone. It is used when there is no matching DNS record for the query.</li> <li>Wildcard Response: Wildcard responses are used when a wildcard query matches multiple subdomains or hostnames within a domain. The response provides information for all matching subdomains or hostnames.</li> </ol> <p>These are some of the common types of DNS responses, each serving a specific purpose in providing DNS information to clients and resolvers. DNS responses are essential for translating domain names into IP addresses and facilitating communication on the Internet.</p>"},{"location":"docs/events/builtin/network/net_packet_dns_response/#net_packet_dns_response","title":"net_packet_dns_response","text":"<p>The <code>net_packet_dns_response</code> provides one event for each existing DNS packet, containing a query, that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code> arguments and customized arguments showing important data about the obtained response.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_dns_response\n</code></pre> <pre><code>{\"timestamp\":1696257538821986017,\"threadStartTime\":1695658999333342058,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2008\",\"eventName\":\"net_packet_dns_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"1.1.1.1\",\"dst_ip\":\"192.168.200.50\",\"src_port\":53,\"dst_port\":34184,\"protocol\":17,\"packet_len\":117,\"iface\":\"any\"}},{\"name\":\"dns_response\",\"type\":\"[]trace.DnsResponseData\",\"value\":[{\"query_data\":{\"query\":\"www.zip.net\",\"query_type\":\"A\",\"query_class\":\"IN\"},\"dns_answer\":[{\"answer_type\":\"CNAME\",\"ttl\":300,\"answer\":\"amazonas.uol.com.br\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"200.147.100.53\"}]}]}]}\n{\"timestamp\":1696257538822455864,\"threadStartTime\":1695658999333342058,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2008\",\"eventName\":\"net_packet_dns_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"8.8.8.8\",\"dst_ip\":\"192.168.200.50\",\"src_port\":53,\"dst_port\":55287,\"protocol\":17,\"packet_len\":172,\"iface\":\"any\"}},{\"name\":\"dns_response\",\"type\":\"[]trace.DnsResponseData\",\"value\":[{\"query_data\":{\"query\":\"www.zip.net\",\"query_type\":\"AAAA\",\"query_class\":\"IN\"},\"dns_answer\":[{\"answer_type\":\"CNAME\",\"ttl\":300,\"answer\":\"amazonas.uol.com.br\"}]}]}]}\n{\"timestamp\":1696257538823870518,\"threadStartTime\":1695658999333342058,\"processorId\":6,\"processId\":472,\"cgroupId\":2626,\"threadId\":472,\"parentProcessId\":1,\"hostProcessId\":472,\"hostThreadId\":472,\"hostParentProcessId\":1,\"userId\":976,\"mountNamespace\":4026532555,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2008\",\"eventName\":\"net_packet_dns_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":131662446,\"processEntityId\":131662446,\"parentEntityId\":1975426032,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"8.8.8.8\",\"dst_ip\":\"192.168.200.50\",\"src_port\":53,\"dst_port\":42873,\"protocol\":17,\"packet_len\":117,\"iface\":\"any\"}},{\"name\":\"dns_response\",\"type\":\"[]trace.DnsResponseData\",\"value\":[{\"query_data\":{\"query\":\"www.zip.net\",\"query_type\":\"A\",\"query_class\":\"IN\"},\"dns_answer\":[{\"answer_type\":\"CNAME\",\"ttl\":300,\"answer\":\"amazonas.uol.com.br\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"200.147.3.199\"}]}]}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_http/","title":"net_packet_http","text":""},{"location":"docs/events/builtin/network/net_packet_http/#http","title":"HTTP","text":"<p>The HTTP header is an integral part of the Hypertext Transfer Protocol (HTTP), which is the foundation of data communication on the World Wide Web. HTTP headers are metadata included in both HTTP requests and responses, and they carry essential information about the nature and handling of the data being transmitted between a client (such as a web browser) and a web server.</p> <p>Here's an overview of the HTTP header and its significance:</p> <p>Request Headers:</p> <p>These headers provide information about the client's request, including details about the requested resource, preferred content types, and client capabilities.</p> <ul> <li>User-Agent: Specifies the user agent (e.g., web browser or client application) making the request.</li> <li>Host: Indicates the domain name of the web server.</li> <li>Accept: Specifies the content types that the client can accept.</li> <li>Authorization: Used for authentication, typically containing credentials.</li> <li>Cookie: Contains data associated with the user's session.</li> <li>Referer (or Referrer): Indicates the URL of the referring web page.</li> </ul> <pre><code>GET /path/to/resource HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n</code></pre> <p>Response Headers:</p> <p>These headers provide information about the server's response, including metadata about the resource and how it should be handled.</p> <ul> <li>Server: Identifies the web server software and version.</li> <li>Content-Type: Specifies the media type (e.g., HTML, JSON) of the response content.</li> <li>Content-Length: Indicates the size of the response body in bytes.</li> <li>Location: Used for redirection, providing the URL to which the client should redirect.</li> <li>Cache-Control: Defines caching directives for the client and intermediaries.</li> <li>Set-Cookie: Sets cookies in the client's browser to maintain stateful information.</li> </ul> <pre><code>HTTP/1.1 200 OK\nDate: Mon, 03 Oct 2023 12:34:56 GMT\nServer: Apache/2.4.41 (Ubuntu)\nContent-Type: text/html; charset=UTF-8\nContent-Length: 12345\n</code></pre> <p>HTTP is the protocol that powers the web by facilitating the exchange of data between clients and servers. When a user interacts with a web application or browses a website, their web browser sends HTTP requests to web servers hosting the requested resources (e.g., web pages, images, scripts). These requests include HTTP headers that convey important details about the user's preferences and requirements.</p> <p>Upon receiving an HTTP request, the web server processes the request, generates an HTTP response, and attaches its own set of headers to the response. These headers contain information about the resource being served, its format, caching policies, and more. For example, the \"Content-Type\" header specifies whether the response is HTML, JSON, or another format, while \"Content-Length\" indicates the size of the response data.</p> <p>HTTP headers also play a crucial role in supporting various web features and security mechanisms. For instance, \"Authorization\" headers are used for user authentication, \"Referer\" headers help track referral sources, and \"Cookie\" headers enable session management.</p>"},{"location":"docs/events/builtin/network/net_packet_http/#net_packet_http","title":"net_packet_http","text":"<p>The <code>net_packet_http</code> event provides one event for each existing HTTP packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code>, <code>metadata</code> arguments, the full HTTP Header, its contents and more related information.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_http\n</code></pre> <pre><code>{\"timestamp\":1696269931297494423,\"threadStartTime\":1696269818755096557,\"processorId\":0,\"processId\":21,\"cgroupId\":18465,\"threadId\":99695,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1091300,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-164\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2009\",\"eventName\":\"net_packet_http\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":756761678,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"172.17.0.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.11\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":46348},{\"name\":\"proto_http\",\"type\":\"trace.ProtoHTTP\",\"value\":{\"direction\":\"response\",\"method\":\"\",\"protocol\":\"HTTP/1.1\",\"host\":\"\",\"uri_path\":\"\",\"status\":\"200 \",\"status_code\":200,\"headers\":{\"Content-Length\":[\"180\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:05:31 GMT\"]},\"content_length\":180}}]}\n{\"timestamp\":1696269933962085345,\"threadStartTime\":1696269933920911687,\"processorId\":6,\"processId\":1092840,\"cgroupId\":5650,\"threadId\":1092840,\"parentProcessId\":1037836,\"hostProcessId\":1092840,\"hostThreadId\":1092840,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"curl\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2009\",\"eventName\":\"net_packet_http\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3903007647,\"processEntityId\":3903007647,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"142.251.128.68\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":54894},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_http\",\"type\":\"trace.ProtoHTTP\",\"value\":{\"direction\":\"request\",\"method\":\"GET\",\"protocol\":\"HTTP/1.1\",\"host\":\"www.google.com\",\"uri_path\":\"/\",\"status\":\"\",\"status_code\":0,\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"curl/8.3.0\"]},\"content_length\":0}}]}\n{\"timestamp\":1696269934070871329,\"threadStartTime\":1696269933920911687,\"processorId\":6,\"processId\":1092840,\"cgroupId\":5650,\"threadId\":1092840,\"parentProcessId\":1037836,\"hostProcessId\":1092840,\"hostThreadId\":1092840,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"curl\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2009\",\"eventName\":\"net_packet_http\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3903007647,\"processEntityId\":3903007647,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"142.251.128.68\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":54894},{\"name\":\"proto_http\",\"type\":\"trace.ProtoHTTP\",\"value\":{\"direction\":\"response\",\"method\":\"\",\"protocol\":\"HTTP/1.1\",\"host\":\"\",\"uri_path\":\"\",\"status\":\"200 OK\",\"status_code\":200,\"headers\":{\"Accept-Ranges\":[\"none\"],\"Cache-Control\":[\"private, max-age=0\"],\"Content-Security-Policy-Report-Only\":[\"object-src 'none';base-uri 'self';script-src 'nonce-KaLfx0e0TtSb-jA3800WsQ' 'strict-dynamic' 'report-sample' 'unsafe-eval' 'unsafe-inline' https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp\"],\"Content-Type\":[\"text/html; charset=ISO-8859-1\"],\"Date\":[\"Mon, 02 Oct 2023 18:05:29 GMT\"],\"Expires\":[\"-1\"],\"P3p\":[\"CP=\\\"This is not a P3P policy! See g.co/p3phelp for more info.\\\"\"],\"Server\":[\"gws\"],\"Set-Cookie\":[\"1P_JAR=2023-10-02-18; expires=Wed, 01-Nov-2023 18:05:29 GMT; path=/; domain=.google.com; Secure\",\"AEC=Ackid1S2DnK3U6XCf0FULRi0Fa9KOmCQYPGhJZCO_DxYQY2rKyEM5VJ-NDs; expires=Sat, 30-Mar-2024 18:05:29 GMT; path=/; domain=.google.com; Secure; HttpOnly; SameSite=lax\",\"NID=511=aaaaaaaaaaaA-IoAv6rXsHvxqFmEHiEas5ZKLzivyXGGdxKF5dqeg-UG9J-Bvi5wRGTn5Ti9Iyvi6oDsu3WDKRw7O2ZoeRAOwfNNB40o9wjyBcm0PDBX54oxl4E8NYE4wewzI5K3BzxZi6rLncb__EDzlEcCLEvAQpCB-iIX70o; expires=Tue, 02-Apr-2024 18:05:29 GMT; path=/; domain=.google.com; HttpOnly\"],\"Vary\":[\"Accept-Encoding\"],\"X-Frame-Options\":[\"SAMEORIGIN\"],\"X-Xss-Protection\":[\"0\"]},\"content_length\":-1}}]}\n{\"timestamp\":1696269935497378027,\"threadStartTime\":1696269818755096557,\"processorId\":7,\"processId\":21,\"cgroupId\":18465,\"threadId\":99695,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1091300,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-164\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2009\",\"eventName\":\"net_packet_http\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":756761678,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"172.17.0.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.13\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":35830},{\"name\":\"proto_http\",\"type\":\"trace.ProtoHTTP\",\"value\":{\"direction\":\"response\",\"method\":\"\",\"protocol\":\"HTTP/1.1\",\"host\":\"\",\"uri_path\":\"\",\"status\":\"200 \",\"status_code\":200,\"headers\":{\"Content-Length\":[\"263\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:05:35 GMT\"]},\"content_length\":263}}]}\n{\"timestamp\":1696269935578759155,\"threadStartTime\":1696269818755096557,\"processorId\":3,\"processId\":21,\"cgroupId\":18465,\"threadId\":99695,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1091300,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-164\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2009\",\"eventName\":\"net_packet_http\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":756761678,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"172.17.0.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.12\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":51430},{\"name\":\"proto_http\",\"type\":\"trace.ProtoHTTP\",\"value\":{\"direction\":\"response\",\"method\":\"\",\"protocol\":\"HTTP/1.1\",\"host\":\"\",\"uri_path\":\"\",\"status\":\"200 \",\"status_code\":200,\"headers\":{\"Content-Length\":[\"319\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:05:35 GMT\"]},\"content_length\":319}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_http_request/","title":"net_packet_http_request","text":""},{"location":"docs/events/builtin/network/net_packet_http_request/#http","title":"HTTP","text":"<p>Check net_packet_http.md for more information on HTTP. The HTTP Request event shows HTTP requests only.</p> <p>HTTP (Hypertext Transfer Protocol) requests are an integral part of how web browsers and other clients communicate with web servers to retrieve and interact with web resources. An HTTP request is a message sent by a client (e.g., a web browser) to a server (e.g., a web server) to request a specific resource, such as a web page, image, or API endpoint. These requests are fundamental to the functioning of the World Wide Web and are responsible for loading web pages, submitting forms, and interacting with web services.</p> <p>An HTTP request typically includes several key components. Example:</p> <pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nReferer: https://www.google.com/\nCookie: session_id=1234567890; user_prefs=dark_mode\nConnection: keep-alive\n</code></pre> <p>In this example:</p> <ol> <li>Request Method: The request uses the <code>GET</code> method, indicating a request to retrieve data.</li> <li>URI: The URI specifies the resource being requested as <code>/index.html</code>. It includes the path to the file on the server.</li> <li>HTTP Version: The request uses HTTP/1.1.</li> <li>Host Header: The <code>Host</code> header indicates the domain name of the server, which is <code>www.example.com</code>.</li> <li>User-Agent Header: The <code>User-Agent</code> header provides information about the client's user agent, which is a web browser (Google Chrome).</li> <li>Accept Header: The <code>Accept</code> header specifies the types of content the client can accept, including HTML and XML.</li> <li>Accept-Language Header: The <code>Accept-Language</code> header indicates the preferred languages for content, with English as the primary language.</li> <li>Referer Header: The <code>Referer</code> header identifies the URL of the referring web page, in this case, Google's search results page.</li> <li>Cookie Header: The <code>Cookie</code> header includes session information and user preferences as cookies.</li> <li>Connection Header: The <code>Connection</code> header is set to <code>keep-alive</code>, indicating that the client wants to keep the TCP connection open for potential future requests.</li> <li>...</li> </ol> <p>This example represents a simplified HTTP request, but real-world requests can include many more headers and a request body, depending on the specific use case and the web application's requirements. The server processes this request and responds with the appropriate resource, typically in an HTTP response message.</p> <p>Once the HTTP request is constructed, the client sends it to the server, which processes the request and generates an HTTP response. The response typically includes the requested resource, along with its own set of HTTP headers.</p> <p>HTTP requests are versatile and support various features, including authentication, caching, content negotiation, and more. They are the foundation of the web's interactivity and enable users to browse websites, submit forms, and interact with web applications seamlessly. Developers and webmasters use HTTP requests extensively when building and maintaining web-based systems to deliver content and services to users worldwide.</p>"},{"location":"docs/events/builtin/network/net_packet_http_request/#net_packet_http_request","title":"net_packet_http_request","text":"<p>The <code>net_packet_http_request</code> event provides one event for each existing HTTP request that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code> arguments, the full HTTP Header, its contents and more related information.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_http_request\n</code></pre> <pre><code>{\"timestamp\":1696259155542061071,\"threadStartTime\":1696259155505431448,\"processorId\":6,\"processId\":1055252,\"cgroupId\":5650,\"threadId\":1055252,\"parentProcessId\":1037836,\"hostProcessId\":1055252,\"hostThreadId\":1055252,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"curl\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2010\",\"eventName\":\"net_packet_http_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3061510256,\"processEntityId\":3061510256,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"192.168.200.50\",\"dst_ip\":\"142.251.129.36\",\"src_port\":50064,\"dst_port\":80,\"protocol\":6,\"packet_len\":129,\"iface\":\"any\"}},{\"name\":\"http_request\",\"type\":\"trace.ProtoHTTPRequest\",\"value\":{\"method\":\"GET\",\"protocol\":\"HTTP/1.1\",\"host\":\"www.google.com\",\"uri_path\":\"/\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"curl/8.3.0\"]},\"content_length\":0}}]}\n{\"timestamp\":1696259158887036266,\"threadStartTime\":1696203826511069764,\"processorId\":7,\"processId\":963213,\"cgroupId\":5650,\"threadId\":963219,\"parentProcessId\":963208,\"hostProcessId\":963213,\"hostThreadId\":963219,\"hostParentProcessId\":963168,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"Chrome_ChildIOT\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2010\",\"eventName\":\"net_packet_http_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2469898314,\"processEntityId\":1872563844,\"parentEntityId\":2821133720,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"::1\",\"dst_ip\":\"::1\",\"src_port\":49622,\"dst_port\":8000,\"protocol\":6,\"packet_len\":781,\"iface\":\"any\"}},{\"name\":\"http_request\",\"type\":\"trace.ProtoHTTPRequest\",\"value\":{\"method\":\"GET\",\"protocol\":\"HTTP/1.1\",\"host\":\"localhost:8000\",\"uri_path\":\"/livereload/600097443/600104814\",\"headers\":{\"Accept\":[\"*/*\"],\"Accept-Encoding\":[\"gzip, deflate, br\"],\"Accept-Language\":[\"en-US,en;q=0.9,pt-BR;q=0.8,pt;q=0.7\"],\"Connection\":[\"keep-alive\"],\"Cookie\":[\"org.cups.sid=12344c3a4fd11efabe2dba9519517966; unifises=monAplOcbPmRSi26LDgZiM7fZr31Xwuu; csrf_token=B86NGyz9RgNbLahz6tjrY4qrKdC4try5\"],\"Dnt\":[\"1\"],\"Referer\":[\"http://localhost:8000/tracee/docs/events/builtin/network/net_packet_ipv4/\"],\"Sec-Ch-Ua\":[\"\\\"Google Chrome\\\";v=\\\"117\\\", \\\"Not;A=Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"117\\\"\"],\"Sec-Ch-Ua-Mobile\":[\"?0\"],\"Sec-Ch-Ua-Platform\":[\"\\\"Linux\\\"\"],\"Sec-Fetch-Dest\":[\"empty\"],\"Sec-Fetch-Mode\":[\"cors\"],\"Sec-Fetch-Site\":[\"same-origin\"],\"User-Agent\":[\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36\"]},\"content_length\":0}}]}\n{\"timestamp\":1696259158887212058,\"threadStartTime\":1696255132899010481,\"processorId\":3,\"processId\":1022747,\"cgroupId\":5142,\"threadId\":1035048,\"parentProcessId\":1022554,\"hostProcessId\":1022747,\"hostThreadId\":1035048,\"hostParentProcessId\":1302,\"userId\":0,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"docker-proxy\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2010\",\"eventName\":\"net_packet_http_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2934239730,\"processEntityId\":3554267035,\"parentEntityId\":3216747323,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"172.17.0.1\",\"dst_ip\":\"172.17.0.3\",\"src_port\":53870,\"dst_port\":8000,\"protocol\":6,\"packet_len\":801,\"iface\":\"any\"}},{\"name\":\"http_request\",\"type\":\"trace.ProtoHTTPRequest\",\"value\":{\"method\":\"GET\",\"protocol\":\"HTTP/1.1\",\"host\":\"localhost:8000\",\"uri_path\":\"/livereload/600097443/600104814\",\"headers\":{\"Accept\":[\"*/*\"],\"Accept-Encoding\":[\"gzip, deflate, br\"],\"Accept-Language\":[\"en-US,en;q=0.9,pt-BR;q=0.8,pt;q=0.7\"],\"Connection\":[\"keep-alive\"],\"Cookie\":[\"org.cups.sid=12344c3a4ed12efabe2dba9519517966; unifises=monAplOcbPmRSi26LDgZiM7fZr31Xwuu; csrf_token=B86NGyz9RgNbLahz6tjrY4qrKdC4try5\"],\"Dnt\":[\"1\"],\"Referer\":[\"http://localhost:8000/tracee/docs/events/builtin/network/net_packet_ipv4/\"],\"Sec-Ch-Ua\":[\"\\\"Google Chrome\\\";v=\\\"117\\\", \\\"Not;A=Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"117\\\"\"],\"Sec-Ch-Ua-Mobile\":[\"?0\"],\"Sec-Ch-Ua-Platform\":[\"\\\"Linux\\\"\"],\"Sec-Fetch-Dest\":[\"empty\"],\"Sec-Fetch-Mode\":[\"cors\"],\"Sec-Fetch-Site\":[\"same-origin\"],\"User-Agent\":[\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36\"]},\"content_length\":0}}]}\n{\"timestamp\":1696259161872205237,\"threadStartTime\":1696259161583361191,\"processorId\":0,\"processId\":1055283,\"cgroupId\":5650,\"threadId\":1055283,\"parentProcessId\":1037836,\"hostProcessId\":1055283,\"hostThreadId\":1055283,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"curl\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2010\",\"eventName\":\"net_packet_http_request\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4056179853,\"processEntityId\":4056179853,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"192.168.200.50\",\"dst_ip\":\"95.217.163.246\",\"src_port\":53810,\"dst_port\":80,\"protocol\":6,\"packet_len\":132,\"iface\":\"any\"}},{\"name\":\"http_request\",\"type\":\"trace.ProtoHTTPRequest\",\"value\":{\"method\":\"GET\",\"protocol\":\"HTTP/1.1\",\"host\":\"www.archlinux.org\",\"uri_path\":\"/\",\"headers\":{\"Accept\":[\"*/*\"],\"User-Agent\":[\"curl/8.3.0\"]},\"content_length\":0}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_http_response/","title":"net_packet_http_response","text":""},{"location":"docs/events/builtin/network/net_packet_http_response/#http-response","title":"HTTP Response","text":"<p>HTTP responses are critical components of web communication, providing servers' answers to clients' requests in the Hypertext Transfer Protocol (HTTP). These responses contain the requested resources, such as web pages, images, or data, along with vital metadata. Understanding HTTP responses is essential for web developers and administrators as they play a pivotal role in delivering web content to users.</p> <p>An HTTP response comprises several key components:</p> <pre><code>HTTP/1.1 200 OK\nDate: Mon, 03 Oct 2023 12:34:56 GMT\nServer: Apache/2.4.41 (Ubuntu)\nContent-Type: text/html; charset=UTF-8\nContent-Length: 12345\nCache-Control: max-age=3600, public\nSet-Cookie: session_id=abcdef123456; Path=/; Secure; HttpOnly; SameSite=Lax\nLast-Modified: Fri, 01 Oct 2023 18:00:00 GMT\nETag: \"123456789\"\nAccept-Ranges: bytes\nConnection: keep-alive\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Example Page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome to the Example Page&lt;/h1&gt;\n    &lt;p&gt;This is a sample HTTP response.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In this example:</p> <ol> <li>Status Line: The status line indicates that this is an HTTP/1.1 response with a status code of <code>200 OK</code>, indicating a successful response.</li> <li>Date Header: The <code>Date</code> header specifies the date and time when the response was generated.</li> <li>Server Header: The <code>Server</code> header identifies the web server software and version running on the server.</li> <li>Content-Type Header: The <code>Content-Type</code> header indicates that the response contains HTML (<code>text/html</code>) with UTF-8 character encoding.</li> <li>Content-Length Header: The <code>Content-Length</code> header specifies the size of the response body in bytes (12345 bytes).</li> <li>Cache-Control Header: The <code>Cache-Control</code> header defines caching directives for the client and intermediaries, setting a maximum age of 3600 seconds (1 hour) and allowing public caching.</li> <li>Set-Cookie Header: The <code>Set-Cookie</code> header sets a session cookie named <code>session_id</code> with a secure attribute, HTTP-only attribute, and a SameSite policy of Lax.</li> <li>Last-Modified Header: The <code>Last-Modified</code> header indicates the date and time when the resource was last modified.</li> <li>ETag Header: The <code>ETag</code> header provides an entity tag for caching purposes.</li> <li>Accept-Ranges Header: The <code>Accept-Ranges</code> header indicates that the server supports byte-range requests.</li> <li>Connection Header: The <code>Connection</code> header is set to <code>keep-alive</code>, indicating that the server wants to keep the TCP connection open for potential future requests.</li> <li>Response Body: The response body contains an HTML document with a title, heading, and paragraph, which is the actual content of the requested resource.</li> </ol> <p>This example demonstrates a simplified HTTP response, but real-world responses can contain more headers and a larger response body, depending on the specific resource and server configuration. HTTP responses enable clients to receive and interpret web content, allowing users to view web pages, images, or other resources in their web browsers.</p> <p>HTTP responses are versatile and can convey various information. They can also include cookies for session management, set caching policies to optimize performance, and provide instructions for further actions, such as redirection.</p> <p>HTTP responses are integral to web browsing and application development, enabling clients to access and display web content seamlessly. Understanding the information conveyed within HTTP responses is crucial for developers and administrators to ensure efficient and secure communication between clients and servers on the World Wide Web.</p>"},{"location":"docs/events/builtin/network/net_packet_http_response/#net_packet_http_response","title":"net_packet_http_response","text":"<p>The <code>net_packet_http_response</code> event provides one event for each existing HTTP response that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code> arguments, the full HTTP Header, its contents and more related information.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_http_response\n</code></pre> <pre><code>{\"timestamp\":1696269878969198725,\"threadStartTime\":1696268045240158340,\"processorId\":6,\"processId\":21,\"cgroupId\":18465,\"threadId\":98926,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1077380,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-161\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2011\",\"eventName\":\"net_packet_http_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":1303867201,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"172.17.0.2\",\"dst_ip\":\"192.168.100.16\",\"src_port\":8080,\"dst_port\":50322,\"protocol\":6,\"packet_len\":331,\"iface\":\"any\"}},{\"name\":\"http_response\",\"type\":\"trace.ProtoHTTPResponse\",\"value\":{\"status\":\"200 \",\"status_code\":200,\"protocol\":\"HTTP/1.1\",\"headers\":{\"Content-Length\":[\"180\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:04:38 GMT\"]},\"content_length\":180}}]}\n{\"timestamp\":1696269880377378962,\"threadStartTime\":1696269880249502196,\"processorId\":6,\"processId\":1092254,\"cgroupId\":5650,\"threadId\":1092254,\"parentProcessId\":1037836,\"hostProcessId\":1092254,\"hostThreadId\":1092254,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"curl\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2011\",\"eventName\":\"net_packet_http_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1225483232,\"processEntityId\":1225483232,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"142.251.132.36\",\"dst_ip\":\"192.168.200.50\",\"src_port\":80,\"dst_port\":42606,\"protocol\":6,\"packet_len\":2852,\"iface\":\"any\"}},{\"name\":\"http_response\",\"type\":\"trace.ProtoHTTPResponse\",\"value\":{\"status\":\"200 OK\",\"status_code\":200,\"protocol\":\"HTTP/1.1\",\"headers\":{\"Accept-Ranges\":[\"none\"],\"Cache-Control\":[\"private, max-age=0\"],\"Content-Security-Policy-Report-Only\":[\"object-src 'none';base-uri 'self';script-src 'nonce-u5D68fG7x3C4aNvFt9Pg1g' 'strict-dynamic' 'report-sample' 'unsafe-eval' 'unsafe-inline' https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp\"],\"Content-Type\":[\"text/html; charset=ISO-8859-1\"],\"Date\":[\"Mon, 02 Oct 2023 18:04:36 GMT\"],\"Expires\":[\"-1\"],\"P3p\":[\"CP=\\\"This is not a P3P policy! See g.co/p3phelp for more info.\\\"\"],\"Server\":[\"gws\"],\"Set-Cookie\":[\"1P_JAR=2023-10-02-18; expires=Wed, 01-Nov-2023 18:04:36 GMT; path=/; domain=.google.com; Secure\",\"AEC=Ackid1R0wdgXEgtb4J6PdiRAgKV9sweuRHnFVEJQpH1gfj0f8yBOtiKokV8; expires=Sat, 30-Mar-2024 18:04:36 GMT; path=/; domain=.google.com; Secure; HttpOnly; SameSite=lax\",\"NID=511=fhw31kVbscPFimDzfMPJ1r2kduV6AqtzgKUxqZbXwZCMSL3pEFOuqNZCwz3Q6Xwxyv4kRva7uzeF8zu--4PXyIi59PGTmzlMGqqPH_TRuvKq83ktYDkaX-oq3AltqZHGEMwxIzEQZkPhr83glWmlYQKdWFGu39MULyEttMbRLGw; expires=Tue, 02-Apr-2024 18:04:36 GMT; path=/; domain=.google.com; HttpOnly\"],\"Vary\":[\"Accept-Encoding\"],\"X-Frame-Options\":[\"SAMEORIGIN\"],\"X-Xss-Protection\":[\"0\"]},\"content_length\":-1}}]}\n{\"timestamp\":1696269880812078239,\"threadStartTime\":1696268045240158340,\"processorId\":6,\"processId\":21,\"cgroupId\":18465,\"threadId\":98926,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1077380,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-161\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2011\",\"eventName\":\"net_packet_http_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":1303867201,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"172.17.0.2\",\"dst_ip\":\"192.168.100.12\",\"src_port\":8080,\"dst_port\":51420,\"protocol\":6,\"packet_len\":260,\"iface\":\"any\"}},{\"name\":\"http_response\",\"type\":\"trace.ProtoHTTPResponse\",\"value\":{\"status\":\"200 \",\"status_code\":200,\"protocol\":\"HTTP/1.1\",\"headers\":{\"Content-Length\":[\"109\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:04:40 GMT\"]},\"content_length\":109}}]}\n{\"timestamp\":1696269882656565968,\"threadStartTime\":1696268045240158340,\"processorId\":6,\"processId\":21,\"cgroupId\":18465,\"threadId\":98926,\"parentProcessId\":7,\"hostProcessId\":691018,\"hostThreadId\":1077380,\"hostParentProcessId\":691004,\"userId\":0,\"mountNamespace\":4026532885,\"pidNamespace\":4026532889,\"processName\":\"inform-161\",\"executable\":{\"path\":\"\"},\"hostName\":\"95e88e281c4b\",\"containerId\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\",\"container\":{\"id\":\"95e88e281c4b47994e0d17ac74b83761fbc3ea570c3f1d4b98b6501ecc00dd84\"},\"kubernetes\":{},\"eventId\":\"2011\",\"eventName\":\"net_packet_http_response\",\"matchedPolicies\":[\"\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":true,\"isCompat\":false},\"threadEntityId\":1303867201,\"processEntityId\":1031873185,\"parentEntityId\":4179927769,\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"172.17.0.2\",\"dst_ip\":\"192.168.100.15\",\"src_port\":8080,\"dst_port\":58612,\"protocol\":6,\"packet_len\":358,\"iface\":\"any\"}},{\"name\":\"http_response\",\"type\":\"trace.ProtoHTTPResponse\",\"value\":{\"status\":\"200 \",\"status_code\":200,\"protocol\":\"HTTP/1.1\",\"headers\":{\"Content-Length\":[\"207\"],\"Content-Type\":[\"application/x-binary\"],\"Date\":[\"Mon, 02 Oct 2023 18:04:42 GMT\"]},\"content_length\":207}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_icmp/","title":"net_packet_icmp","text":""},{"location":"docs/events/builtin/network/net_packet_icmp/#icmp","title":"ICMP","text":"<p>The Internet Control Message Protocol (ICMP) is a network layer protocol within the Internet protocol suite (TCP/IP). ICMP is primarily used for diagnostic and control purposes, allowing devices in a network to communicate error and status information about network conditions. It is commonly employed by networking utilities and diagnostic tools such as ping and traceroute. The ICMP protocol operates at the network layer, just like IP, and it uses specific message types encapsulated within ICMP packets.</p> <p>The ICMP header consists of several fields:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Type (8 bits)             |    Code (8 bits)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Checksum (16 bits)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Rest of Header (32 bits)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                         Data (variable length)                +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Type (8 bits): The Type field identifies the purpose or type of ICMP message being sent. Common types include Echo Request (ping), Destination Unreachable, Time Exceeded, and Redirect, among others.</li> <li>Code (8 bits): The Code field provides additional context or details related to the specific ICMP message type. It works in conjunction with the Type field to refine the message's meaning.</li> <li>Checksum (16 bits): The Checksum field is used to ensure the integrity of the ICMP message and its header during transmission.</li> <li>Rest of Header (32 bits): Depending on the specific ICMP message type, this field may contain additional information, such as an Identifier and Sequence Number for Echo Request and Echo Reply messages.</li> <li>Data (variable length): The Data portion of the ICMP packet contains the payload specific to the ICMP message type. For example, an Echo Request message contains data that will be echoed back in the corresponding Echo Reply.</li> </ol> <p>Because ICMP messages can potentially reveal information about a network's structure, they may be filtered or controlled by security mechanisms in certain network environments to mitigate potential security risks.</p> <p>ICMP (Internet Control Message Protocol) includes several message types, but some are more commonly used than others for network diagnostics and management. Here are descriptions of some of the most commonly used ICMP message types along with their headers:</p> <ol> <li> <p>Echo Request and Echo Reply (Ping):</p> <ul> <li>Type: 8 (Echo Request), 0 (Echo Reply)</li> <li>Description: The Echo Request and Echo Reply messages, often referred to as \"ping,\" are used to test network connectivity and measure round-trip time. An Echo Request is sent to a destination, and the destination responds with an Echo Reply if it's reachable. The ICMP header for both types includes a 32-bit Identifier and a 32-bit Sequence Number to identify the request and response pairs.</li> </ul> </li> <li> <p>Destination Unreachable:</p> <ul> <li>Type: 3</li> <li>Description: Destination Unreachable messages are generated by routers or gateways to inform the sender that a destination host or network is unreachable. The Code field specifies the reason for the unreachability, such as \"Host Unreachable\" or \"Port Unreachable.\" The ICMP header includes a portion of the original packet's IP header and data payload.</li> </ul> </li> <li> <p>Time Exceeded:</p> <ul> <li>Type: 11</li> <li>Description: Time Exceeded messages are sent by routers when they discard a packet due to its Time to Live (TTL) reaching zero. This indicates a network loop or routing issue. The ICMP header includes the original packet's IP header and the first 8 bytes of its data payload.</li> </ul> </li> <li> <p>Redirect Message:</p> <ul> <li>Type: 5</li> <li>Description: Redirect messages are used by routers to inform the sender that there's a better next-hop gateway for a particular destination. The Code field specifies whether the redirection is for the host or the network. The ICMP header includes the original packet's IP header.</li> </ul> </li> <li> <p>Parameter Problem:</p> <ul> <li>Type: 12</li> <li>Description: Parameter Problem messages are generated when a router encounters an issue with the IP header of a received packet. The ICMP header includes a Pointer field that indicates the location of the error within the IP header and 8 bytes of the original IP header.</li> </ul> </li> </ol> <p>These are some of the most commonly used ICMP message types. Each type serves a specific purpose in network diagnostics, troubleshooting, and management. ICMP provides essential feedback for network administrators to identify and resolve issues, improve network performance, and ensure reliable communication. The headers of these ICMP messages include critical information for diagnosing network problems and understanding the context of the messages.</p>"},{"location":"docs/events/builtin/network/net_packet_icmp/#net_packet_icmp","title":"net_packet_icmp","text":"<p>The <code>net_packet_icmp</code> event provides one event for each existing ICMP packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>metadata</code> arguments (common to all networking events) and all <code>ICMP header fields</code>.</p> <p>Example:</p> <pre><code>$ tracee --output json --events net_packet_icmp\n</code></pre> <pre><code>{\"timestamp\":1696270181814910395,\"threadStartTime\":1696270180811296936,\"processorId\":6,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":38217,\"id\":6,\"seq\":2}}]}\n{\"timestamp\":1696270181823805929,\"threadStartTime\":1696270180811296936,\"processorId\":6,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":40265,\"id\":6,\"seq\":2}}]}\n{\"timestamp\":1696270182815992107,\"threadStartTime\":1696270180811296936,\"processorId\":1,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":17732,\"id\":6,\"seq\":3}}]}\n{\"timestamp\":1696270182825223127,\"threadStartTime\":1696270180811296936,\"processorId\":6,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":19780,\"id\":6,\"seq\":3}}]}\n{\"timestamp\":1696270183817423936,\"threadStartTime\":1696270180811296936,\"processorId\":6,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":62525,\"id\":6,\"seq\":4}}]}\n{\"timestamp\":1696270183826709353,\"threadStartTime\":1696270180811296936,\"processorId\":6,\"processId\":1094692,\"cgroupId\":5650,\"threadId\":1094692,\"parentProcessId\":1037836,\"hostProcessId\":1094692,\"hostThreadId\":1094692,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2004\",\"eventName\":\"net_packet_icmp\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":4158935444,\"processEntityId\":4158935444,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.200.50\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":64573,\"id\":6,\"seq\":4}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_icmpv6/","title":"net_packet_icmpv6","text":""},{"location":"docs/events/builtin/network/net_packet_icmpv6/#icmpv6","title":"ICMPv6","text":"<p>The Internet Control Message Protocol version 6 (ICMPv6) is the counterpart of ICMP for IPv6 networks. It serves a similar purpose as ICMP in IPv4 but is adapted to the features and requirements of the IPv6 protocol. ICMPv6 is a fundamental part of the IPv6 suite and plays a crucial role in network diagnostics and control. Here's an overview of the ICMPv6 header and its significance:</p> <p>ICMPv6 Header:</p> <p>The ICMPv6 header is composed of two main parts: the ICMPv6 message type and code fields, followed by the ICMPv6 message body. Here are the primary components of the ICMPv6 header:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type (8 bits)             |    Code (8 bits)               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Checksum (16 bits)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                   Message Body (variable length)              +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Type (8 bits): The Type field specifies the type of ICMPv6 message, such as Router Advertisement, Neighbor Solicitation, Neighbor Advertisement, and others. Each type serves a specific purpose in IPv6 network communication.</li> <li>Code (8 bits): The Code field works in conjunction with the Type field to further categorize and define the specific ICMPv6 message type. It provides additional context or details related to the message.</li> <li>Checksum (16 bits): The Checksum field is used to verify the integrity of the ICMPv6 message and its header during transmission, similar to ICMP in IPv4.</li> <li>Message Body (variable length): The message body contains specific information or data associated with the ICMPv6 message type. The structure and content of the message body vary depending on the message type.</li> </ol> <p>ICMPv6 serves various critical functions in IPv6 networks, including:</p> <ul> <li>Neighbor Discovery: ICMPv6 plays a crucial role in Neighbor Discovery, which is responsible for address resolution (finding a link-layer address given an IPv6 address), determining the reachability of neighboring devices, and duplicate address detection.</li> </ul> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Type (8 bits)         |     Code (8 bits)             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Checksum (16 bits)                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                  Target IPv6 Address (128 bits)               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                  Source Link-Layer Address (variable)         +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ul> <li>Router and Prefix Advertisement: Routers use ICMPv6 to advertise their presence and provide configuration information to hosts on the network, including prefixes, default gateways, and other parameters.</li> <li>Error Reporting: Like ICMP in IPv4, ICMPv6 is used to report errors, such as Destination Unreachable and Time Exceeded, to indicate network issues or unreachable destinations.</li> <li>Redirect: ICMPv6 Redirect messages inform hosts about a more efficient next-hop router for a particular destination.</li> <li>Multicast Listener Discovery: ICMPv6 supports Multicast Listener Discovery, allowing nodes to report their interest in receiving multicast traffic and routers to keep track of active listeners.</li> </ul> <p>ICMPv6 is an integral part of IPv6 network operations and diagnostics. It facilitates efficient and reliable communication in IPv6 networks, enhances network management, and simplifies various network-related tasks compared to its IPv4 counterpart.</p>"},{"location":"docs/events/builtin/network/net_packet_icmpv6/#net_packet_icmpv6","title":"net_packet_icmpv6","text":"<p>The <code>net_packet_icmpv6</code> event provides one event for each existing ICMPv6 packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>metadata</code> arguments (common to all networking events) and all <code>ICMPv6 header fields</code>.</p> <p>Example:</p> <pre><code>tracee --output json --events net_packet_icmpv6\n</code></pre> <pre><code>{\"timestamp\":1696271035058952944,\"threadStartTime\":1696271035053334693,\"processorId\":3,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":25155}}]}\n{\"timestamp\":1696271035059002883,\"threadStartTime\":1696271035053334693,\"processorId\":3,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":24899}}]}\n{\"timestamp\":1696271036064885442,\"threadStartTime\":1696271035053334693,\"processorId\":1,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":32811}}]}\n{\"timestamp\":1696271036064949538,\"threadStartTime\":1696271035053334693,\"processorId\":1,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":32555}}]}\n{\"timestamp\":1696271037078256967,\"threadStartTime\":1696271035053334693,\"processorId\":3,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"sendto\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":3574}}]}\n{\"timestamp\":1696271037078303516,\"threadStartTime\":1696271035053334693,\"processorId\":3,\"processId\":1099372,\"cgroupId\":5650,\"threadId\":1099372,\"parentProcessId\":1037836,\"hostProcessId\":1099372,\"hostThreadId\":1099372,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2005\",\"eventName\":\"net_packet_icmpv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":1216694504,\"processEntityId\":1216694504,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":3318}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_ipv4/","title":"net_packet_ipv4","text":""},{"location":"docs/events/builtin/network/net_packet_ipv4/#ipv4","title":"IPv4","text":"<p>The IPv4 (Internet Protocol version 4) header is a fundamental part of the IP protocol suite and is used for routing packets of data across networks. It contains various fields that provide crucial information about the packet and help in its delivery.</p> <p>Here's a description of the IPv4 header fields:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |   TOS   |         Total Length                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Identification          |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  TTL  |   Protocol  |        Header Checksum                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Source IP Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Destination IP Address                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Version (4 bits): This field indicates the IP version being used, with IPv4 being denoted as '0100' in binary or '4' in decimal.</li> <li>Internet Header Length (IHL, 4 bits): The IHL field specifies the length of the entire IPv4 header in 32-bit words. It is needed because the header can have variable length options, so this field tells where the actual data begins.</li> <li>Type of Service (TOS, 8 bits): This field is used for Quality of Service (QoS) and Differentiated Services Code Point (DSCP) markings. It helps routers prioritize packets based on their importance, such as VoIP traffic getting higher priority than email.</li> <li>Total Length (16 bits): The Total Length field specifies the total size of the IPv4 packet, including both the header and the payload (data). It is measured in bytes and ranges from 20 to 65,535 bytes.</li> <li>Identification (16 bits): This field is primarily used for fragmentation and reassembly of packets. It assigns a unique identifier to each packet, allowing fragmented packets to be reassembled correctly.</li> <li>Flags (3 bits) and Fragment Offset (13 bits): These fields work together for packet fragmentation. The Flags field includes control bits like 'Don't Fragment' (DF) and 'More Fragments' (MF). The Fragment Offset indicates the position of the fragment in the original packet's data.</li> <li>Time to Live (TTL, 8 bits): TTL is a counter that starts with a certain value when the packet is created and is decremented by one each time it passes through a router. If it reaches zero, the packet is discarded to prevent it from circulating indefinitely.</li> <li>Protocol (8 bits): This field specifies the upper-layer protocol to which the packet should be delivered after the IP layer processes it. For example, a value of 6 indicates TCP, while 17 indicates UDP.</li> <li>Header Checksum (16 bits): The checksum field is used for error-checking the header. It ensures the integrity of the header during transmission.</li> <li>Source IP Address (32 bits) and Destination IP Address (32 bits): These fields specify the source and destination IP addresses, respectively, identifying the sender and recipient of the packet.</li> </ol> <p>The IPv4 header is crucial for the proper routing and delivery of packets across the Internet, and these fields play a vital role in ensuring data reaches its intended destination accurately and efficiently.</p>"},{"location":"docs/events/builtin/network/net_packet_ipv4/#net_packet_ipv4","title":"net_packet_ipv4","text":"<p>The <code>net_packet_ipv4</code> event provides one event for each existing IPv4 packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>metadata</code> arguments (common to all networking events) and all <code>IPv4 header fields</code>.</p> <p>Example:</p> <pre><code>tracee --output json --events net_packet_ipv4 --events net_packet_ipv4.args.src=10.10.11.2\n</code></pre> <pre><code>{\"timestamp\":1696271464003181761,\"threadStartTime\":1696271463999022297,\"processorId\":2,\"processId\":1103574,\"cgroupId\":5650,\"threadId\":1103574,\"parentProcessId\":1098248,\"hostProcessId\":1103574,\"hostThreadId\":1103574,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2347021303,\"processEntityId\":2347021303,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":21515,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":48281,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n{\"timestamp\":1696271464003224112,\"threadStartTime\":1696271455012758640,\"processorId\":2,\"processId\":1103525,\"cgroupId\":5650,\"threadId\":1103525,\"parentProcessId\":1037836,\"hostProcessId\":1103525,\"hostThreadId\":1103525,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2580724346,\"processEntityId\":2580724346,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":21515,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":48281,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n{\"timestamp\":1696271464003252321,\"threadStartTime\":1696271455012758640,\"processorId\":2,\"processId\":1103525,\"cgroupId\":5650,\"threadId\":1103525,\"parentProcessId\":1037836,\"hostProcessId\":1103525,\"hostThreadId\":1103525,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2580724346,\"processEntityId\":2580724346,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":0,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":4261,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n{\"timestamp\":1696271464003264004,\"threadStartTime\":1696271463999022297,\"processorId\":2,\"processId\":1103574,\"cgroupId\":5650,\"threadId\":1103574,\"parentProcessId\":1098248,\"hostProcessId\":1103574,\"hostThreadId\":1103574,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2347021303,\"processEntityId\":2347021303,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":0,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":4261,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n{\"timestamp\":1696271464003290303,\"threadStartTime\":1696271463999022297,\"processorId\":2,\"processId\":1103574,\"cgroupId\":5650,\"threadId\":1103574,\"parentProcessId\":1098248,\"hostProcessId\":1103574,\"hostThreadId\":1103574,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2347021303,\"processEntityId\":2347021303,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":21516,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":48288,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n{\"timestamp\":1696271464003301870,\"threadStartTime\":1696271455012758640,\"processorId\":2,\"processId\":1103525,\"cgroupId\":5650,\"threadId\":1103525,\"parentProcessId\":1037836,\"hostProcessId\":1103525,\"hostThreadId\":1103525,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2000\",\"eventName\":\"net_packet_ipv4\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2580724346,\"processEntityId\":2580724346,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.10.11.2\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":21516,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":48288,\"srcIP\":\"10.10.11.2\",\"dstIP\":\"10.10.11.2\"}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_ipv6/","title":"net_packet_ipv6","text":""},{"location":"docs/events/builtin/network/net_packet_ipv6/#ipv6","title":"IPv6","text":"<p>The IPv6 (Internet Protocol version 6) header is an essential component of the IPv6 protocol suite and is responsible for routing packets across networks. Unlike IPv4, IPv6 has a simplified header structure, which improves efficiency and reduces the burden on routers.</p> <p>Here's a description of the main IPv6 header fields:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  Traffic Class  |            Flow Label               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Payload Length         |  Next Header  |   Hop Limit   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                   Source IPv6 Address (128 bits)              +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                 Destination IPv6 Address (128 bits)           +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Version (4 bits): Similar to IPv4, the Version field indicates the IP version being used, with IPv6 being denoted as '0110' in binary or '6' in decimal.</li> <li>Traffic Class (8 bits): The Traffic Class field is used for Quality of Service (QoS) and Differentiated Services Code Point (DSCP) markings, similar to IPv4's Type of Service (TOS) field. It helps in prioritizing packets based on their importance.</li> <li>Flow Label (20 bits): The Flow Label field is designed to help routers and switches identify and handle packets belonging to the same flow or session. It's primarily used for real-time and multimedia traffic to maintain consistency.</li> <li>Payload Length (16 bits): This field specifies the length of the payload (data) in the IPv6 packet, excluding the header. It's measured in bytes.</li> <li>Next Header (8 bits): The Next Header field is equivalent to IPv4's Protocol field. It specifies the type of the next header or extension header that follows the IPv6 header. Common values include ICMPv6 (58), TCP (6), and UDP (17).</li> <li>Hop Limit (8 bits): The Hop Limit field serves the same purpose as IPv4's Time to Live (TTL) field. It is a counter that limits the number of hops (routers) the packet can traverse before being discarded. When it reaches zero, the packet is dropped to prevent looping.</li> <li>Source IP Address (128 bits) and Destination IP Address (128 bits): These fields specify the source and destination IPv6 addresses, respectively. They uniquely identify the sender and recipient of the packet and are 128 bits in length, allowing for a vastly expanded address space compared to IPv4.</li> </ol> <p>The simplified structure of the IPv6 header streamlines packet processing and enhances the efficiency of routing in modern networks.</p> <p>Additionally, IPv6 introduces extension headers for optional features and options, which can be inserted between the main IPv6 header and the payload, providing flexibility and extensibility in handling different packet types and network services.</p>"},{"location":"docs/events/builtin/network/net_packet_ipv6/#net_packet_ipv6","title":"net_packet_ipv6","text":"<p>The <code>net_packet_ipv6</code> event provides one event for each existing IPv6 packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>metadata</code> arguments (common to all networking events) and all <code>IPv6 header fields</code>.</p> <p>Example:</p> <pre><code>tracee --output json --events net_packet_ipv6\n</code></pre> <pre><code>{\"timestamp\":1696271714895915799,\"threadStartTime\":1696271714890936591,\"processorId\":7,\"processId\":1105201,\"cgroupId\":5650,\"threadId\":1105201,\"parentProcessId\":1098248,\"hostProcessId\":1105201,\"hostThreadId\":1105201,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":520127464,\"processEntityId\":520127464,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917134,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::1\",\"dstIP\":\"fd12:3456:789a::2\"}}]}\n{\"timestamp\":1696271714895946394,\"threadStartTime\":1696271709967284585,\"processorId\":7,\"processId\":1105169,\"cgroupId\":5650,\"threadId\":1105169,\"parentProcessId\":1037836,\"hostProcessId\":1105169,\"hostThreadId\":1105169,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2333477623,\"processEntityId\":2333477623,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917134,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::1\",\"dstIP\":\"fd12:3456:789a::2\"}}]}\n{\"timestamp\":1696271714895979201,\"threadStartTime\":1696271714890936591,\"processorId\":7,\"processId\":1105201,\"cgroupId\":5650,\"threadId\":1105201,\"parentProcessId\":1098248,\"hostProcessId\":1105201,\"hostThreadId\":1105201,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":520127464,\"processEntityId\":520127464,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":362266,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::2\",\"dstIP\":\"fd12:3456:789a::1\"}}]}\n{\"timestamp\":1696271714895998772,\"threadStartTime\":1696271714890936591,\"processorId\":7,\"processId\":1105201,\"cgroupId\":5650,\"threadId\":1105201,\"parentProcessId\":1098248,\"hostProcessId\":1105201,\"hostThreadId\":1105201,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":520127464,\"processEntityId\":520127464,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917134,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::1\",\"dstIP\":\"fd12:3456:789a::2\"}}]}\n{\"timestamp\":1696271714896006632,\"threadStartTime\":1696271709967284585,\"processorId\":7,\"processId\":1105169,\"cgroupId\":5650,\"threadId\":1105169,\"parentProcessId\":1037836,\"hostProcessId\":1105169,\"hostThreadId\":1105169,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2333477623,\"processEntityId\":2333477623,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917134,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::1\",\"dstIP\":\"fd12:3456:789a::2\"}}]}\n{\"timestamp\":1696271715216768685,\"threadStartTime\":1696271714890936591,\"processorId\":4,\"processId\":1105201,\"cgroupId\":5650,\"threadId\":1105201,\"parentProcessId\":1098248,\"hostProcessId\":1105201,\"hostThreadId\":1105201,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2001\",\"eventName\":\"net_packet_ipv6\",\"matchedPolicies\":[\"\"],\"argsNum\":3,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":520127464,\"processEntityId\":520127464,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917134,\"length\":34,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd12:3456:789a::1\",\"dstIP\":\"fd12:3456:789a::2\"}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_tcp/","title":"net_packet_tcp","text":""},{"location":"docs/events/builtin/network/net_packet_tcp/#tcp","title":"TCP","text":"<p>The Transmission Control Protocol (TCP) is a core protocol in the Internet protocol suite, responsible for reliable and connection-oriented data communication between devices over a network. The TCP header contains various fields that govern the behavior of the protocol and ensure the reliable delivery of data.</p> <p>Here's a description of the TCP header fields:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Port (16 bits)     |  Destination Port (16 bits)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Sequence Number (32 bits)                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Acknowledgment Number (32 bits)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Data Offset |  Reserved   |  Control Flags (6 bits)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Window Size (16 bits)    |  Checksum (16 bits)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Urgent Pointer (16 bits)   |                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|              Options (variable length, if any)                |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Source Port (16 bits) and Destination Port (16 bits): These fields specify the source and destination ports, respectively, allowing the receiving device to determine which application or service should receive the data. Port numbers range from 0 to 65535, with well-known ports (e.g., port 80 for HTTP) and ephemeral ports for temporary connections.</li> <li>Sequence Number (32 bits): The Sequence Number field plays a vital role in ensuring the ordered and reliable delivery of data. It assigns a unique sequence number to each segment sent, enabling the receiver to reassemble segments in the correct order.</li> <li>Acknowledgment Number (32 bits): In acknowledgment-based communication, this field indicates the next sequence number the sender expects to receive from the other end. It acknowledges receipt of all data up to that number, helping to confirm successful delivery.</li> <li>Data Offset (4 bits): The Data Offset field specifies the length of the TCP header in 32-bit words. This value is necessary because TCP allows for variable-length options in the header, so the receiver needs to know where the actual data begins.</li> <li>Reserved (6 bits): These bits are reserved for future use and should be set to zero.</li> <li>Control Flags (6 bits): TCP uses a variety of control flags to manage the connection. Key flags include:<ul> <li><code>URG</code> (Urgent Pointer): Indicates that urgent data follows in the segment.</li> <li><code>ACK</code> (Acknowledgment): Acknowledges the receipt of data.</li> <li><code>PSH</code> (Push Function): Urges the receiver to push data to the application immediately.</li> <li><code>RST</code> (Reset Connection): Resets the connection in response to an error.</li> <li><code>SYN</code> (Synchronize Sequence Numbers): Initiates a connection.</li> <li><code>FIN</code> (Finish): Indicates the end of data transmission.</li> </ul> </li> <li>Window Size (16 bits): The Window Size field specifies the size of the sender's receive window, indicating the amount of data it can accept without overflowing its buffer. It helps in flow control and prevents congestion.</li> <li>Checksum (16 bits): The Checksum field is used for error detection, ensuring the integrity of the TCP header and data during transmission.</li> <li>Urgent Pointer (16 bits): This field is only significant if the <code>URG</code> flag is set. It points to the urgent data in the segment.</li> <li>Options (variable length): The Options field allows for various TCP options, such as Maximum Segment Size (MSS), Timestamps, and Window Scale, among others, to be included in the header.</li> </ol> <p>The TCP header, with its rich set of fields, provides the foundation for reliable and orderly data transfer in network communication. By managing sequence numbers, acknowledgments, flow control, and error checking, TCP ensures that data reaches its destination accurately and efficiently, even in complex and congested network environments.</p>"},{"location":"docs/events/builtin/network/net_packet_tcp/#net_packet_tcp","title":"net_packet_tcp","text":"<p>The <code>net_packet_tcp</code> event provides one event for each existing TCP packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code>, <code>metadata</code> arguments and all <code>TCP header fields</code>.</p> <p>Example:</p> <pre><code>tracee --output json --events net_packet_tcp --events net_packet_tcp.args.src=fd12:3456:789a::2\n</code></pre> <pre><code>{\"timestamp\":1696272024347781212,\"threadStartTime\":1696271974944102178,\"processorId\":7,\"processId\":1107258,\"cgroupId\":5650,\"threadId\":1107258,\"parentProcessId\":1098248,\"hostProcessId\":1107258,\"hostThreadId\":1107258,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2781367766,\"processEntityId\":2781367766,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":55013},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":55013,\"seq\":677659081,\"ack\":0,\"dataOffset\":5,\"FIN\":0,\"SYN\":0,\"RST\":1,\"PSH\":0,\"ACK\":0,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":0,\"checksum\":21540,\"urgent\":0}}]}\n{\"timestamp\":1696272027374076813,\"threadStartTime\":1696272027372569306,\"processorId\":4,\"processId\":1107603,\"cgroupId\":5650,\"threadId\":1107603,\"parentProcessId\":1098248,\"hostProcessId\":1107603,\"hostThreadId\":1107603,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2571859936,\"processEntityId\":2571859936,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":49963},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":49963,\"seq\":795748968,\"ack\":922008806,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":65464,\"checksum\":21560,\"urgent\":0}}]}\n{\"timestamp\":1696272027906687804,\"threadStartTime\":1696272021882621094,\"processorId\":0,\"processId\":1107548,\"cgroupId\":5650,\"threadId\":1107548,\"parentProcessId\":1037836,\"hostProcessId\":1107548,\"hostThreadId\":1107548,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"socket\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":341009752,\"processEntityId\":341009752,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":49963},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":49963,\"seq\":795748969,\"ack\":922008809,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":512,\"checksum\":21552,\"urgent\":0}}]}\n{\"timestamp\":1696272027906697145,\"threadStartTime\":1696272027372569306,\"processorId\":0,\"processId\":1107603,\"cgroupId\":5650,\"threadId\":1107603,\"parentProcessId\":1098248,\"hostProcessId\":1107603,\"hostThreadId\":1107603,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2571859936,\"processEntityId\":2571859936,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":49963},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":49963,\"seq\":795748969,\"ack\":922008809,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":512,\"checksum\":21552,\"urgent\":0}}]}\n{\"timestamp\":1696272028900730092,\"threadStartTime\":1696272021882621094,\"processorId\":0,\"processId\":1107548,\"cgroupId\":5650,\"threadId\":1107548,\"parentProcessId\":1037836,\"hostProcessId\":1107548,\"hostThreadId\":1107548,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":341009752,\"processEntityId\":341009752,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":49963},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":49963,\"seq\":795748969,\"ack\":922008809,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":512,\"checksum\":21556,\"urgent\":0}}]}\n{\"timestamp\":1696272028900769370,\"threadStartTime\":1696272027372569306,\"processorId\":0,\"processId\":1107603,\"cgroupId\":5650,\"threadId\":1107603,\"parentProcessId\":1098248,\"hostProcessId\":1107603,\"hostThreadId\":1107603,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2002\",\"eventName\":\"net_packet_tcp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2571859936,\"processEntityId\":2571859936,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":49963},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8080,\"dstPort\":49963,\"seq\":795748969,\"ack\":922008809,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":512,\"checksum\":21556,\"urgent\":0}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/net_packet_udp/","title":"net_packet_udp","text":""},{"location":"docs/events/builtin/network/net_packet_udp/#udp","title":"UDP","text":"<p>The User Datagram Protocol (UDP) is one of the core transport layer protocols in the Internet protocol suite (TCP/IP). Unlike TCP, UDP is a connectionless and minimalistic protocol designed for simplicity and speed. It offers a best-effort delivery service, making it suitable for applications where low overhead and minimal delay are more critical than guaranteed data delivery. UDP packets, often referred to as datagrams, consist of a relatively simple header and a data payload.</p> <p>Here's a description of the main UDP header fields:</p> <pre><code> 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Port (16 bits)     |  Destination Port (16 bits)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Length (16 bits)     |           Checksum (16 bits) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre> <ol> <li>Source Port (16 bits): This field identifies the source port number, indicating the sender's endpoint for communication.</li> <li>Destination Port (16 bits): The Destination Port field specifies the port number of the receiving endpoint.</li> <li>Length (16 bits): The Length field indicates the length of the UDP header and the data payload. It measures the total size of the UDP packet in bytes.</li> <li>Checksum (16 bits): The Checksum field is used for error detection. It provides a simple checksum value that can be used to verify the integrity of the UDP header and data payload.</li> </ol>"},{"location":"docs/events/builtin/network/net_packet_udp/#net_packet_udp","title":"net_packet_udp","text":"<p>The <code>net_packet_udp</code> event provides one event for each existing UDP packet that reaches or leaves one of the processes being traced (or even \"all OS processes for the default run\"). As arguments for this event you will find: <code>src</code>, <code>dst</code>, <code>src_port</code>, <code>dst_port</code>, <code>metadata</code> arguments and all <code>UDP header fields</code>.</p> <p>Example:</p> <pre><code>tracee --output json --events net_packet_udp --events net_packet_udp.args.src=fd12:3456:789a::2\n</code></pre> <pre><code>{\"timestamp\":1696272374106561233,\"threadStartTime\":1696272081675489950,\"processorId\":1,\"processId\":1108786,\"cgroupId\":5650,\"threadId\":1108786,\"parentProcessId\":1037836,\"hostProcessId\":1108786,\"hostThreadId\":1108786,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2003\",\"eventName\":\"net_packet_udp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3953446441,\"processEntityId\":3953446441,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":37294},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8080,\"dstPort\":37294,\"length\":12,\"checksum\":21543}}]}\n{\"timestamp\":1696272377447546123,\"threadStartTime\":1696272081675489950,\"processorId\":1,\"processId\":1108786,\"cgroupId\":5650,\"threadId\":1108786,\"parentProcessId\":1037836,\"hostProcessId\":1108786,\"hostThreadId\":1108786,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2003\",\"eventName\":\"net_packet_udp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3953446441,\"processEntityId\":3953446441,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":37294},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8080,\"dstPort\":37294,\"length\":12,\"checksum\":21543}}]}\n{\"timestamp\":1696272377447582525,\"threadStartTime\":1696272102435727490,\"processorId\":1,\"processId\":1108865,\"cgroupId\":5650,\"threadId\":1108865,\"parentProcessId\":1098248,\"hostProcessId\":1108865,\"hostThreadId\":1108865,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2003\",\"eventName\":\"net_packet_udp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2138584357,\"processEntityId\":2138584357,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":37294},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8080,\"dstPort\":37294,\"length\":12,\"checksum\":21543}}]}\n{\"timestamp\":1696272386589678156,\"threadStartTime\":1696272081675489950,\"processorId\":6,\"processId\":1108786,\"cgroupId\":5650,\"threadId\":1108786,\"parentProcessId\":1037836,\"hostProcessId\":1108786,\"hostThreadId\":1108786,\"hostParentProcessId\":1037836,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2003\",\"eventName\":\"net_packet_udp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"write\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":3953446441,\"processEntityId\":3953446441,\"parentEntityId\":2142180145,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":37294},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8080,\"dstPort\":37294,\"length\":10,\"checksum\":21541}}]}\n{\"timestamp\":1696272386589710441,\"threadStartTime\":1696272102435727490,\"processorId\":6,\"processId\":1108865,\"cgroupId\":5650,\"threadId\":1108865,\"parentProcessId\":1098248,\"hostProcessId\":1108865,\"hostThreadId\":1108865,\"hostParentProcessId\":1098248,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"executable\":{\"path\":\"\"},\"hostName\":\"rugged\",\"containerId\":\"\",\"container\":{},\"kubernetes\":{},\"eventId\":\"2003\",\"eventName\":\"net_packet_udp\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"threadEntityId\":2138584357,\"processEntityId\":2138584357,\"parentEntityId\":129643807,\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd12:3456:789a::1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":8080},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":37294},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8080,\"dstPort\":37294,\"length\":10,\"checksum\":21541}}]}\n</code></pre>"},{"location":"docs/events/builtin/signatures/","title":"Security Events","text":""},{"location":"docs/events/builtin/signatures/#understanding-signatures-in-tracee","title":"Understanding Signatures in Tracee","text":"<p>In Tracee, a signature is a set of criteria designed to detect specific system activities based on events such as syscalls, network interactions, and LSM hook occurrences. When these foundational system events align with the conditions set by a signature, Tracee generates a corresponding \"security event.\" This process enables Tracee to actively monitor and report potential security concerns arising from observed system interactions.</p>"},{"location":"docs/events/builtin/signatures/#functionality-and-scope-of-signatures","title":"Functionality and Scope of Signatures","text":"<p>The signatures documented herein focus on key system operations. For instance, one signature identifies attempts to manipulate the syscall tables or the <code>/proc</code> filesystem, operations that are indicative of rootkit behaviors. Another detects the dynamic introduction of new executables into the system, flagging potential security issues. Upon a match, these signatures prompt Tracee to produce a security event, capturing the specifics of the underlying event and any associated implications.</p>"},{"location":"docs/events/builtin/signatures/#the-role-of-security-events-in-tracee","title":"The Role of Security Events in Tracee","text":"<p>Security events play a critical role in maintaining system integrity. They provide an analytical layer, translating raw events like syscalls into actionable insights about potential threats or anomalies. With the power of eBPF, Tracee efficiently monitors system activities in real-time, generating security events that equip users with the information they need to assess and respond to the state of their digital environments.</p>"},{"location":"docs/events/builtin/signatures/#be-prepared","title":"Be Prepared!","text":"<p>For optimal utilization of Tracee and effective response to potential threats, we strongly recommend readers to meticulously review each security event documentation page.</p> <p>A good understanding of what each signature detects will empower users to make informed decisions and take appropriate actions when a security event arises. Being well-versed in the nuances of each signature ensures that you're not just alerted to risks, but also equipped to address them effectively.</p>"},{"location":"docs/events/builtin/signatures/#list-of-default-security-events","title":"List of Default Security Events","text":"Name of Signature Description Anti-Debugging Technique Detects anti-debugging techniques. ASLR Inspection Detects ASLR inspections. Cgroups notify_on_release File Modification Monitors <code>notify_on_release</code> file changes in cgroups. Cgroups Release Agent File Modification Detects changes to the cgroup release_agent. Core Dumps Config File Modification Monitors core dump configuration alterations. Default Dynamic Loader Modification Tracks changes to the default binary loader. Container Device Mount Detects unauthorized container device mounts. Docker Socket Abuse Flags potential Docker socket misuse. Dropped Executables Detects runtime-dropped executables. Dynamic Code Loading Monitors dynamic code loading events. Fileless Execution Flags fileless execution techniques. Hidden Executable File Creation Detects creation of hidden executable files. Illegitimate Shell Flags unauthorized or unexpected shell executions. Kernel Module Loading Monitors kernel module load events. Kubernetes API Server Connection Detects connections to the Kubernetes API server. Kubernetes TLS Certificate Theft Flags potential theft of Kubernetes certificates. LD_PRELOAD Code Injection Monitors LD_PRELOAD injection attempts. File Operations Hooking on Proc Filesystem Detects hooks on file operations in /proc. Kcore Memory File Read Monitors reads of /proc/kcore. Process Memory Access Flags unauthorized /proc/mem access. Procfs Mem Code Injection Detects code injections via /proc/mem. Process VM Write Code Injection Monitors injections via process_vm_writev. Ptrace Code Injection Detects ptrace-facilitated code injections. RCD Modification Monitors changes to the remote control daemon. Sched Debug Reconnaissance Flags /proc/sched_debug reconnaissance. Scheduled Tasks Modification Tracks modifications to scheduled tasks. Process Standard Input/Output over Socket Detects IO redirection over sockets. Sudoers File Modification Monitors alterations to the sudoers file. Syscall Table Hooking Detects syscall table hook attempts. System Request Key Configuration Modification Monitors system request key configuration changes."},{"location":"docs/events/builtin/signatures/anti_debugging/","title":"Anti-Debugging Technique Detection","text":""},{"location":"docs/events/builtin/signatures/anti_debugging/#intro","title":"Intro","text":"<p>The <code>antiDebugging</code> signature is designed to detect processes that employ anti-debugging techniques to thwart or block the efforts of debuggers. This tactic can be a significant indicator of software or malware attempting to conceal its operations, avoid analysis, or thwart reverse engineering efforts.</p>"},{"location":"docs/events/builtin/signatures/anti_debugging/#description","title":"Description","text":"<p>Debugging is a standard and indispensable technique for developers and security researchers alike. It allows for the examination of software in operation, making it possible to identify issues, vulnerabilities, or understand the software's behavior. Some malicious software or even certain commercial applications incorporate anti-debugging mechanisms to deter analysis.</p> <p>The <code>antiDebugging</code> signature closely monitors for the usage of the <code>ptrace</code> system call with the <code>PTRACE_TRACEME</code> request. The <code>ptrace</code> system call allows a process to control another, enabling debugging. When a process invokes <code>ptrace</code> with <code>PTRACE_TRACEME</code>, it's essentially asking to be traced by its parent, which can be a technique to determine if it's currently being debugged.</p>"},{"location":"docs/events/builtin/signatures/anti_debugging/#purpose","title":"Purpose","text":"<p>The primary goal of this signature is to identify and raise alerts about processes that utilize the <code>PTRACE_TRACEME</code> request with <code>ptrace</code>. Detection of such activity can signify attempts by software or malware to engage in defense evasion by deploying execution guardrails against debugging.</p>"},{"location":"docs/events/builtin/signatures/anti_debugging/#metadata","title":"Metadata","text":"<ul> <li>Name: Anti-Debugging</li> <li>Description: The signature identifies processes that employ the <code>PTRACE_TRACEME</code> request with <code>ptrace</code> as an anti-debugging technique. This behavior can indicate a program's attempt to evade analysis or thwart reverse engineering.</li> <li>Tags: linux, container</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>MITRE ATT&amp;CK: Defense Evasion: Execution Guardrails</li> </ul>"},{"location":"docs/events/builtin/signatures/anti_debugging/#findings","title":"Findings","text":"<p>Upon detection of an anti-debugging effort, the signature returns a <code>Finding</code> data structure, which encompasses:</p> <ul> <li>SigMetadata: Metadata that offers comprehensive details about the threat according to the signature's specifications.</li> <li>Event: A detailed account of the specific event that triggered the signature's alert system.</li> <li>Data: Contains the specific <code>ptrace</code> request used, which, in this context, would be \"PTRACE_TRACEME\".</li> </ul>"},{"location":"docs/events/builtin/signatures/anti_debugging/#events-used","title":"Events Used","text":"<p>The signature's operations hinge primarily on the following event:</p> <ul> <li><code>ptrace</code>: Activated when the <code>ptrace</code> system call is used. The signature specifically examines the request type to determine if there's an invocation of <code>PTRACE_TRACEME</code>, indicating an anti-debugging attempt.</li> </ul>"},{"location":"docs/events/builtin/signatures/aslr_inspection/","title":"ASLR inspection detected","text":""},{"location":"docs/events/builtin/signatures/aslr_inspection/#intro","title":"Intro","text":"<p>The <code>AslrInspection</code> signature detects instances where the ASLR (address space layout randomization) configuration is being read.</p>"},{"location":"docs/events/builtin/signatures/aslr_inspection/#description","title":"Description","text":"<p>ASLR is a vital security mechanism used by Linux operating systems to randomize the memory locations used by processes, making it more difficult to exploit vulnerabilities that rely on predictable memory addresses.</p> <p>However, adversaries may seek to inspect or even disable ASLR in their attempts to exploit vulnerabilities. The signature specifically tracks attempts to open and read the ASLR configuration from its standard location (<code>/proc/sys/kernel/randomize_va_space</code>).</p>"},{"location":"docs/events/builtin/signatures/aslr_inspection/#purpose","title":"Purpose","text":"<p>By alerting on instances where the ASLR configuration is being inspected, the system can identify potential preparatory actions by adversaries who might be gearing up for more direct attacks or exploit attempts. Disabling or altering ASLR can be a crucial step in a larger attack plan.</p>"},{"location":"docs/events/builtin/signatures/aslr_inspection/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-109</li> <li>Version: 1</li> <li>Name: ASLR inspection detected</li> <li>EventName: aslr_inspection</li> <li>Description: Monitors for attempts to inspect the ASLR configuration on a Linux system, a potential precursor to privilege escalation attacks.</li> <li>Properties:</li> <li>Severity: 0</li> <li>Category: privilege-escalation</li> <li>Technique: Exploitation for Privilege Escalation</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--b21c3b2d-02e6-45b1-980b-e69051040839</li> <li>external_id: T1068</li> </ul>"},{"location":"docs/events/builtin/signatures/aslr_inspection/#findings","title":"Findings","text":"<p>Upon detection, the signature returns a <code>Finding</code> data structure, but it does not contain any specific data fields related to the event, other than the metadata of the event itself.</p>"},{"location":"docs/events/builtin/signatures/aslr_inspection/#events-used","title":"Events Used","text":"<p>The signature is primarily triggered by the following event:</p> <ol> <li><code>security_file_open</code> - Indicates when a file is opened. The signature checks if the file being opened matches the path of the ASLR configuration and if it's being read.</li> </ol>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/","title":"Cgroups notify_on_release file modification","text":""},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#intro","title":"Intro","text":"<p>The <code>CgroupNotifyOnReleaseModification</code> signature identifies modifications to the <code>notify_on_release</code> file within Cgroups. Unauthorized or unintended changes to this file may suggest attempts to escape from a container or to exploit the Cgroups feature for malicious purposes.</p>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#description","title":"Description","text":"<p>Cgroups (Control Groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, etc.) of a collection of processes. The <code>notify_on_release</code> file within Cgroups specifies if a notification should be sent when the resources of the Cgroup are no longer in use.</p> <p>Manipulating this file could allow adversaries to be notified when a containerized process completes, potentially giving them an opportunity to exploit the released resources. This may enable unauthorized actions, like container escape or privilege escalation.</p>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#purpose","title":"Purpose","text":"<p>The main goal of this signature is to detect and raise alerts on unauthorized or suspicious modifications to the <code>notify_on_release</code> file within Cgroups. By monitoring such changes, this signature aids in the early detection and prevention of potential container escape attempts or other malicious activities leveraging Cgroup mechanisms.</p>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-106</li> <li>Version: 1</li> <li>Name: Cgroups notify_on_release file modification</li> <li>EventName: cgroup_notify_on_release</li> <li>Description: Monitors for attempts to modify the <code>notify_on_release</code> file in Cgroups. Unauthorized changes might hint at adversarial efforts to exploit Cgroup functionalities, like trying to escape from containers.</li> <li>Properties:</li> <li>Severity: 3</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#findings","title":"Findings","text":"<p>On detection of unauthorized or suspicious activities related to the <code>notify_on_release</code> file, the signature produces a <code>Finding</code> which contains details about the event and the associated threat metadata.</p>"},{"location":"docs/events/builtin/signatures/cgroup_notify_on_release_modification/#events-used","title":"Events Used","text":"<p>The signature primarily listens to the <code>security_file_open</code> event, especially from the <code>container</code> origin. This event provides insights into attempts to access or modify files, and in this context, specifically watches for interactions with the <code>notify_on_release</code> file in Cgroups.</p>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/","title":"Cgroups Release Agent File Modification Detection","text":""},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#intro","title":"Intro","text":"<p>The <code>CgroupReleaseAgentModification</code> signature detects modifications to the Cgroup release agent file, a critical file related to the resource management of process groups in Linux.</p>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#description","title":"Description","text":"<p>Cgroups (short for \"control groups\") is a Linux kernel feature that provides a mechanism for managing and monitoring system resources like CPU, memory, disk I/O, and network usage by grouping a set of tasks (like processes and threads).</p> <p>One of its key features is the <code>release_agent</code> which specifies a script or command to be run whenever a cgroup becomes empty. Any unauthorized or malicious modification to this file could be indicative of adversarial intent.</p> <p>This signature specifically identifies attempts to modify the <code>release_agent</code> file. Unauthorized changes to this file could be employed by adversaries in techniques aiming for container escapes or other privilege escalation schemes.</p>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#purpose","title":"Purpose","text":"<p>The main purpose of this signature is to detect and raise alerts for unauthorized modifications to the <code>release_agent</code> file of Cgroups. Since the <code>release_agent</code> can be exploited by attackers to run arbitrary commands when cgroups are empty, monitoring its changes is pivotal for ensuring system security and container boundaries.</p>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1010</li> <li>Version: 1</li> <li>Name: Cgroups release agent file modification</li> <li>EventName: cgroup_release_agent</li> <li>Description: The signature monitors the modification of the Cgroup release agent file. Unauthorized changes to this file may be indicative of an adversary trying to leverage Cgroup features for privilege escalation or container escaping techniques.</li> <li>Properties:</li> <li>Severity: 3 (Moderate threat level)</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#findings","title":"Findings","text":"<p>Upon detecting a potential threat, the signature returns a <code>Finding</code> data structure, comprising:</p> <ul> <li>SigMetadata: Metadata about the threat based on the signature.</li> <li>Event: Specifics of the event that instigated the signature to activate.</li> <li>Data: Presently set to <code>nil</code>, signifying that no supplementary data is returned with this structure.</li> </ul>"},{"location":"docs/events/builtin/signatures/cgroup_release_agent_modification/#events-used","title":"Events Used","text":"<p>The signature is contingent on the following events:</p> <ul> <li><code>security_file_open</code>: Triggers when a file is accessed. The signature inspects the accessed file's pathname and flags to ascertain if the <code>release_agent</code> file is being modified.</li> <li><code>security_inode_rename</code>: Activates when there's an inode rename event. This is employed to identify if the <code>release_agent</code> is being renamed, which could be a tactic to hide malicious modifications.</li> </ul>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/","title":"Core dumps configuration file modification detection","text":""},{"location":"docs/events/builtin/signatures/core_pattern_modification/#intro","title":"Intro","text":"<p>The <code>CorePatternModification</code> signature detects unauthorized changes to the core dump configuration file (<code>core_pattern</code>), an integral component within Linux systems.</p>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/#description","title":"Description","text":"<p>In Linux, the core dump mechanism captures the memory content of a crashed program, typically written to disk. This aids in debugging and analyzing the cause of the crash. The location and format of these core dumps are defined by the <code>core_pattern</code> configuration file located within <code>/proc/sys/kernel/</code>.</p> <p>Any unauthorized modification to the <code>core_pattern</code> could be indicative of an adversary attempting to exploit kernel's core dump capabilities, particularly for container escape maneuvers. Such techniques can allow attackers to run arbitrary commands when a program crashes, and as such, any changes to the <code>core_pattern</code> should be monitored closely.</p> <p>The <code>CorePatternModification</code> signature specifically identifies unauthorized attempts to modify this configuration file.</p>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/#purpose","title":"Purpose","text":"<p>The primary intent of this signature is to identify and raise alerts for unauthorized modifications to the <code>core_pattern</code> file. By keeping an eye on alterations to this file, the system can preemptively counter attempts at exploiting the core dump functionality, especially for container escapes or other privilege escalation tactics.</p>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1011</li> <li>Version: 1</li> <li>Name: Core dumps configuration file modification detected</li> <li>EventName: core_pattern_modification</li> <li>Description: The signature observes any alterations to the core dump configuration file (<code>core_pattern</code>). Any unauthorized change can be a precursor to an attacker leveraging kernel's core dump mechanisms for nefarious ends, such as container escapes.</li> <li>Properties:</li> <li>Severity: 3 (Moderate threat level)</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/#findings","title":"Findings","text":"<p>Upon detecting a potential threat, the signature returns a <code>Finding</code> data structure, which includes:</p> <ul> <li>SigMetadata: Metadata that offers insights about the threat based on the signature.</li> <li>Event: Specific details of the event that prompted the signature's activation.</li> <li>Data: Currently set to <code>nil</code>, indicating that there isn't any additional data linked with this structure.</li> </ul>"},{"location":"docs/events/builtin/signatures/core_pattern_modification/#events-used","title":"Events Used","text":"<p>This signature is contingent on the following event:</p> <ul> <li><code>security_file_open</code>: This event is triggered when a file is accessed. The signature analyzes the accessed file's pathname and associated flags to discern if the <code>core_pattern</code> file undergoes any modification.</li> </ul>"},{"location":"docs/events/builtin/signatures/default_loader_modification/","title":"Default dynamic loader modification detection","text":""},{"location":"docs/events/builtin/signatures/default_loader_modification/#intro","title":"Intro","text":"<p>The <code>DefaultLoaderModification</code> signature detects unauthorized or unexpected changes to the default dynamic loader on a Linux system.</p> <p>Dynamic loaders play a crucial role in the execution of applications by loading necessary shared libraries before the main program runs. Unauthorized modifications to this component could allow an attacker to manipulate the behavior of almost every application on the system.</p>"},{"location":"docs/events/builtin/signatures/default_loader_modification/#description","title":"Description","text":"<p>Dynamic loaders, which are located in directories like <code>/lib</code> and <code>/usr/lib</code>, are responsible for loading shared libraries for dynamically linked applications. By manipulating the dynamic loader, an attacker could control or alter the way an application behaves, making it a potent attack vector.</p> <p>Such modifications could be used to achieve persistence, bypass security controls, or intercept sensitive information. Recognizing changes to these loaders is, therefore, of paramount importance to maintain system integrity.</p>"},{"location":"docs/events/builtin/signatures/default_loader_modification/#purpose","title":"Purpose","text":"<p>This signature focuses on identifying unauthorized modifications to the default dynamic loader. Monitoring such changes helps in the early detection of potential system compromises or attempts by adversaries to inject malicious code into application execution contexts.</p>"},{"location":"docs/events/builtin/signatures/default_loader_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1012</li> <li>Version: 1</li> <li>Name: Default dynamic loader modification detected</li> <li>EventName: default_loader_mod</li> <li>Description: Monitors for modifications to the default dynamic loader, which is essential for the execution of dynamically linked applications. Any unexpected changes could signify an attacker's attempt to control or manipulate application behavior, bypass security mechanisms, or achieve persistence on the system.</li> <li>Properties:</li> <li>Severity: 3</li> <li>Category: defense-evasion</li> <li>Technique: Hijack Execution Flow</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--aedfca76-3b30-4866-b2aa-0f1d7fd1e4b6</li> <li>external_id: T1574</li> </ul>"},{"location":"docs/events/builtin/signatures/default_loader_modification/#findings","title":"Findings","text":"<p>When a potential modification to the default dynamic loader is identified, a <code>Finding</code> is generated, which contains detailed information about the event and associated threat metadata.</p>"},{"location":"docs/events/builtin/signatures/default_loader_modification/#events-used","title":"Events Used","text":"<p>The signature is mainly interested in two events:</p> <ul> <li> <p><code>security_file_open</code>: This event is triggered when a file is opened. This signature particularly focuses on instances where the file is opened with write permissions.</p> </li> <li> <p><code>security_inode_rename</code>: This event indicates the renaming of a file or directory, which could be an indicator of an attacker trying to replace the original loader with a malicious one.</p> </li> </ul> <p>If the path associated with these events matches the pattern of a default dynamic loader, an alert is raised.</p>"},{"location":"docs/events/builtin/signatures/disk_mount/","title":"Container Device Mount Detection","text":""},{"location":"docs/events/builtin/signatures/disk_mount/#intro","title":"Intro","text":"<p>The <code>DiskMount</code> signature aims to identify instances when a container mounts a host device filesystem. Such actions, while sometimes valid, can be indicative of malicious activity, as they might be exploited by attackers attempting to break out of the container and gain unauthorized access to the host machine.</p>"},{"location":"docs/events/builtin/signatures/disk_mount/#description","title":"Description","text":"<p>Containers are isolated environments, and attempts to mount the host device filesystem within them can be suspicious.</p> <p>The <code>DiskMount</code> signature observes the <code>security_sb_mount</code> event, particularly in a container context, to detect and evaluate such operations. If the mounted device pertains to the host, as indicated by its presence in the <code>/dev/</code> directory, an alert is generated.</p>"},{"location":"docs/events/builtin/signatures/disk_mount/#purpose","title":"Purpose","text":"<p>The primary objective of the <code>DiskMount</code> signature is to deliver real-time alerts for potential malicious activity involving the mounting of host device filesystems in containers. This is essential as container escape techniques could grant attackers enhanced privileges, putting the security and integrity of the host system at risk.</p>"},{"location":"docs/events/builtin/signatures/disk_mount/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1014</li> <li>Version: 1</li> <li>Name: Container device mount detected</li> <li>EventName: disk_mount</li> <li>Description: Monitors containers for mounting host device filesystems, potentially indicative of malicious attempts at container escape.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/disk_mount/#findings","title":"Findings","text":"<p>Upon the identification of a potentially harmful device mount operation:</p> <ul> <li>SigMetadata: Provides a detailed view of the threat according to the signature's specifications.</li> <li>Event: Captures a comprehensive log of the specific occurrence that instigated the alert.</li> <li>Data: Currently marked as <code>nil</code>, suggesting no supplementary data is paired with the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/disk_mount/#events-used","title":"Events Used","text":"<p>The signature exclusively tracks:</p> <ul> <li><code>security_sb_mount</code>: Triggered during a filesystem mount operation.</li> </ul>"},{"location":"docs/events/builtin/signatures/docker_abuse/","title":"Docker socket abuse detected","text":""},{"location":"docs/events/builtin/signatures/docker_abuse/#intro","title":"Intro","text":"<p>The <code>DockerAbuse</code> signature is designed to identify malicious activities targeting the Docker UNIX socket, specifically when this activity originates from within a container.</p> <p>This UNIX socket serves as the primary entry point for the Docker API. Malicious actions against this socket can be indicative of an attempt to compromise the host or the wider Docker environment.</p>"},{"location":"docs/events/builtin/signatures/docker_abuse/#description","title":"Description","text":"<p>Docker socket (<code>docker.sock</code>) represents a significant security boundary. When this socket is accessed from within a container, it provides a potential pathway for an attacker to execute commands directly on the host or on other containers. This could lead to a wide range of malicious activities such as container escape, launching of new containers, or even compromising the host system itself.</p>"},{"location":"docs/events/builtin/signatures/docker_abuse/#purpose","title":"Purpose","text":"<p>This signature aims to protect Docker environments by detecting when the UNIX socket is being abused. It is specifically tailored to identify the unauthorized access or malicious activities against the Docker socket from within a containerized environment.</p>"},{"location":"docs/events/builtin/signatures/docker_abuse/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1019</li> <li>Version: 1</li> <li>Name: Docker socket abuse detected</li> <li>EventName: docker_abuse</li> <li>Description: Monitors for any suspicious activities targeting the Docker UNIX socket from within a container, which may indicate an attempt to compromise the Docker environment or the host system.</li> <li>Properties:</li> <li>Severity: 2</li> <li>Category: privilege-escalation</li> <li>Technique: Exploitation for Privilege Escalation</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--b21c3b2d-02e6-45b1-980b-e69051040839</li> <li>external_id: T1068</li> </ul>"},{"location":"docs/events/builtin/signatures/docker_abuse/#findings","title":"Findings","text":"<p>Upon detection of any malicious or suspicious activity, the signature returns a <code>Finding</code> structure. The findings don't carry specific data fields related to the event, apart from the metadata of the event itself.</p>"},{"location":"docs/events/builtin/signatures/docker_abuse/#events-used","title":"Events Used","text":"<p>This signature primarily responds to two event types:</p> <ol> <li><code>security_file_open</code> - Indicative of a file being opened. This event is checked for access to the <code>docker.sock</code> file from within a container.</li> <li><code>security_socket_connect</code> - Indicates a connection attempt to a UNIX socket. This event identifies if there's a connection to the Docker UNIX socket from within a container.</li> </ol> <p>By monitoring these events, the signature ensures comprehensive coverage against potential Docker socket abuse.</p>"},{"location":"docs/events/builtin/signatures/dropped_executable/","title":"Detection of Dropped Executables","text":""},{"location":"docs/events/builtin/signatures/dropped_executable/#introduction","title":"Introduction","text":"<p>The <code>DroppedExecutable</code> signature is designed to identify instances where a new executable file is introduced into the system during runtime. This type of activity can often be a significant security concern, especially in containerized environments where images are generally built with all necessary binaries included. An unexpected or \"dropped\" binary can indicate an intrusion or malicious activity within the container.</p>"},{"location":"docs/events/builtin/signatures/dropped_executable/#description","title":"Description","text":"<p>When running containers, a primary security principle is the immutability of container images. This means that once a container image is built, it should have all the binaries and libraries it needs to function. Any deviation from this, such as dropping or introducing new executables during runtime, is often a sign of malicious intent or an indication that the container's integrity has been compromised.</p> <p>The <code>DroppedExecutable</code> signature vigilantly monitors for such anomalies. If it detects that a new executable has been introduced into the runtime environment, it triggers an alert.</p>"},{"location":"docs/events/builtin/signatures/dropped_executable/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1022</li> <li>Version: 1</li> <li>Name: New executable dropped</li> <li>EventName: dropped_executable</li> <li>Description: Focuses on identifying instances where new executable files appear during the container's runtime. The presence of such unexpected binaries often suggests potential intrusions or that a threat actor has compromised the container.</li> <li>Properties:</li> <li>Severity: 2 (Moderate)</li> <li>Category: defense-evasion</li> <li>Technique: Masquerading</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--42e8de7b-37b2-4258-905a-6897815e58e0</li> <li>external_id: T1036</li> </ul>"},{"location":"docs/events/builtin/signatures/dropped_executable/#findings","title":"Findings","text":"<p>Once an unexpected executable drop is detected, the signature generates a <code>Finding</code> that contains:</p> <ul> <li>SigMetadata: Essential metadata that provides context regarding the detected event's nature and potential threat level.</li> <li>Event: An exhaustive log of the triggering event, offering a detailed perspective of the issue.</li> <li>Data: Points out the specific path where the unexpected executable has been located, helping to pinpoint the source of the potential breach.</li> </ul>"},{"location":"docs/events/builtin/signatures/dropped_executable/#events-used","title":"Events Used","text":"<p>Primarily, the signature watches for the event:</p> <ul> <li><code>magic_write</code>: This event is activated when there's an attempt to introduce a new file or binary within the container's environment. The signature then inspects this event's data to deduce if the write operation involves a new executable.</li> </ul>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/","title":"Dynamic Code Loading Detection","text":""},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#intro","title":"Intro","text":"<p>The <code>DynamicCodeLoading</code> signature identifies potential threats associated with dynamic code loading. Dynamic code loading is a technique that can be used by attackers to introduce and execute malicious code at runtime, bypassing static analysis mechanisms.</p>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#description","title":"Description","text":"<p>Certain defensive tools monitor the attributes of memory regions in binaries to detect misconduct. If a memory region switches from being \"writable\" to \"executable\", it may indicate that code was written to it and is now intended to be run - a potential sign of dynamic code loading.</p> <p>The <code>DynamicCodeLoading</code> signature vigilantly observes these memory protection alerts to recognize any that signify a transition from \"W\" (Writable) to \"E\" (Executable). This could signify an attempt to load code dynamically for possible malicious intent, bypassing some detection mechanisms.</p>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#purpose","title":"Purpose","text":"<p>The primary goal of the <code>DynamicCodeLoading</code> signature is to provide instantaneous detection and alerts when a binary's memory protection attributes change in a manner indicative of dynamic code loading.</p> <p>Detecting this behavior is essential as it can be used by adversaries to execute malicious code covertly without actually having to drop executable files onto the file system.</p>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-104</li> <li>Version: 1</li> <li>Name: Dynamic code loading detected</li> <li>EventName: dynamic_code_loading</li> <li>Description: Highlights potential dynamic code loading attempts characterized by the binary's memory being both writable and executable. This method can be adopted by adversaries to execute malicious instructions stealthily without storing executable files on the system.</li> <li>Properties:</li> <li>Severity: 2 (Moderate threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Software Packing</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--deb98323-e13f-4b0c-8d94-175379069062</li> <li>external_id: T1027.002</li> </ul>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#findings","title":"Findings","text":"<p>Upon the detection of a potential dynamic code loading instance:</p> <ul> <li>SigMetadata: Renders a comprehensive threat profile as outlined by the signature's definitions.</li> <li>Event: Chronicles a thorough log of the particular event that led to the alert.</li> <li>Data: Presently flagged as <code>nil</code>, indicating that no supplementary data is associated with the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/dynamic_code_loading/#events-used","title":"Events Used","text":"<p>This signature is particularly interested in:</p> <ul> <li><code>mem_prot_alert</code>: Fired whenever there's an alert about memory protection attributes in a binary. The signature specifically looks for alerts indicating a protection change from \"W\" (Writable) to \"E\" (Executable) - a potential hint at dynamic code loading.</li> </ul>"},{"location":"docs/events/builtin/signatures/fileless_execution/","title":"Fileless Execution Detection","text":""},{"location":"docs/events/builtin/signatures/fileless_execution/#intro","title":"Intro","text":"<p>The <code>FilelessExecution</code> signature is crafted to detect instances of fileless execution, which involves running processes directly from memory rather than from a file on the file system. Adversaries use such techniques to escape detection, as fileless operations don't leave traditional footprints on the disk.</p>"},{"location":"docs/events/builtin/signatures/fileless_execution/#description","title":"Description","text":"<p>Fileless execution is a sophisticated technique that circumvents traditional security mechanisms which focus on files. By running processes directly from memory, malicious actors can potentially operate undetected, as no file artifacts are created on the storage system.</p> <p>The <code>FilelessExecution</code> signature identifies these fileless execution attempts by monitoring the <code>sched_process_exec</code> event. If it detects the process is originating from a memory location rather than a file, an alert is raised.</p>"},{"location":"docs/events/builtin/signatures/fileless_execution/#purpose","title":"Purpose","text":"<p>The main goal of the <code>FilelessExecution</code> signature is to provide real-time detection and alerts for fileless execution attempts. With an increasing number of threats leveraging fileless techniques for stealth, being able to detect such activities is crucial for maintaining a robust security posture.</p>"},{"location":"docs/events/builtin/signatures/fileless_execution/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-105</li> <li>Version: 1</li> <li>Name: Fileless execution detected</li> <li>EventName: fileless_execution</li> <li>Description: Fileless execution was detected. Executing a process from memory instead from a file in the filesystem may indicate that an adversary is trying to avoid execution detection.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Reflective Code Loading</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4933e63b-9b77-476e-ab29-761bc5b7d15a</li> <li>external_id: T1620</li> </ul>"},{"location":"docs/events/builtin/signatures/fileless_execution/#findings","title":"Findings","text":"<p>Upon detecting a potential fileless execution, the signature produces a <code>Finding</code> data structure comprising:</p> <ul> <li>SigMetadata: Metadata detailing the threat based on the signature's specifications.</li> <li>Event: A comprehensive log of the specific event that prompted the detection.</li> <li>Data: Currently set to <code>nil</code>, signifying that no supplementary data supports the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/fileless_execution/#events-used","title":"Events Used","text":"<p>The signature predominantly monitors the following event:</p> <ul> <li><code>sched_process_exec</code>: This event is triggered when there's an attempt to execute a process. The signature checks if the process's origin is a memory path, hinting at a fileless execution attempt.</li> </ul>"},{"location":"docs/events/builtin/signatures/format/","title":"Signature Name","text":""},{"location":"docs/events/builtin/signatures/format/#intro","title":"Intro","text":"<p>A very small intro about the signature.</p>"},{"location":"docs/events/builtin/signatures/format/#description","title":"Description","text":"<p>Describe the signature and what it does.</p>"},{"location":"docs/events/builtin/signatures/format/#purpose","title":"Purpose","text":"<p>Describe why the signature does what it does.</p>"},{"location":"docs/events/builtin/signatures/format/#metadata","title":"Metadata","text":"<p>Describe the metadata for the signature.</p>"},{"location":"docs/events/builtin/signatures/format/#findings","title":"Findings","text":"<p>Each signature returns a \"finding\" data structure. This part has a list of all fields inside this \"data\" structure and their types (and what they could mean).</p>"},{"location":"docs/events/builtin/signatures/format/#events-used","title":"Events Used","text":"<p>Each signature has a \"selected events\" session that describes the events that will trigger the signature. This part has a list of all events used by the signature.</p> <p>Note: This document was generated by OpenAI with a human review process.</p>"},{"location":"docs/events/builtin/signatures/hidden_file_created/","title":"Hidden Executable File Creation Detection","text":""},{"location":"docs/events/builtin/signatures/hidden_file_created/#intro","title":"Intro","text":"<p>The <code>HiddenFileCreated</code> signature targets the identification of furtive attempts to create hidden executable files, specifically ELF (Executable and Linkable Format) files, in the system. By convention, in Unix-like systems, any file or directory that starts with a dot (.) is hidden from standard directory listings.</p>"},{"location":"docs/events/builtin/signatures/hidden_file_created/#description","title":"Description","text":"<p>Hidden files and directories are commonly used in Linux and Unix systems to store configuration files and user preferences. However, malicious actors can exploit this convention to hide their activities, files, and tools from standard monitoring and listing tools. The creation of a hidden ELF file, in particular, can suggest that an attacker or malicious software is attempting to operate undetected on the system.</p> <p>The <code>HiddenFileCreated</code> signature closely watches for these furtive actions by scanning the file paths for the presence of the \"hidden\" pattern, i.e., starting with a \"/.\". Combined with checking the magic bytes of files to determine if they are ELF format, this signature provides a robust method to detect hidden executable file creation.</p>"},{"location":"docs/events/builtin/signatures/hidden_file_created/#purpose","title":"Purpose","text":"<p>This signature's principal objective is to detect and flag the concealed creation of ELF files. Monitoring such actions is crucial since, while there can be legitimate reasons to have hidden executables, the unauthorized or unexpected creation of such files can be an early indication of malicious activities.</p>"},{"location":"docs/events/builtin/signatures/hidden_file_created/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1015</li> <li>Version: 1</li> <li>Name: Hidden executable creation detected</li> <li>EventName: hidden_file_created</li> <li>Description: The signature identifies the creation of hidden executable ELF files in the system. While there can be genuine reasons for having hidden executables, the unauthorized or unforeseen creation of such files can be indicative of malicious intent.</li> <li>Properties:</li> <li>Severity: 2 (Moderate threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Hidden Files and Directories</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--ec8fc7e2-b356-455c-8db5-2e37be158e7d</li> <li>external_id: T1564.001</li> </ul>"},{"location":"docs/events/builtin/signatures/hidden_file_created/#findings","title":"Findings","text":"<p>When an anomaly is detected, the signature returns a <code>Finding</code> data structure, which comprises:</p> <ul> <li>SigMetadata: Metadata that provides detailed information about the detected threat, based on the signature's definitions.</li> <li>Event: An exhaustive description of the particular event that invoked the signature's alert mechanism.</li> <li>Data: Currently initialized to <code>nil</code>, indicating that no additional data is associated with the alert.</li> </ul>"},{"location":"docs/events/builtin/signatures/hidden_file_created/#events-used","title":"Events Used","text":"<p>The primary event that powers this signature's functionality is:</p> <ul> <li><code>magic_write</code>: Triggered when specific byte sequences, or \"magic bytes,\" are written to a file. The signature checks the bytes to see if they correspond to an ELF file and examines the file path to determine if the ELF file is hidden.</li> </ul>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/","title":"Illegitimate Shell Detection","text":""},{"location":"docs/events/builtin/signatures/illegitimate_shell/#intro","title":"Intro","text":"<p>The <code>IllegitimateShell</code> signature is specifically designed to detect instances where a web server program spawns a shell. In a standard operating environment, web servers seldom run shell programs. When observed, this behavior might signify a malicious actor exploiting a web server, aiming for command-line execution on the server.</p>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/#description","title":"Description","text":"<p>Web servers primarily serve content and rarely require a shell to function. When a shell gets spawned by a web server, it's often a strong indication of compromise. The <code>IllegitimateShell</code> signature works by monitoring for the <code>security_bprm_check</code> event and examining if any of the predefined web server processes initiate shell execution.</p>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/#purpose","title":"Purpose","text":"<p>The principal aim of the <code>IllegitimateShell</code> signature is to offer real-time alerts and detection for situations where web servers improperly initiate shell processes. Recognizing such anomalies swiftly is paramount in identifying potential breaches, facilitating immediate action and mitigation.</p>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1016</li> <li>Version: 1</li> <li>Name: Web server spawned a shell</li> <li>EventName: illegitimate_shell</li> <li>Description: A web-server program on your server spawned a shell program. Shells are command-line tools, and it's unconventional for web servers to initiate them. This alert might point to a malicious actor leveraging a web server to execute commands on the server.</li> <li>Properties:</li> <li>Severity: 2 (Moderate threat level)</li> <li>Category: initial-access</li> <li>Technique: Exploit Public-Facing Application</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--3f886f2a-874f-4333-b794-aa6075009b1c</li> <li>external_id: T1190</li> </ul>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/#findings","title":"Findings","text":"<p>When an illegitimate shell gets detected from a web server process, the signature formulates a <code>Finding</code> data structure which consists of:</p> <ul> <li>SigMetadata: Metadata that provides insightful details about the potential threat as per the signature's guidelines.</li> <li>Event: An extensive record of the event that set off the detection.</li> <li>Data: Currently marked as <code>nil</code>, indicating there's no additional data underpinning the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/illegitimate_shell/#events-used","title":"Events Used","text":"<p>The signature primarily keeps an eye on the subsequent event:</p> <ul> <li><code>security_bprm_check</code>: Triggered when there's an attempt to execute a program. The signature inspects if the web server processes are trying to run any of the listed shell names.</li> </ul>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/","title":"Kernel Module Loading Detection","text":""},{"location":"docs/events/builtin/signatures/kernel_module_loading/#intro","title":"Intro","text":"<p>The <code>KernelModuleLoading</code> signature is created to detect instances of kernel module loading. Kernel modules are binaries designed to operate within the kernel. By doing so, they run with elevated privileges and can directly interact with the core of the operating system. As a result, malicious entities might aim to load custom kernel modules, extending their capabilities and evading detection by residing in the kernel, away from user space.</p>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/#description","title":"Description","text":"<p>Loading kernel modules can be a legitimate activity, such as when administrators aim to extend the kernel's capabilities. However, when unexpected, it can signify a potentially harmful operation. The <code>KernelModuleLoading</code> signature is designed to monitor for events that hint at kernel module loading and provide alerts when detected.</p>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/#purpose","title":"Purpose","text":"<p>The primary objective of the <code>KernelModuleLoading</code> signature is to ensure real-time detection of kernel module loadings. This proactive detection is vital in identifying potentially harmful modules before they execute their intended functions, offering security personnel an opportunity to intervene.</p>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1017</li> <li>Version: 1</li> <li>Name: Kernel module loading detected</li> <li>EventName: kernel_module_loading</li> <li>Description: Loading of a kernel module was detected. Kernel modules are meant for execution in the kernel environment. Adversaries might load such modules to enhance their functionalities and to elude detection by operating directly within the kernel, sidestepping user space.</li> <li>Properties:</li> <li>Severity: 2 (Moderate threat level)</li> <li>Category: persistence</li> <li>Technique: Kernel Modules and Extensions</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--a1b52199-c8c5-438a-9ded-656f1d0888c6</li> <li>external_id: T1547.006</li> </ul>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/#findings","title":"Findings","text":"<p>When a potential kernel module loading event is recognized, the signature formulates a <code>Finding</code> data structure which encompasses:</p> <ul> <li>SigMetadata: Metadata detailing the perceived threat according to the specifications of the signature.</li> <li>Event: A thorough log of the particular event that caused the detection.</li> <li>Data: Currently labeled as <code>nil</code>, denoting there isn't any extra data backing the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/kernel_module_loading/#events-used","title":"Events Used","text":"<p>This signature predominantly observes the following events:</p> <ul> <li><code>init_module</code>: Triggered during the initiation of a kernel module. When detected, it suggests a module loading event.</li> <li><code>security_kernel_read_file</code>: Engaged when there's a reading activity within the kernel. This event is further inspected to check if the reading pertains to \"kernel-module\" type, which would indicate module loading.</li> </ul>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/","title":"Kubernetes API server connection detected","text":""},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#intro","title":"Intro","text":"<p>The <code>K8sApiConnection</code> signature detects attempts to connect to the Kubernetes API server from within a container.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#description","title":"Description","text":"<p>This signature tracks and monitors connections made from containers to the Kubernetes API server. It maintains a mapping of container IDs and their respective Kubernetes API server IP addresses.</p> <p>When a connection to the tracked Kubernetes API server IP address is detected, an alert is raised, as unauthorized access or communication attempts with the Kubernetes API can signal potential security breaches.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#purpose","title":"Purpose","text":"<p>The Kubernetes API server is the central management entity of a Kubernetes cluster. Malicious attempts to communicate or interact with it can be indicative of information gathering, credential extraction, or attempts to deploy malicious containers. By detecting such connections, the system can identify unauthorized or suspicious activities early on.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1013</li> <li>Version: 0.1.0</li> <li>Name: Kubernetes API server connection detected</li> <li>EventName: k8s_api_connection</li> <li>Description: Monitoring and alerting on connections to the Kubernetes API server, as interactions with the API server can reveal attempts to gather data, credentials or run malicious containers.</li> <li>Tags: container</li> <li>Properties:</li> <li>Severity: 1</li> <li>MITRE ATT&amp;CK: Discovery: Cloud Service Discovery</li> </ul>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#findings","title":"Findings","text":"<p>Upon detection, the signature returns a <code>Finding</code> data structure with the following fields:</p> <ul> <li>ip: (Type: string) The IP address of the Kubernetes API server that the container tried to connect to.</li> </ul>"},{"location":"docs/events/builtin/signatures/kubernetes_api_connection/#events-used","title":"Events Used","text":"<p>The signature responds to two primary events:</p> <ol> <li><code>sched_process_exec</code> - Triggered when a process is scheduled for execution within a container. It checks for the Kubernetes API server IP in the container's environment variables.</li> <li><code>security_socket_connect</code> - Indicates when a socket connection is made within a container. If the connection IP matches the earlier stored Kubernetes API server IP, an alert is generated.</li> </ol>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/","title":"Kubernetes TLS Certificate Theft Detection","text":""},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#intro","title":"Intro","text":"<p>The <code>KubernetesCertificateTheftAttempt</code> signature is designed to detect unauthorized access or potential theft of Kubernetes Transport Layer Security (TLS) certificates. Kubernetes relies on TLS certificates for secure communication between its components. Any unauthorized access or movement of these certificates can potentially allow an adversary to impersonate Kubernetes components within the cluster, jeopardizing its security.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#description","title":"Description","text":"<p>TLS certificates are foundational to establishing trust between systems. Kubernetes uses these certificates to ensure secure communication pathways between different components, such as the kubelet scheduler, controller, and the API Server. The theft or misuse of these certificates can give adversaries undue access or the ability to masquerade as legitimate Kubernetes components.</p> <p>The <code>KubernetesCertificateTheftAttempt</code> signature vigilantly monitors file access patterns and renaming activities in the Kubernetes certificate directory to catch any unauthorized or suspicious activities.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#purpose","title":"Purpose","text":"<p>The primary aim of the <code>KubernetesCertificateTheftAttempt</code> signature is to ensure real-time detection of unauthorized access to Kubernetes TLS certificates. By proactively identifying potential theft or misuse, security teams can promptly respond to contain the breach and safeguard the cluster.</p>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1018</li> <li>Version: 1</li> <li>Name: K8s TLS certificate theft detected</li> <li>EventName: k8s_cert_theft</li> <li>Description: Theft of Kubernetes TLS certificates was recognized. These certificates play a pivotal role in establishing trust and secure communication within the Kubernetes cluster. If compromised, adversaries can impersonate legitimate Kubernetes components.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: credential-access</li> <li>Technique: Steal Application Access Token</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--890c9858-598c-401d-a4d5-c67ebcdd703a</li> <li>external_id: T1528</li> </ul>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#findings","title":"Findings","text":"<p>When a potential unauthorized access to Kubernetes TLS certificates is detected, the signature generates a <code>Finding</code> data structure, encompassing:</p> <ul> <li>SigMetadata: Metadata detailing the perceived threat as per the signature's specifications.</li> <li>Event: A detailed log of the event that triggered the detection.</li> <li>Data: Presently marked as <code>nil</code>, indicating that there isn't any additional data supporting the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/kubernetes_certificate_theft_attempt/#events-used","title":"Events Used","text":"<p>The signature primarily monitors the following events:</p> <ul> <li><code>security_file_open</code>: This event is triggered when there's an attempt to open a file. The signature inspects if the operation pertains to reading and if the file path aligns with Kubernetes certificates. It also ensures that only legitimate processes can access the certificates.</li> <li><code>security_inode_rename</code>: Engaged when there's a renaming activity within the inode. The signature checks if the old path of the renamed item corresponds with the Kubernetes certificate directory.</li> </ul>"},{"location":"docs/events/builtin/signatures/ld_preload/","title":"LD_PRELOAD code injection detected","text":""},{"location":"docs/events/builtin/signatures/ld_preload/#intro","title":"Intro","text":"<p>The <code>LdPreload</code> signature identifies the use of <code>LD_PRELOAD</code> and <code>LD_LIBRARY_PATH</code> environment variables, or alterations to the <code>/etc/ld.so.preload</code> file, which can potentially be leveraged for code injection. By preloading certain libraries, adversaries might gain the ability to hijack function calls or manipulate program behavior.</p>"},{"location":"docs/events/builtin/signatures/ld_preload/#description","title":"Description","text":"<p>This signature targets three main aspects:</p> <ol> <li>Monitoring environment variables during process execution that are related to library preloading.</li> <li>Detecting when the <code>/etc/ld.so.preload</code> file is being opened with write permissions.</li> <li>Observing renaming operations that involve the <code>/etc/ld.so.preload</code> file.</li> </ol> <p>These detections are pivotal, as the unauthorized or unintended use of <code>LD_PRELOAD</code> can allow attackers to change the order in which a program loads its libraries. This could enable them to inject malicious code or redirect specific function calls to other unintended functions.</p>"},{"location":"docs/events/builtin/signatures/ld_preload/#purpose","title":"Purpose","text":"<p>The primary goal of this signature is to detect and alert on potential code injection attempts that exploit library preloading mechanisms. By detecting alterations or suspicious usage of related environment variables or the preload file, it aids in thwarting attempts by adversaries to subvert application behavior or maintain a malicious foothold on the system.</p>"},{"location":"docs/events/builtin/signatures/ld_preload/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-107</li> <li>Version: 1</li> <li>Name: LD_PRELOAD code injection detected</li> <li>EventName: ld_preload</li> <li>Description: Monitors for the use of <code>LD_PRELOAD</code> or <code>LD_LIBRARY_PATH</code> environment variables and changes to the <code>/etc/ld.so.preload</code> file. These methods can be exploited for malicious code injection or altering program behavior.</li> <li>Properties:</li> <li>Severity: 2</li> <li>Category: persistence</li> <li>Technique: Hijack Execution Flow</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--aedfca76-3b30-4866-b2aa-0f1d7fd1e4b6</li> <li>external_id: T1574</li> </ul>"},{"location":"docs/events/builtin/signatures/ld_preload/#findings","title":"Findings","text":"<p>When any suspicious or predefined activities are detected, the signature triggers a <code>Finding</code>, signaling a potential threat. This finding contains the event's metadata and might also include data fields specifying the particular environment variable that was used.</p>"},{"location":"docs/events/builtin/signatures/ld_preload/#events-used","title":"Events Used","text":"<p>The signature listens to three event types:</p> <ol> <li><code>sched_process_exec</code> - Examines environment variables during process execution to detect the usage of <code>LD_PRELOAD</code> or <code>LD_LIBRARY_PATH</code>.</li> <li><code>security_file_open</code> - Monitors if the <code>/etc/ld.so.preload</code> file is being accessed with write permissions, indicating potential alterations.</li> <li><code>security_inode_rename</code> - Observes renaming operations involving the <code>/etc/ld.so.preload</code> file.</li> </ol> <p>Using these events, the signature provides an extensive defense against unauthorized or malicious utilization of library preloading mechanisms.</p>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/","title":"File Operations Hooking on Proc Filesystem Detection","text":""},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#intro","title":"Intro","text":"<p>The <code>ProcFopsHooking</code> signature is constructed to detect malicious hooking of file operations on the proc filesystem.</p> <p>The proc filesystem serves as a pseudo-filesystem which presents running processes as files. Rootkits and similar sophisticated malware can exploit this system by replacing the default file operations, hence altering or gaining control over how the OS interacts with its processes.</p>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#description","title":"Description","text":"<p>The proc filesystem offers an interface that maps running processes to files. This mapping is crucial for utilities such as <code>ps</code> and <code>top</code>, which rely on this representation to list and provide details of running processes.</p> <p>File operations define how the system interacts with these 'files', and hooking these operations can let an attacker gain unauthorized control over system functions. For instance, they can influence file listings or even hijack execution flows.</p> <p>This kind of meddling is not just a hallmark of rootkits but is also an alarming sign that the kernel could be compromised. Additionally, hidden modules, signified as hidden symbol owners, amplify the threat as they may indicate a deeper penetration of adversarial activities.</p>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#purpose","title":"Purpose","text":"<p><code>ProcFopsHooking</code> is geared towards real-time detection of such malicious file operation hooking on the proc filesystem. Recognizing these hooks can give a critical headstart in responding to and neutralizing threats, preserving the kernel's integrity and ensuring that system processes are left uncompromised.</p>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1020</li> <li>Version: 1</li> <li>Name: File operations hooking on proc filesystem detected</li> <li>EventName: proc_fops_hooking</li> <li>Description: It monitors malicious hooking on the proc filesystem. Such hooking interferes with how processes, presented as files, are handled by the system. Malicious entities, like rootkits, can hijack or control system functions through this, implying the kernel may be compromised.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Rootkit</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--0f20e3cb-245b-4a61-8a91-2d93f7cb0e9b</li> <li>external_id: T1014</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#findings","title":"Findings","text":"<p>Upon detecting malicious hooking, the signature generates a <code>Finding</code>, which contains:</p> <ul> <li>SigMetadata: Metadata that offers insights into the detected threat based on the signature's defined parameters.</li> <li>Event: A comprehensive log detailing the event that prompted the detection.</li> <li>Data: This outlines the specific file operations on the proc filesystem that have been hooked, thus offering more granularity on the potential threat.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_fops_hooking/#events-used","title":"Events Used","text":"<p>The signature mainly focuses on the event:</p> <ul> <li><code>hooked_proc_fops</code>: Triggered when malicious hooking of proc filesystem file operations is detected. The signature evaluates the data attached to this event to determine the exact nature and extent of the hooking.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/","title":"Kcore Memory File Read Detection","text":""},{"location":"docs/events/builtin/signatures/proc_kcore_read/#intro","title":"Intro","text":"<p>The <code>ProcKcoreRead</code> signature identifies attempts to access and read the <code>/proc/kcore</code> file, a crucial system file that mirrors the physical memory of the Linux system.</p>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/#description","title":"Description","text":"<p>The <code>/proc/kcore</code> file is a unique entity in Linux systems. It offers an image of the physical memory in the ELF core dump file format. This means it provides a comprehensive snapshot of the entire system's memory. While this can be useful for certain legitimate debugging scenarios, malicious actors can also leverage it to acquire a comprehensive memory dump, potentially containing sensitive data, credentials, or other valuable information.</p> <p>Reading the <code>/proc/kcore</code> file can be a significant step for adversaries aiming for techniques such as container escapes. It's a tactic that can give them detailed insights into the host system, which could be subsequently exploited for more advanced attacks.</p> <p>The <code>ProcKcoreRead</code> signature vigilantly watches for any attempts to read this file and raises alerts if such activities are detected.</p>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/#purpose","title":"Purpose","text":"<p>The central aim of this signature is to detect and raise alerts concerning unauthorized access and reading of the <code>/proc/kcore</code> file. Monitoring this file is vital since any unauthorized reads can be indicative of adversarial intentions, such as gleaning host memory data for potential container escape strategies.</p>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1021</li> <li>Version: 1</li> <li>Name: Kcore memory file read</li> <li>EventName: proc_kcore_read</li> <li>Description: The signature tracks any read operations on the <code>/proc/kcore</code> file. This file provides a complete dump of the host's physical memory. Unauthorized access to it can suggest an attacker's attempts to gain insights into the host memory, potentially aiming for container escapes or other privilege escalation techniques.</li> <li>Properties:</li> <li>Severity: 2 (Moderate to low threat level)</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/#findings","title":"Findings","text":"<p>When a potential threat is pinpointed, the signature returns a <code>Finding</code> data structure, which contains:</p> <ul> <li>SigMetadata: Metadata detailing the threat as per the signature's information.</li> <li>Event: The specific event details that instigated the signature's activation.</li> <li>Data: Currently set to <code>nil</code>, which denotes no additional data accompanies this structure.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_kcore_read/#events-used","title":"Events Used","text":"<p>The signature relies on the following event for its operations:</p> <ul> <li><code>security_file_open</code>: Activates when a file is accessed. The signature examines the accessed file's pathname and flags to determine if there's an attempt to read the <code>/proc/kcore</code> file.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_mem_access/","title":"Process Memory Access Detection","text":""},{"location":"docs/events/builtin/signatures/proc_mem_access/#intro","title":"Intro","text":"<p>The <code>ProcMemAccess</code> signature is designed to monitor and identify unauthorized or suspicious attempts to access a process's memory through the Linux proc filesystem.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_access/#description","title":"Description","text":"<p>In Linux, each process has an associated directory in the <code>/proc</code> filesystem, labeled by its PID (Process Identifier). Within this directory, the <code>mem</code> file provides an interface to access the process's memory. This can be invaluable for debugging, but it also poses a significant security risk. Malicious actors can exploit this access point to read confidential data from running processes, including secrets and credentials.</p> <p>By accessing these memory files, adversaries can gain insights into the system's operations and potentially extract valuable information. The <code>ProcMemAccess</code> signature, therefore, employs a regex pattern to vigilantly track access to these <code>mem</code> files, raising alerts when detected.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_access/#purpose","title":"Purpose","text":"<p>The primary objective of the <code>ProcMemAccess</code> signature is to flag unauthorized or unexpected access to the memory of running processes. Monitoring these accesses is paramount as it can provide early warnings about potential data breaches or malware activities attempting to steal sensitive information.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_access/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1023</li> <li>Version: 1</li> <li>Name: Process memory access detected</li> <li>EventName: proc_mem_access</li> <li>Description: The signature identifies unauthorized or suspicious attempts to access the memory of running processes via the <code>/proc</code> filesystem. Such access can be indicative of attacks aiming to steal credentials, secrets, or other sensitive data from these processes.</li> <li>Properties:</li> <li>Severity: 3 (Moderate threat level)</li> <li>Category: credential-access</li> <li>Technique: Proc Filesystem</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--3120b9fa-23b8-4500-ae73-09494f607b7d</li> <li>external_id: T1003.007</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_mem_access/#findings","title":"Findings","text":"<p>Upon detection of a potential threat, the signature returns a <code>Finding</code> data structure, which encapsulates:</p> <ul> <li>SigMetadata: Metadata, as defined by the signature, that outlines the specifics of the threat.</li> <li>Event: Detailed account of the event that triggered the signature.</li> <li>Data: Currently initialized to <code>nil</code>, signifying no supplementary data is attached.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_mem_access/#events-used","title":"Events Used","text":"<p>The primary event the signature leans on for its functioning is:</p> <ul> <li><code>security_file_open</code>: This event is triggered when there's an attempt to access a file. The signature cross-references the accessed file's pathname with its regex pattern to discern whether there's an endeavor to access a process's memory file in the <code>/proc</code> filesystem.</li> </ul>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/","title":"Code injection detected through procfs mem file","text":""},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#intro","title":"Intro","text":"<p>The <code>ProcMemCodeInjection</code> signature detects attempts to inject code into another process by writing to the <code>/proc/&lt;pid&gt;/mem</code> file.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#description","title":"Description","text":"<p>The <code>/proc/&lt;pid&gt;/mem</code> file on Linux systems allows direct access to the memory of a process, represented by the <code>&lt;pid&gt;</code> placeholder in the file path.</p> <p>Adversaries might attempt to write malicious code into a process's memory space by using this file, a tactic commonly referred to as code injection. Successful code injection can allow adversaries to execute arbitrary code in the context of another process, facilitating evasion, persistence, and potentially privilege escalation.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#purpose","title":"Purpose","text":"<p>By monitoring writes to the <code>/proc/&lt;pid&gt;/mem</code> file, this signature aims to identify and alert on possible code injection attempts. Detecting such attempts can be crucial for identifying and mitigating advanced threats that utilize in-memory exploitation techniques.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1024</li> <li>Version: 1</li> <li>Name: Code injection detected through /proc//mem file <li>EventName: proc_mem_code_injection</li> <li>Description: Monitors for potential code injection attempts into another process using the <code>/proc/&lt;pid&gt;/mem</code> file, a technique that can be used to execute arbitrary code within the context of another process.</li> <li>Properties:</li> <li>Severity: 3</li> <li>Category: defense-evasion</li> <li>Technique: Proc Memory</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--d201d4cc-214d-4a74-a1ba-b3fa09fd4591</li> <li>external_id: T1055.009</li>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#findings","title":"Findings","text":"<p>Upon detection, the signature returns a <code>Finding</code> data structure. The findings don't contain any specific data fields related to the event, other than the metadata of the event itself.</p>"},{"location":"docs/events/builtin/signatures/proc_mem_code_injection/#events-used","title":"Events Used","text":"<p>The signature primarily reacts to the following event:</p> <ol> <li><code>security_file_open</code> - Indicates when a file is opened. The signature checks if the file being opened matches the pattern <code>/proc/&lt;pid&gt;/mem</code> and if it's being written to.</li> </ol>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/","title":"Process VM Write Code Injection Detection","text":""},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#intro","title":"Intro","text":"<p>The <code>ProcessVmWriteCodeInjection</code> signature is designed to detect potential code injection attacks using the <code>process_vm_writev</code> syscall.</p> <p>Code injection attacks involve injecting malicious code into another process's memory. Such techniques allow adversaries to execute their malicious payloads within the context of other processes, potentially evading detection and benefiting from the permissions of the targeted process.</p>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#description","title":"Description","text":"<p>The <code>process_vm_writev</code> syscall allows one process to write into another process's memory. While there are legitimate uses for this syscall, it can also be abused for code injection purposes.</p> <p>The <code>ProcessVmWriteCodeInjection</code> signature closely monitors this syscall for indications of cross-process memory writes that might indicate malicious activity.</p>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#purpose","title":"Purpose","text":"<p>The core purpose of the <code>ProcessVmWriteCodeInjection</code> signature is to provide real-time detection and alerts when a process tries to write into another process's memory using the <code>process_vm_writev</code> syscall. This is critical because code injection can give attackers the ability to run arbitrary code with the permissions of the compromised process, making it a dangerous attack vector.</p>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1025</li> <li>Version: 1</li> <li>Name: Code injection detected using process_vm_writev syscall</li> <li>EventName: process_vm_write_inject</li> <li>Description: Detects possible code injection attempts into another process's memory. This technique is employed by adversaries to execute malicious code in the context of another process.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Process Injection</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--43e7dc91-05b2-474c-b9ac-2ed4fe101f4d</li> <li>external_id: T1055</li> </ul>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#findings","title":"Findings","text":"<p>If a potential code injection attempt is detected, the signature returns a <code>Finding</code> data structure containing:</p> <ul> <li>SigMetadata: Metadata outlining the threat as per the signature's definition.</li> <li>Event: A detailed log of the specific event that triggered the detection.</li> <li>Data: Currently set to <code>nil</code>, implying that no additional data is accompanying the detection.</li> </ul>"},{"location":"docs/events/builtin/signatures/process_vm_write_code_injection/#events-used","title":"Events Used","text":"<p>The primary event this signature monitors is:</p> <ul> <li><code>process_vm_writev</code>: Invoked when the <code>process_vm_writev</code> syscall is used. The signature verifies if the memory write is targeting another process's memory (i.e., when the source and destination PIDs don't match). If such a discrepancy is observed, it may be indicative of a code injection attempt.</li> </ul>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/","title":"Ptrace Code Injection Detection","text":""},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#intro","title":"Intro","text":"<p>The <code>PtraceCodeInjection</code> signature is tailored to identify attempts at code injection through the use of the <code>ptrace</code> system call. The signature specifically looks for the <code>PTRACE_POKETEXT</code> and <code>PTRACE_POKEDATA</code> requests, commonly used for altering the target process's memory. Code injection is a sophisticated attack vector, allowing attackers to run arbitrary code within the context of another process.</p>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#description","title":"Description","text":"<p>Code injection is a pervasive technique used by adversaries to execute malicious payloads within other processes, evading detection and leveraging the permissions of the injected process. This can enable them to operate stealthily, as the malicious operations appear to be coming from a legitimate process.</p> <p>The <code>ptrace</code> system call, especially with the <code>PTRACE_POKETEXT</code> and <code>PTRACE_POKEDATA</code> requests, can be exploited for such purposes. By monitoring these specific requests, this signature can detect attempts to write to another process's memory, signaling potential code injection attempts.</p>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#purpose","title":"Purpose","text":"<p>The primary objective of the <code>PtraceCodeInjection</code> signature is to detect and raise alerts regarding potential code injection attempts using <code>ptrace</code>. Such detection is vital because, if successful, the attacker can assume the identity of another process, potentially gaining elevated privileges and evading detection mechanisms.</p>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-103</li> <li>Version: 1</li> <li>Name: Code injection detected using ptrace</li> <li>EventName: ptrace_code_injection</li> <li>Description: The signature is specifically crafted to detect potential code injection attempts into another process using the <code>ptrace</code> system call. Code injection is a method used by adversaries to execute malicious code within the confines of another process, effectively evading detection and leveraging the permissions of the injected process.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Ptrace System Calls</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--ea016b56-ae0e-47fe-967a-cc0ad51af67f</li> <li>external_id: T1055.008</li> </ul>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#findings","title":"Findings","text":"<p>Upon detecting a potential code injection attempt, the signature returns a <code>Finding</code> data structure, which entails:</p> <ul> <li>SigMetadata: Metadata detailing the threat according to the signature's specifications.</li> <li>Event: Provides an in-depth account of the specific event that triggered the signature's detection mechanism.</li> <li>Data: Currently set to <code>nil</code>, indicating no additional data accompanies this structure.</li> </ul>"},{"location":"docs/events/builtin/signatures/ptrace_code_injection/#events-used","title":"Events Used","text":"<p>The detection capabilities of this signature rely primarily on the following event:</p> <ul> <li><code>ptrace</code>: Triggered when the <code>ptrace</code> system call is utilized. The signature meticulously evaluates the request type to determine if there's an invocation of either <code>PTRACE_POKETEXT</code> or <code>PTRACE_POKEDATA</code>, indicating a potential code injection attempt.</li> </ul>"},{"location":"docs/events/builtin/signatures/rcd_modification/","title":"Rcd Modification Detection","text":""},{"location":"docs/events/builtin/signatures/rcd_modification/#intro","title":"Intro","text":"<p>The <code>RcdModification</code> signature identifies changes or modifications to the rcd files and related commands. These files are crucial as they are scripts executed during boot and runlevel switches. By altering these scripts, adversaries can maintain persistence across system reboots.</p>"},{"location":"docs/events/builtin/signatures/rcd_modification/#description","title":"Description","text":"<p>The rcd (runlevel control directories) scripts are integral to the Linux system as they are responsible for service control during system bootup and when the system's runlevel changes. When these scripts or related directories are altered, it can imply a persistent malicious foothold within the system.</p> <p>This signature, <code>RcdModification</code>, monitors the rcd files and directories for any modifications. By identifying unauthorized changes to these components, it aims to counteract threats that rely on altering system initialization scripts to ensure continuous malicious activity after system reboots.</p>"},{"location":"docs/events/builtin/signatures/rcd_modification/#purpose","title":"Purpose","text":"<p>The primary objective of this signature is to detect unauthorized changes or executions related to the rcd files, directories, and commands. By doing so, it aims to safeguard the system against threats that target bootup scripts for persistence.</p>"},{"location":"docs/events/builtin/signatures/rcd_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1026</li> <li>Version: 1</li> <li>Name: Rcd modification detected</li> <li>EventName: rcd_modification</li> <li>Description: The signature zeroes in on modifications to the rcd files. Since these files run during system bootup and runlevel switches, they are paramount for system initialization. Adversaries can modify or append to these files, ensuring their malicious code runs consistently even after reboots, thus achieving persistence.</li> <li>Properties:</li> <li>Severity: 2 (Moderate threat level)</li> <li>Category: persistence</li> <li>Technique: RC Scripts</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--dca670cf-eeec-438f-8185-fd959d9ef211</li> <li>external_id: T1037.004</li> </ul>"},{"location":"docs/events/builtin/signatures/rcd_modification/#findings","title":"Findings","text":"<p>Upon detection of a potential threat, the signature reports back a <code>Finding</code> data structure, which encapsulates:</p> <ul> <li>SigMetadata: Information about the potential threat based on the signature's criteria.</li> <li>Event: The specifics of the event which caused the signature to trigger.</li> <li>Data: Currently set to <code>nil</code>, indicating that no additional data is provided.</li> </ul>"},{"location":"docs/events/builtin/signatures/rcd_modification/#events-used","title":"Events Used","text":"<p>This signature relies on several events:</p> <ul> <li><code>security_file_open</code>: This event activates when a file is accessed. The signature checks if the file is one of the rcd files and if it's being written to.</li> <li><code>security_inode_rename</code>: This event is triggered when an inode is renamed. The signature uses this event to discern if any rcd files or directories are being renamed.</li> <li><code>sched_process_exec</code>: This event fires up when a new process is initiated. The signature ensures if the <code>update-rc.d</code> command, which manages the rcd scripts, is executed.</li> </ul>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/","title":"<code>sched_debug</code> File Reconnaissance Detection","text":""},{"location":"docs/events/builtin/signatures/sched_debug_recon/#intro","title":"Intro","text":"<p>The <code>SchedDebugRecon</code> signature aims to detect when the <code>sched_debug</code> file, a file that offers insights about the CPU and ongoing processes, is read. Threat actors could tap into this file to glean valuable information about a system's operational dynamics.</p>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/#description","title":"Description","text":"<p>The <code>sched_debug</code> file, commonly found at <code>/proc/sched_debug</code> and <code>/sys/kernel/debug/sched/debug</code>, provides detailed information about the scheduler's inner workings, including insights about the CPU and ongoing processes.</p> <p>Though it's primarily intended for debugging purposes, adversaries can exploit it for reconnaissance, profiling the system before executing a potentially harmful action.</p>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/#purpose","title":"Purpose","text":"<p>This signature's primary purpose is to identify unauthorized or suspicious reads on the <code>sched_debug</code> file. Recognizing such access can serve as an early warning, flagging a possible attempt at system reconnaissance.</p>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1029</li> <li>Version: 1</li> <li>Name: sched_debug CPU file was read</li> <li>EventName: sched_debug_recon</li> <li>Description: Detects when the <code>sched_debug</code> file is accessed for reading. Given the sensitive information this file contains, unauthorized reads could imply that an adversary is attempting to gather intelligence about the system.</li> <li>Properties:</li> <li>Severity: 1 (Lowest threat level)</li> <li>Category: discovery</li> <li>Technique: Container and Resource Discovery</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--0470e792-32f8-46b0-a351-652bc35e9336</li> <li>external_id: T1613</li> </ul>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/#findings","title":"Findings","text":"<p>If a match is detected, meaning that the <code>sched_debug</code> file is read, a <code>Finding</code> is generated. This finding encompasses detailed metadata about the potential threat, enabling system administrators or security professionals to take further action if necessary.</p>"},{"location":"docs/events/builtin/signatures/sched_debug_recon/#events-used","title":"Events Used","text":"<p>This signature focuses on a single event:</p> <ul> <li><code>security_file_open</code>: This event fires when a file is accessed. The signature determines if the <code>sched_debug</code> file is being read by checking the file's pathname and flags.</li> </ul>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/","title":"Scheduled tasks modification detected","text":""},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#intro","title":"Intro","text":"<p>The <code>ScheduledTaskModification</code> signature aims to identify when scheduled tasks or their configurations have been tampered with. Scheduled tasks are a common mechanism used on Linux-based systems to execute commands or scripts at predefined times or after specific intervals. However, adversaries might manipulate these tasks for malicious purposes, such as maintaining persistence after a reboot.</p>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#description","title":"Description","text":"<p>This signature focuses on the various aspects of task scheduling, specifically revolving around the <code>crontab</code> and its associated files and directories.</p> <p>Monitoring alterations to these files and directories is critical because changes could be indicative of unauthorized activities. The signature also identifies when certain commands related to scheduling are executed, ensuring a broader coverage against potential threats.</p>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#purpose","title":"Purpose","text":"<p>This signature primarily aims to safeguard systems against unauthorized or malicious modifications to scheduled tasks. By detecting such changes, it alerts administrators or security systems, helping prevent potential breaches or maintaining a persistent presence by adversaries.</p>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1027</li> <li>Version: 1</li> <li>Name: Scheduled tasks modification detected</li> <li>EventName: scheduled_task_mod</li> <li>Description: Monitors for changes to task scheduling configurations or the execution of scheduling-related commands. Detecting such modifications is crucial because adversaries can use these tasks for persistence mechanisms.</li> <li>Properties:</li> <li>Severity: 2</li> <li>Category: persistence</li> <li>Technique: Cron</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--2acf44aa-542f-4366-b4eb-55ef5747759c</li> <li>external_id: T1053.003</li> </ul>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#findings","title":"Findings","text":"<p>Upon detecting any of the predefined suspicious actions, the signature triggers a <code>Finding</code> structure, signaling potential threats. The findings don't contain specific data fields related to the event, except for the event's metadata.</p>"},{"location":"docs/events/builtin/signatures/scheduled_task_modification/#events-used","title":"Events Used","text":"<p>This signature primarily listens to three event types:</p> <ol> <li><code>security_file_open</code> - Checks if a scheduling-related file was opened, specifically with write permissions.</li> <li><code>security_inode_rename</code> - Monitors if any of the scheduling-related files or directories got renamed.</li> <li><code>sched_process_exec</code> - Listens for the execution of specific commands related to task scheduling.</li> </ol> <p>By monitoring these events, the signature offers a comprehensive safeguard against the unauthorized alteration of scheduled tasks.</p>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/","title":"Process standard input/output over socket detected","text":""},{"location":"docs/events/builtin/signatures/stdio_over_socket/#intro","title":"Intro","text":"<p>The <code>StdioOverSocket</code> signature is a security mechanism aimed at detecting potential Reverse Shell attacks based on process standard input/output redirections to sockets.</p>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/#description","title":"Description","text":"<p>Upon identifying that a process has its standard input/output redirected to a socket, this signature raises an alert. Such behavior can be indicative of a malicious actor attempting to establish a reverse shell, which provides them interactive control over a compromised target.</p>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/#purpose","title":"Purpose","text":"<p>The main goal of this signature is to identify and flag suspicious redirection of standard I/O operations. Specifically, if these operations are redirected to a socket, it can be a red flag, as this is a behavior commonly associated with a Reverse Shell attack. By detecting such activities, proactive actions can be taken to mitigate potential breaches.</p>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-101</li> <li>Version: 2</li> <li>Name: Process standard input/output over socket detected</li> <li>EventName: stdio_over_socket</li> <li>Description: This behavior hints at a Reverse Shell attack, where an interactive shell is activated from a target machine back to the attacker's machine.</li> <li>Properties:</li> <li>Severity: 3</li> <li>Category: execution</li> <li>Technique: Unix Shell</li> <li>id: attack-pattern--a9d4b653-6915-42af-98b2-5758c4ceee56</li> <li>external_id: T1059.004</li> </ul>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/#findings","title":"Findings","text":"<p>Upon detection, the signature returns a <code>Finding</code> data structure with the following fields:</p> <ul> <li>IP address: (Type: string) The IP address associated with the socket.</li> <li>Port: (Type: string) The port associated with the socket.</li> <li>File descriptor: (Type: int) The file descriptor of the standard input/output (0, 1, 2 for stdin, stdout, stderr, respectively).</li> </ul>"},{"location":"docs/events/builtin/signatures/stdio_over_socket/#events-used","title":"Events Used","text":"<p>The signature responds to two primary events:</p> <ol> <li><code>security_socket_connect</code> - Indicates when a socket connection is made.</li> <li><code>socket_dup</code> - Denotes when a socket is duplicated.</li> </ol> <p>Both events are sourced from <code>tracee</code>.</p>"},{"location":"docs/events/builtin/signatures/sudoers_modification/","title":"Sudoers File Modification Detection","text":""},{"location":"docs/events/builtin/signatures/sudoers_modification/#intro","title":"Intro","text":"<p>The <code>SudoersModification</code> signature is designed to detect unauthorized or unexpected changes to the sudoers configuration files on a system.</p> <p>The sudoers file is a critical part of Unix and Linux systems, controlling which users can run which commands as superuser. Unauthorized changes to this file can lead to privilege escalation and unauthorized command execution.</p>"},{"location":"docs/events/builtin/signatures/sudoers_modification/#description","title":"Description","text":"<p>The sudoers file, traditionally located at <code>/etc/sudoers</code>, contains the rules that users must follow when they use the <code>sudo</code> command. It dictates who can run what, as whom, and from where. Any unauthorized changes to this file, or the related configuration in <code>/etc/sudoers.d/</code>, could allow an attacker to elevate their privileges and take control of a system.</p>"},{"location":"docs/events/builtin/signatures/sudoers_modification/#purpose","title":"Purpose","text":"<p>The main aim of this signature is to monitor for modifications to the sudoers configuration. By doing so, it helps in the early detection of possible security breaches or misconfigurations which could jeopardize the security posture of a system.</p>"},{"location":"docs/events/builtin/signatures/sudoers_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1028</li> <li>Version: 1</li> <li>Name: Sudoers file modification detected</li> <li>EventName: sudoers_modification</li> <li>Description: Monitors for unauthorized changes to the sudoers file. The sudoers file manages permissions for the <code>sudo</code> command. Unauthorized changes could allow an attacker to elevate privileges or run commands without proper authorization.</li> <li>Properties:</li> <li>Severity: 2</li> <li>Category: privilege-escalation</li> <li>Technique: Sudo and Sudo Caching</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--1365fe3b-0f50-455d-b4da-266ce31c23b0</li> <li>external_id: T1548.003</li> </ul>"},{"location":"docs/events/builtin/signatures/sudoers_modification/#findings","title":"Findings","text":"<p>On detecting a potential unauthorized modification to the sudoers configuration, a <code>Finding</code> is generated. This <code>Finding</code> contains detailed information about the event, along with associated threat metadata, enabling responders to take appropriate action.</p>"},{"location":"docs/events/builtin/signatures/sudoers_modification/#events-used","title":"Events Used","text":"<p>This signature is chiefly concerned with two events:</p> <ul> <li> <p><code>security_file_open</code>: Triggered when a file is accessed. The signature checks if the file is being opened with write permissions.</p> </li> <li> <p><code>security_inode_rename</code>: This event signifies the renaming of a file or directory. Renaming critical files, like the sudoers file, might be an indicator of malicious activity.</p> </li> </ul> <p>The signature checks if the path associated with these events matches the known paths for sudoers files or starts with the directory paths designated for sudoers configurations.</p>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/","title":"Syscall Table Hooking Detection","text":""},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#intro","title":"Intro","text":"<p>The <code>SyscallTableHooking</code> signature is developed to detect malevolent hooking of the syscall table in a system.</p> <p>System calls (syscalls) serve as the pivotal bridge between user applications and the operating system kernel. If manipulated through hooking, they grant an adversary the capability to exert substantial control over vital system functions.</p>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#description","title":"Description","text":"<p>Syscalls are essential; they act as intermediaries enabling user applications to request services and operations from the OS kernel. A table in the kernel catalogs these syscalls.</p> <p>If a malicious actor manages to manipulate or \"hook\" into this table, they gain the ability to either supplant or entirely circumvent the kernel's innate operations. This control ranges from basic operations like reading/writing files to advanced capabilities like influencing the system's behavior or even rerouting its execution flow. In simple terms, an attacker could make the system believe it's performing regular operations when it's, in fact, executing the attacker's code.</p> <p>Rootkits, notorious for deep system infiltration, often exploit syscall table hooking. It's a strong indication that the system's kernel may have been compromised. Furthermore, any modules hiding in the shadows, known as \"hidden modules,\" also hint at a deeper malfeasance and indicate an elevated threat level.</p>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#purpose","title":"Purpose","text":"<p>The signature <code>SyscallTableHooking</code> is meticulously designed to detect instances where the syscall table is tampered with in real-time. By spotting these hooks early, it provides a pivotal advantage in thwarting and neutralizing potential threats, preserving the sanctity of the kernel and the entire system.</p>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1030</li> <li>Version: 1</li> <li>Name: Syscall table hooking detected</li> <li>EventName: syscall_hooking</li> <li>Description: It focuses on detecting unauthorized and malevolent hooking of the syscall table. This manipulation allows an attacker to exert undue control over the kernel's operations, leading to potential compromises of the entire system. Rootkits often employ this technique, making it a critical threat to detect and address.</li> <li>Properties:</li> <li>Severity: 3 (Moderate to high threat level)</li> <li>Category: defense-evasion</li> <li>Technique: Rootkit</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--0f20e3cb-245b-4a61-8a91-2d93f7cb0e9b</li> <li>external_id: T1014</li> </ul>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#findings","title":"Findings","text":"<p>Upon discovering a malevolent hook in the syscall table, the signature generates a <code>Finding</code> that houses:</p> <ul> <li>SigMetadata: This is a set of metadata outlining the nature and potential threat of the detected issue.</li> <li>Event: A comprehensive record of the event that spurred the detection, offering a granular look at the problem.</li> <li>Data: This highlights the specific syscalls that have been manipulated, giving insights into the nature and extent of the threat.</li> </ul>"},{"location":"docs/events/builtin/signatures/syscall_table_hooking/#events-used","title":"Events Used","text":"<p>The signature predominantly zeroes in on the event:</p> <ul> <li><code>hooked_syscalls</code>: This event is fired when malicious hooking of the syscall table is detected. The signature parses this event's data to ascertain the degree and nature of the hooking.</li> </ul>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/","title":"System Request Key Configuration Modification Detection","text":""},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#intro","title":"Intro","text":"<p>The <code>SystemRequestKeyConfigModification</code> signature detects modifications to the System Request Key configuration files, which are powerful utilities that allow direct kernel input.</p>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#description","title":"Description","text":"<p>The System Request Key (often abbreviated as SysRq) is a mechanism in the Linux kernel that provides a way to send commands directly to the kernel via key combinations.</p> <p>These combinations allow, among other things, a user to perform various low-level commands regardless of the system's state. Because of its potent capabilities, any unauthorized or suspicious modifications to its configurations could indicate adversarial activity.</p> <p>Specifically, this signature focuses on detecting attempts to modify and activate the System Request Key configuration files located at <code>/proc/sys/kernel/sysrq</code> and <code>/proc/sysrq-trigger</code>.</p>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#purpose","title":"Purpose","text":"<p>The primary objective of this signature is to detect and flag any unauthorized or suspicious modifications to the System Request Key configuration. Such modifications could allow an adversary to immediately shut down or restart a system. Moreover, if combined with read access to kernel logs, it might leak sensitive host-related information, enabling potential container escape tactics.</p>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#metadata","title":"Metadata","text":"<ul> <li>ID: TRC-1031</li> <li>Version: 1</li> <li>Name: System request key configuration modification</li> <li>EventName: system_request_key_mod</li> <li>Description: The signature detects modifications to the System Request Key configuration files. Unauthorized or malicious alterations to these files can grant the ability to shut down or restart systems and disclose host-related data that can potentially be used for container escapes.</li> <li>Properties:</li> <li>Severity: 3 (Moderate threat level)</li> <li>Category: privilege-escalation</li> <li>Technique: Escape to Host</li> <li>Kubernetes_Technique: N/A</li> <li>id: attack-pattern--4a5b7ade-8bb5-4853-84ed-23f262002665</li> <li>external_id: T1611</li> </ul>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#findings","title":"Findings","text":"<p>Upon detecting a potential threat, the signature returns a <code>Finding</code> data structure, comprising:</p> <ul> <li>SigMetadata: Metadata about the threat based on the signature.</li> <li>Event: Details of the event that caused the signature to trigger.</li> <li>Data: Currently set to <code>nil</code>, meaning no extra information is provided in this structure.</li> </ul>"},{"location":"docs/events/builtin/signatures/system_request_key_config_modification/#events-used","title":"Events Used","text":"<p>The signature is contingent on the following events:</p> <ul> <li><code>security_file_open</code>: Activated when a file is accessed. The signature examines the accessed file's pathname and flags to determine if the System Request Key configuration files are being modified.</li> </ul>"},{"location":"docs/events/builtin/syscalls/","title":"Syscalls","text":"<p>Tracee supports tracing all Linux system calls. To trace a system call, use it's name as the event name. For example, to trace the <code>open</code> system call, use the <code>open</code> event name. The arguments of the system call will be available as event arguments. For more information about system calls, please consult the man pages.</p>"},{"location":"docs/events/builtin/syscalls/accept/","title":"<code>accept()</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#intro","title":"Intro","text":"<p>The <code>accept()</code> syscall returns connected file descriptors for a given listening socket.</p>"},{"location":"docs/events/builtin/syscalls/accept/#description","title":"Description","text":"<p>The <code>accept()</code> syscall enables a process to perform a passive connection, or accept, with a remote peer. The <code>accept()</code> syscall is the accept half of a two-way communication link. It is typically used when a server provides a service over a network. The <code>accept()</code> syscall will block until a connection is accepted. </p> <p>When <code>accept()</code> is successful, it will create a new file descriptor and store the address of the connecting peer in the sockaddr structure provided by the user. </p> <p>There are a few edge cases where <code>accept()</code> might fail and return an error. For example, if the program does not have permission to create a new socket descriptor, or the remote peer does not support the protocol in question, <code>accept()</code> may fail. There is also a chance of a race condition in the <code>accept()</code> syscall if it is used without the <code>O_NONBLOCK</code> flag. In a race condition, <code>accept()</code> may return a newly created descriptor, but the remote connection could be dropped before the connection is actually made. </p>"},{"location":"docs/events/builtin/syscalls/accept/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>: <code>int</code> - Descriptor of the listening socket.</li> <li><code>addr</code>: <code>struct sockaddr*</code>[<code>U</code>] - Structure used to store the address of the connecting peer.</li> <li><code>addrlen</code>: <code>int*</code>[<code>U</code>,<code>OPT</code>] - Size of the sockaddr structure. </li> </ul>"},{"location":"docs/events/builtin/syscalls/accept/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/accept/#sys_accept","title":"<code>sys_accept</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#type","title":"Type","text":"<p>KProbe.</p>"},{"location":"docs/events/builtin/syscalls/accept/#purpose","title":"Purpose","text":"<p>Used for tracing when a process is attempting to accept a connection.</p>"},{"location":"docs/events/builtin/syscalls/accept/#do_accept","title":"<code>do_accept</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#type_1","title":"Type","text":"<p>KRetProbe.</p>"},{"location":"docs/events/builtin/syscalls/accept/#purpose_1","title":"Purpose","text":"<p>Used for tracing the return value of the <code>sys_accept</code> syscall, indicating whether or not the accept syscall was successful. </p>"},{"location":"docs/events/builtin/syscalls/accept/#example-use-case","title":"Example Use Case","text":"<p>Using <code>accept()</code> in a server application to allow incoming connections from remote clients. </p>"},{"location":"docs/events/builtin/syscalls/accept/#issues","title":"Issues","text":"<p><code>accept()</code> is vulnerable to a type of race condition called Time Of Check, Time Of Use (TOCTOU). If <code>accept()</code> is called without the <code>O_NONBLOCK</code> flag, a newly accepted connection descriptor may be returned before the connection is actually made. If the connection is dropped before the connection is made, <code>accept()</code> will return the connection but the user will not be able to use the descriptor.</p>"},{"location":"docs/events/builtin/syscalls/accept/#related-events","title":"Related Events","text":"<p><code>connect()</code> - Used by the clients in order to connect to a server.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/accept4/","title":"accept4","text":""},{"location":"docs/events/builtin/syscalls/accept4/#intro","title":"Intro","text":"<p>accept4 - a system call for accepting incoming connections on a listening socket</p>"},{"location":"docs/events/builtin/syscalls/accept4/#description","title":"Description","text":"<p>The <code>accept4</code> system call is used by a server process to accept incoming connections on a listening socket. It is a variant of the <code>accept</code> system call which has an additional parameter <code>flags</code>, which can be used to control how the connection is created. For example, the <code>SOCK_NONBLOCK</code> flag can be used to ensure that the connection is created in non-blocking mode, to avoid blocking the server process in the event of no available clients. Further flags can also be used to control whether the socket is granted exclusive access to the address, and whether credentials are passed with the connection (using the <code>SOCK_PASSCRED</code> flag).</p> <p>The <code>sockfd</code> parameter is a file descriptor for the listening socket. The <code>addr</code> and <code>addrlen</code> parameters point to a <code>sockaddr</code> structure and an <code>int</code> respectively, and are used to store information about the client connection. Once accepted, the address and length of the connection are copied to these structures. The <code>flags</code> parameter is used to control the type of socket that is created, as described above.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the listening socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[K,U] - pointer to <code>sockaddr</code> to store the details of the connection.</li> <li><code>addrlen</code>:<code>int*</code>[K,U] - pointer to an integer to store the length of the <code>struct sockaddr</code> associated with the connection.</li> <li><code>flags</code>:<code>int</code>[K] - flags to control the type of socket that is created (e.g. <code>SOCK_NONBLOCK</code>), passed as a bitmask.</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/accept4/#sock_allowsockopt","title":"sock_allowsockopt","text":""},{"location":"docs/events/builtin/syscalls/accept4/#type","title":"Type","text":"<p>Tracepoint + Kprobe</p>"},{"location":"docs/events/builtin/syscalls/accept4/#purpose","title":"Purpose","text":"<p>To monitor the flags parameter of the accept4 syscall</p>"},{"location":"docs/events/builtin/syscalls/accept4/#example-use-case","title":"Example Use Case","text":"<p>An example use case would be a web server that needs to listen for incoming connections, but doesn't want to block waiting for them. By using the <code>SOCK_NONBLOCK</code> flag, the server process can instruct the kernel to create the socket in non-blocking mode and return immediately, even if there are no connections available.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#issues","title":"Issues","text":"<p>One potential issue is with the use of TOCTOU (Time-of-Check-Time-of-Use) attacks. These can occur when the flags parameter is passed with a value that changes between the time of check and the time of use. Therefore, care should be taken to ensure that the parameter is locked before the syscall is invoked.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#related-events","title":"Related Events","text":"<ul> <li><code>bind</code> - used to bind the sockets to an address</li> <li><code>listen</code> - used to begin listening for incoming connections</li> <li><code>select</code> - used to wait for incoming connections in non-blocking mode</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/access/","title":"access","text":""},{"location":"docs/events/builtin/syscalls/access/#intro","title":"Intro","text":"<p>access - check user's permissions to a file</p>"},{"location":"docs/events/builtin/syscalls/access/#description","title":"Description","text":"<p>The access system call checks if the calling process can access the file pathname. It takes in two parameters: the pathname and the mode of the access being checked. It returns 0 if the user has permission and -1 if the user does not have permission. The access mode argument specifies which permissions should be checked. The different modes are defined in <code>&lt;fcntl.h&gt;</code>. </p> <p>The access system call can be used to check access permissions prior to attempting to open a file or directory. This provides an additional layer of security because it can be used to minimize the potential of TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/access/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>: <code>const char*</code>[KU] - pathname of the file being accessed</li> <li><code>mode</code>: <code>int</code>[K] - mode of access being tested, defined in <code>fcntl.h</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/access/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/access/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/access/#sys_access","title":"sys_access","text":""},{"location":"docs/events/builtin/syscalls/access/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/access/#purpose","title":"Purpose","text":"<p>To trace access system call.</p>"},{"location":"docs/events/builtin/syscalls/access/#example-use-case","title":"Example Use Case","text":"<p>The access system call could be used in order to implement a security policy in an application. For example, an application may require certain users to be members of a specific group in order to access certain files. The application could call access prior to attempting to access or open a file in order to check if the user has permission to access the requested file. </p>"},{"location":"docs/events/builtin/syscalls/access/#issues","title":"Issues","text":"<p>The access system call is vulnerable to TOCTOU (time of check, time of use) attacks. That is, the permission of the requested file can change between the time it was checked and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/access/#related-events","title":"Related Events","text":"<ul> <li>open - to open the file if the user has permission</li> <li>stat - to query file status, including the owner and group of the file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/acct/","title":"acct()","text":""},{"location":"docs/events/builtin/syscalls/acct/#intro","title":"Intro","text":"<p>acct() - toggle process accounting on or off</p>"},{"location":"docs/events/builtin/syscalls/acct/#description","title":"Description","text":"<p>The acct() system call is used to enable or disable process accounting. It is typically used to start or stop the system writing process accounting information to the file specified in the \"filename\" argument. Process accounting information is stored in a file so that the activities of users on the system can be monitored.</p> <p>Process accounting can be activated by setting the kernel parameter <code>accounting</code> to 1. The kernel will begin writing accounting information to the file specified in the \"filename\" argument when acct() is called. When process accounting is enabled, all processes that terminate have an accounting record written to the accounting file. Accounting records can be read with the acct() system call.</p> <p>Process accounting can be disabled by calling acct() with a null pointer in the \"filename\" argument.</p>"},{"location":"docs/events/builtin/syscalls/acct/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>const char*</code>[K] - pathname of the accounting file to be written. If a null pointer is passed, process accounting will be disabled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/acct/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/acct/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/acct/#sys_acct","title":"sys_acct","text":""},{"location":"docs/events/builtin/syscalls/acct/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/acct/#purpose","title":"Purpose","text":"<p>To monitor process accounting activity.</p>"},{"location":"docs/events/builtin/syscalls/acct/#example-use-case","title":"Example Use Case","text":"<p>An application like \"process_tracker\" that needs to monitor user activities on a system and keep track of when each process is started and when it is terminated. The acct() system call can be used to enable process accounting and record the process accounting information in the specified file.</p>"},{"location":"docs/events/builtin/syscalls/acct/#issues","title":"Issues","text":"<p>If the accounting file becomes too large, the kernel may stop writing new records to it. This can be mitigated by periodically rotating the accounting file by calling mv on it and creating a new accounting file.</p>"},{"location":"docs/events/builtin/syscalls/acct/#related-events","title":"Related Events","text":"<ul> <li>execve() - used to execute or start a process which may be recorded in the accounting file. </li> <li>exit() - used to terminate a process which may be recorded in the accounting file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/add_key/","title":"add_key","text":""},{"location":"docs/events/builtin/syscalls/add_key/#intro","title":"Intro","text":"<p>add_key - adds a key to the kernel's key management facility</p>"},{"location":"docs/events/builtin/syscalls/add_key/#description","title":"Description","text":"<p>add_key is a system call that adds a new key to the kernel's key management facility. The purpose of the system call is to make it easier to use secure symmetric encryption without having to manage and/or store the encryption keys in plaintext. The system call can be used to add public and private keys, as well as binary blobs, as key payloads. After the key is added to the kernel, the key is assigned a unique serial number and stored in secure memory for use.</p> <p>There are some drawbacks to using add_key. Firstly, the size of the payload being added must be less than 768 bytes. Secondly, there is a maximum of 58720 keys allowed in the kernel at any one time, so each key must be manually removed when no longer needed. Additionally, there is a limit of 32 processes that can concurrently access the same keyring.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>const char*</code>[K] - string identifying the type of the key.</li> <li><code>description</code>:<code>const char*</code>[K] - readable string specifying the purpose of the key.</li> <li><code>payload</code>:<code>const void*</code>[K] - the key payload, with a size limit of 768 bytes.</li> <li><code>plen</code>:<code>size_t</code>[K] - the size length of the key payload.</li> <li><code>keyring</code>:<code>key_serial_t</code>[U] - the ID of the keyring where the key will be stored. If set to -1, the default keyring will be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/add_key/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/add_key/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/add_key/#do_add_key","title":"do_add_key","text":""},{"location":"docs/events/builtin/syscalls/add_key/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/add_key/#purpose","title":"Purpose","text":"<p>To trace usage of the add_key syscall.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#key_alloc","title":"key_alloc","text":""},{"location":"docs/events/builtin/syscalls/add_key/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/add_key/#purpose_1","title":"Purpose","text":"<p>To gather information about allocated keys.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#example-use-case","title":"Example Use Case","text":"<p>add_key can be used for securely storing passwords. For example, an application may have a \"forgot password\" feature, which would require the encryption of a password-reset key. Using add_key, this process can be securely done without ever having to store the key in plaintext.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#issues","title":"Issues","text":"<p>The maximum size of the key payload is limited to 768 bytes. Additionally, the maximum amount of keys allowed in the kernel is limited to 58720, so any key that is no longer needed must be manually removed.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#related-events","title":"Related Events","text":"<ul> <li>keyctl</li> <li>keyctl_assume_authority</li> <li>request_key</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/","title":"adjtimex","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#intro","title":"Intro","text":"<p>adjtimex - adjust timekeeping variables with the aim of improving accuracy</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#description","title":"Description","text":"<p>The <code>adjtimex</code> syscall is used to make adjustments to system clock variables. This syscall provides access to the Linux kernel time variables, making it possible to adjust the kernel\u2019s clock frequency and phase, as well as the system time offset. </p> <p>When using <code>adjtimex</code>, it is important to remember that this syscall can modify important system variables. It may lead to side effects like clock desynchronization or even time rollbacks, making it important to be aware of the adjustments being performed to the system\u2019s time variables.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>: <code>struct timex*</code>[K] - a pointer to a <code>struct timex</code>. This argument contains the adjtimex settings. </li> </ul>"},{"location":"docs/events/builtin/syscalls/adjtimex/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/adjtimex/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#adjtimex_1","title":"adjtimex","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#type","title":"Type","text":"<p>Kprobes + tracepoints</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#purpose","title":"Purpose","text":"<p>Monitoring and modifying system time variables.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#example-use-case","title":"Example Use Case","text":"<p>The <code>adjtimex</code> system call can be used to adjust the system's clock offset, frequency and phase. This can be used to provide better time synchronization if there is an issue with current system time accuracy.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#issues","title":"Issues","text":"<p>It can lead to unexpected behavior if used incorrectly (e.g. time rollbacks).</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#related-events","title":"Related Events","text":"<ul> <li>settimeofday </li> <li>clock_settime </li> <li>do_adjtimex</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/afs/","title":"afs","text":""},{"location":"docs/events/builtin/syscalls/afs/#intro","title":"Intro","text":"<p>afs - System call for completely deleting entire directories of files.</p>"},{"location":"docs/events/builtin/syscalls/afs/#description","title":"Description","text":"<p>The afs syscall is used to recursively delete all files and folders in a  given directory. It is a non-atomic operation; each file and folder is  checked and deleted individually. As this type of operation can be  slow and may pose some security risks, it is a somewhat infrequently  used system call. </p> <p>One of the main advantages of using this function is that it is not  affected by symlinks, unlike other functions like <code>rm</code> or <code>unlink</code>.  However, this also means that afs will not detect broken symlinks,  so directories that contain broken symlinks may not be deleted in  their entirety. </p>"},{"location":"docs/events/builtin/syscalls/afs/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>string</code>[K, U] - The path to the directory to be deleted. Must be a string relative or absolute path. </li> </ul>"},{"location":"docs/events/builtin/syscalls/afs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/afs/#sys_afs","title":"sys_afs","text":""},{"location":"docs/events/builtin/syscalls/afs/#type","title":"Type","text":"<p>Kprobe + Tracepoints. </p>"},{"location":"docs/events/builtin/syscalls/afs/#purpose","title":"Purpose","text":"<p>To track the system call usage of afs. </p>"},{"location":"docs/events/builtin/syscalls/afs/#example-use-case","title":"Example Use Case","text":"<p>This system call is useful for applications that need to clean up  after themselves, to ensure that no files or folders remain on the  system after it finishes running. This can be useful for applications  that need to leave no trace of their execution. </p>"},{"location":"docs/events/builtin/syscalls/afs/#issues","title":"Issues","text":"<p>The main issue with afs is that, because of its recursive nature, it  has the potential to cause serious system issues if used incorrectly.  Therefore, caution should be taken when using this function. </p>"},{"location":"docs/events/builtin/syscalls/afs/#related-events","title":"Related Events","text":"<ul> <li>rm - System call used to remove individual files and directories. </li> <li>unlink - System call used to delete symbolic links.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/","title":"afs_syscall","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#intro","title":"Intro","text":"<p><code>afs_syscall</code> - Handler for the <code>sys_afs</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#description","title":"Description","text":"<p><code>afs_syscall</code> is a handler for the <code>sys_afs</code> system call, which is used to process AFS requests. The requests are contributed by kernel modules with the help of an ioctl to the AFS device driver. Requests include operations such as file read/write, access control and other complex operations.</p> <p>Using <code>afs_syscall</code> allows AFS requests to be processed by the system in a secure and consistent way. Additionally, requests can be safely and easily marshalled between user and kernel space. </p> <p>However, performance can be an issue as there is some overhead in the marshalling process. Since operations can take a long time to complete, potential race conditions or other security issues can occur if care is not taken.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:unsigned int[K] - Type of command being requested.</li> <li><code>pn</code>:struct pt_regs*[K, U] - Pointer to task's registers.</li> <li><code>arg1</code>-<code>arg4</code>:unsigned long[K,U] - Arguments to the command.</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#do_sys_afs","title":"do_sys_afs","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#purpose","title":"Purpose","text":"<p>The do_sys_afs function is hooked in order to instrument the syscall handlers. This informs the tracing system whenever a syscall is executed, so the tracing system can collect information about the syscall.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#example-use-case","title":"Example Use Case","text":"<p>For example, the AFS tracing system could be set up with <code>afs_syscall</code> so that whenever an AFS request is made, the arguments, timestamps and other relevant information can be collected. This information can be used to analyse system behaviour and observe the impact of AFS requests.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#issues","title":"Issues","text":"<p><code>afs_syscall</code> requires that the arguments to the request are correctly marshalled between user and kernel space. If the arguments are malformed or invalid, it could potentially lead to a system crash or other unpredictable behaviour.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#related-events","title":"Related Events","text":"<ul> <li>sys_afs</li> <li>ioctl</li> <li>do_sys_open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/alarm/","title":"alarm","text":""},{"location":"docs/events/builtin/syscalls/alarm/#intro","title":"Intro","text":"<p>alarm - set an alarm to be delivered at a specified time</p>"},{"location":"docs/events/builtin/syscalls/alarm/#description","title":"Description","text":"<p>alarm sets an alarm to deliver the signal SIGALRM to the calling process in seconds seconds. If seconds is zero, any currently pending alarms are cancelled.</p> <p>Since the delivery of the signal may be delayed, this function should be used to address any problems related to processes that require a specific timing. However, it should be used with caution, since relying on exact timings can be dangerous and negatively affect the performance of a system if not configured properly.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#arguments","title":"Arguments","text":"<ul> <li><code>seconds</code>:<code>unsigned int</code>[U] - the number of seconds until the alarm is fired. </li> </ul>"},{"location":"docs/events/builtin/syscalls/alarm/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/alarm/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/alarm/#sys_alarm","title":"sys_alarm","text":""},{"location":"docs/events/builtin/syscalls/alarm/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/alarm/#purpose","title":"Purpose","text":"<p>The sys_alarm function is used to hook to obtain the time set for alarm delivery.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor applications that require precise timing, as well as for debugging and performance evaluation of applications and services that might be affected by long delay alarms.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#issues","title":"Issues","text":"<p>The alarm could be interrupted, depending on the system load, so the alarm time might not be delivered precisely on the set time.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#related-events","title":"Related Events","text":"<ul> <li>SIGCHLD - signal is triggered when a child process of the calling process terminates.</li> <li>SIGALRM - signal is triggered when an alarm set by the calling process completes.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/","title":"arch_prctl","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#intro","title":"Intro","text":"<p><code>arch_prctl</code> - sets architecture-specific thread state</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#description","title":"Description","text":"<p>The <code>arch_prctl</code> syscall sets architecture-specific thread state. It allows a process to set a specific architecture feature, such as a floating point unit, from within user-space code. It is particularly useful in cases when a process needs to change the architectural state of a thread for testing purposes, for example. When setting the architectural state the <code>addr</code> argument can optionally be set to provide a pointer to user space memory for getting the removed state. </p> <p>One of the primary drawbacks of <code>arch_prctl</code> is that it is vulnerable to the Time-of-check-to-time-of-use (TOCTOU) race condition, which means that it's possible for the value of <code>addr</code> to change between the invocation of the check and the use of the address. It is therefore important to use <code>arch_prctl</code> very carefully and to take into account the risk of TOCTOU when using this syscall.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - defines the operation to be performed with <code>arch_prctl</code>.</li> <li><code>addr</code>:<code>unsigned long</code>[K] - address of the state information being set or removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#do_arch_prctl","title":"<code>do_arch_prctl</code>","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#purpose","title":"Purpose","text":"<p>Hooked for observability - to measure the latency of the syscall execution, to emit tracing events, to report syscall call patterns and per-process activity.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>arch_prctl</code> syscall can be used to change the architecture-specific states in a thread, such as the floating point unit. It can be used for testing purposes or for providing an alternative to a full system reboot in cases where only a few threads need to be stateful.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#issues","title":"Issues","text":"<p>The <code>arch_prctl</code> syscall is vulnerable to the TOCTOU race condition, which means that it is possible for the values of the <code>addr</code> argument to change between the invoked check and the use of the address.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#related-events","title":"Related Events","text":"<p><code>pthread_arch_prctl</code> - sets thread-specific architecture-specific state information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/","title":"bdflush","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#intro","title":"Intro","text":"<p>bdflush - System call that schedules kernel tasks related to buffer flushing.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#description","title":"Description","text":"<p>The bdflush system call works by writing an argument in to the /proc/sys/vm/bdflush file. Each argument value is taken as an instruction for the bdflush daemon to execute specific buffer-related tasks. This system call responds to pressure from an mmapped buffer pool, not just from the files being written to disk. This can improve performance when dealing with heavy write I/O operations.</p> <p>However, bdflush system calls should be used with care. It can come with a great performance boost, but can also lead to much higher memory usage and potential latency spikes in subsequent system calls.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#arguments","title":"Arguments","text":"<ul> <li><code>func</code>:<code>int</code>[K] - The parameter value is used by the bdflush daemon to determine what to do.</li> <li><code>buffer_pages</code>:<code>unsigned int</code>[K] - Number of pages to write-back per task.</li> <li><code>read_pages</code>: <code>unsigned int</code>[K] - Number of pages to clean per task.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bdflush/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bdflush/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#sys_dobdflush","title":"sys_dobdflush","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#purpose","title":"Purpose","text":"<p>To collect information about bdflush system calls.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#example-use-case","title":"Example Use Case","text":"<p>The bdflush system call can be used when dealing with high-throughput write I/O operations, such as file transfers. This system call can be used to bring the performance back in line with what is expected.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#issues","title":"Issues","text":"<p>The bdflush system call can lead to excessive memory usage and latency spikes in subsequent system calls, which can reduce performance even further.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#related-events","title":"Related Events","text":"<ul> <li>open()</li> <li>read()</li> <li>write()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bind/","title":"bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#intro","title":"Intro","text":"<p>bind - assigns address name to a socket</p>"},{"location":"docs/events/builtin/syscalls/bind/#description","title":"Description","text":"<p>The bind() system call assigns the address specified by addr to the socket  referred to by the file descriptor sockfd. For AF_INET sockets, the bind()  system call binds addr to the address whose port number is specified in addr  and whose Internet address is any address. Only one process may bind to a specific port. </p> <p>The  addrlen  argument  specifies the size, in bytes, of the address structure pointed to by addr. For more information about addrlen requirements for  different address families, refer to the manual page for addrlen. </p> <p>There might be cases where bind() could produce an error due to limits concerning the number of port numbers from 0 to  1023 that are reserved for internal use  and privileged operations (e.g. by root processes).</p>"},{"location":"docs/events/builtin/syscalls/bind/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - file descriptor used in the bind system call. </li> <li><code>addr</code>:<code>struct sockaddr*</code>[KU] - pointer to a structure of sockaddr for the  address that should be bound. </li> <li><code>addrlen</code>:<code>int</code>[K] OPT - length of the sockaddr structure that is pointed by  addr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bind/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/bind/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bind/#sys_bind","title":"sys_bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/bind/#purpose","title":"Purpose","text":"<p>To track bind\u2019s execution from kernel space.</p>"},{"location":"docs/events/builtin/syscalls/bind/#sock_bind","title":"sock_bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/bind/#purpose_1","title":"Purpose","text":"<p>To track bind\u2019s execution from user space.</p>"},{"location":"docs/events/builtin/syscalls/bind/#example-use-case","title":"Example Use Case","text":"<p>The bind() system call is useful for limiting the scope of applications running  on the same host. By using the bind() system call, different applications can  explicitly bind to a specific IP address and assign certain port numbers, so  that two applications on the same host are not using the same port number.</p>"},{"location":"docs/events/builtin/syscalls/bind/#issues","title":"Issues","text":"<p>The bind() system call can only bind to a specific port number once. If the same  port number is asked to be bound to more than one application, it can produce an  error and therefore result in undesired behavior. </p>"},{"location":"docs/events/builtin/syscalls/bind/#related-events","title":"Related Events","text":"<p>connect(), listen(), accept(), sendto()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bpf/","title":"bpf","text":""},{"location":"docs/events/builtin/syscalls/bpf/#intro","title":"Intro","text":"<p>bpf - installs or removes a filter program</p>"},{"location":"docs/events/builtin/syscalls/bpf/#description","title":"Description","text":"<p>The bpf() system call is used to transfer a filter program to the kernel and/or query kernel-managed filter programs. It has capability to extend the kernel by allowing user-defined programs to be attached to probe points specified with the bpf_attach context(8) function. </p> <p>It can perform many actions such as attaching a filter to sockets, attaching an endpoint-agnostic program, attaching a tracking program to kprobes, or creating a seccomp policy. Depending on the command argument supplied, other effects may be observed.</p> <p>There are some edge cases and drawbacks related to using bpf. The kernel can reject user-defined programs that are found to be invalid according to certain criteria. Additionally, an overly complex program may suffer from performance penalties.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - command to execute, determines what other arguments are used. </li> <li><code>attr</code>:<code>union bpf_attr*</code>[K] - points to a structure of type bpf_attr. This must be present in all bpf commands and specifies attributes used by kernels to interpret the bpf program </li> <li><code>size</code>:<code>unsigned int</code>[K] - maximum size of <code>attr</code> in bytes</li> </ul>"},{"location":"docs/events/builtin/syscalls/bpf/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bpf/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bpf/#bpf_1","title":"bpf","text":""},{"location":"docs/events/builtin/syscalls/bpf/#type","title":"Type","text":"<p>kprobe + tracepoint</p>"},{"location":"docs/events/builtin/syscalls/bpf/#purpose","title":"Purpose","text":"<p>This function is hooked to allow user-defined programs to be attached to probe points specified with the bpf_attach() context.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#example-use-case","title":"Example Use Case","text":"<p>A use case for bpf() is to examine the output data from database applications. To do this, a user can write a program that monitors database connections to determine the amount of data being sent and received for each connection. This data can then be used to identify and diagnose database performance bottlenecks.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#issues","title":"Issues","text":"<p>The bpf() system call only works on Linux kernels, so it is not available on other operating systems. </p>"},{"location":"docs/events/builtin/syscalls/bpf/#related-events","title":"Related Events","text":"<ul> <li>bpf_attach()</li> <li>bpf_prog_load()</li> <li>seccomp(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/break/","title":"<code>break</code>","text":""},{"location":"docs/events/builtin/syscalls/break/#intro","title":"Intro","text":"<p><code>break</code> - allows a process to set memory protection for a given address range.</p>"},{"location":"docs/events/builtin/syscalls/break/#description","title":"Description","text":"<p>The <code>break</code> system call is used by a process to set specific memory protection of a given address range within its virtual address space. It can be used to mark memory as non-executable, readable, writable, or any combination of the three. The changes in protection are done atomically and, as a result, are always performed as a whole. It is an essential part of modern operating system memory protection and is used to ensure the memory integrity of running processes.</p> <p>The <code>break</code> system call may have the following drawbacks or edge cases: * It must be called with the start and end boundaries of the region to be altered, so it can be difficult to use this system call with regions that span multiple memory pages. * If an area of memory is marked as non-executable, the processor will try and verify that this isn't the case for all instructions within the region; if it is, the instruction will be disallowed. * It does not differentiate between memory pages, so shared and private memory can be affected by a single call to <code>break</code>.</p>"},{"location":"docs/events/builtin/syscalls/break/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void *</code> - start address of the region to be set. </li> <li><code>len</code>: <code>unsigned long</code> - the number of bytes in the memory area to be changed. </li> <li><code>type</code>: <code>int</code> [K | U | TOCTOU | OPT] - the type of memory protection to be implemented. The possible types are <code>PROT_READ = 1</code>, <code>PROT_WRITE = 2</code> <code>PROT_EXEC = 4</code> <code>PROT_NONE = 0</code> or any combination of these.</li> </ul>"},{"location":"docs/events/builtin/syscalls/break/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/break/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/break/#do_mremap","title":"do_mremap()","text":""},{"location":"docs/events/builtin/syscalls/break/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/break/#purpose","title":"Purpose","text":"<p>To detect calls to <code>break</code> to change the memory protection of a given region.</p>"},{"location":"docs/events/builtin/syscalls/break/#example-use-case","title":"Example Use Case","text":"<p>The <code>break</code> system call can be used to mark memory as non-executable to prevent malicious code injection or execution of unsigned code.</p>"},{"location":"docs/events/builtin/syscalls/break/#issues","title":"Issues","text":"<p>The <code>break</code> system call is vulnerable to TOCTOU (time of check, time of use), as the memory may be changed after the call to the <code>break</code> system call and before the protection can be applied.</p>"},{"location":"docs/events/builtin/syscalls/break/#related-events","title":"Related Events","text":"<p><code>mmap</code>, <code>mprotect</code>, <code>mremap</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/brk/","title":"brk","text":""},{"location":"docs/events/builtin/syscalls/brk/#intro","title":"Intro","text":"<p>brk -  manipulates the calling process's data segment.</p>"},{"location":"docs/events/builtin/syscalls/brk/#description","title":"Description","text":"<p>The brk() system call changes the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.</p> <p>The functionality of the brk() system call is provided by libc, which implements brk() by calling the sbrk() system call. </p>"},{"location":"docs/events/builtin/syscalls/brk/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - pointer to the requested address at which the program break would be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/brk/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/brk/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/brk/#sbrk","title":"sbrk","text":""},{"location":"docs/events/builtin/syscalls/brk/#type","title":"Type","text":"<p>Kprobe+Uprobe</p>"},{"location":"docs/events/builtin/syscalls/brk/#purpose","title":"Purpose","text":"<p>To hook this function to track when the program break is changed.</p>"},{"location":"docs/events/builtin/syscalls/brk/#example-use-case","title":"Example Use Case","text":"<p>brk() is used by programs to manage their own memory usage. This is particularly useful when dealing with dynamic memory allocation.</p>"},{"location":"docs/events/builtin/syscalls/brk/#issues","title":"Issues","text":"<p>There is no guarantee that brk() will successfully allocate memory. Additionally, it can lead to memory fragmentation if memory is requested in large chunks rather than smaller ones.</p>"},{"location":"docs/events/builtin/syscalls/brk/#related-events","title":"Related Events","text":"<p>malloc - for allocating memory in chunks larger than the page size.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/capget/","title":"capget","text":""},{"location":"docs/events/builtin/syscalls/capget/#intro","title":"Intro","text":"<p>capget - Retrieve system capabilities</p>"},{"location":"docs/events/builtin/syscalls/capget/#description","title":"Description","text":"<p>The capget() system call, which retrieves the current capabilities of a certain process or process group. It takes two arguments, a pointer to a <code>cap_user_headers_t</code> structure containing information about the requested capabilities, and a pointer to a <code>cap_user_data_t</code> structure containing an array of capability numbers. The system call then fills in these structures to contain the requested capabilities.</p> <p>There are some drawbacks and edge-cases when using this system call. First, the  requested capabilities must be in range of the capabilities supported by the operating system. Second, if the request is for a process group and the process group doesn't exist, capget() fails with an error code. Finally, not all systems support all of the capabilities that capget() can retrieve.</p>"},{"location":"docs/events/builtin/syscalls/capget/#arguments","title":"Arguments","text":"<ul> <li><code>hdrp</code>: <code>cap_user_header_t</code>[K] - Pointer to a header containing the requested capability type and data length.</li> <li><code>datap</code>: <code>cap_user_data_t</code>[K] - Pointer to an array of one or more capability numbers.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/capget/#capget_1","title":"<code>capget</code>","text":""},{"location":"docs/events/builtin/syscalls/capget/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/capget/#purpose","title":"Purpose","text":"<p>These probes are used to capture system calls when they enter and exit the kernel.</p>"},{"location":"docs/events/builtin/syscalls/capget/#example-use-case","title":"Example Use Case","text":"<p>For example, a security administrator may use capget() to query the current system capabilities of a certain process or process group in order to audit their system configuration. </p>"},{"location":"docs/events/builtin/syscalls/capget/#issues","title":"Issues","text":"<p>Currently, there is no way to retrieve multiple sets of capabilities within one capget() system call.</p>"},{"location":"docs/events/builtin/syscalls/capget/#related-events","title":"Related Events","text":"<ul> <li>capset() - Set system capabilities for process or process group</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/capset/","title":"capset","text":""},{"location":"docs/events/builtin/syscalls/capset/#intro","title":"Intro","text":"<p>capset - dynamically change user's and/or process's capability sets</p>"},{"location":"docs/events/builtin/syscalls/capset/#description","title":"Description","text":"<p>The capset() system call is used to set the user-space capability sets of the current process or of a specified process, as specified in the arguments. cap_user_header_t structure describes the layout of the actual capability sets. It consists of an integer, specifying the version of the structure and an integer, specifying the length of the data that follows. The cap_user_data_t structure describes the capability sets of a given process.</p> <p>The capset() system call can be used to modify the process's current capability sets or to set the capability sets of a specified process, depending on which of the arguments are given. The capset() system call also allows setting flags, if the process is root, to indicate if the capability sets should be inherited by the child processes.</p> <p>There are some drawbacks and advantages of using the capset() system call. The main advantage is that it allows a process to change the set of  capabilities it has at runtime, allowing for higher level of security and stability. On the other hand, it can be susceptible to malicious users of the system, as they can set the capability sets to a different  state than they should be.</p>"},{"location":"docs/events/builtin/syscalls/capset/#arguments","title":"Arguments","text":"<ul> <li><code>hdrp</code>:<code>cap_user_header_t</code>[KU] - pointer to a data structure describing the layout of the capability sets of the process. </li> <li><code>datap</code>:<code>const cap_user_data_t</code>[KU] - pointer to a data structure  describing the capability sets of the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capset/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/capset/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/capset/#sys_capset","title":"sys_capset","text":""},{"location":"docs/events/builtin/syscalls/capset/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/capset/#purpose","title":"Purpose","text":"<p>To detect changes to process or threads' capability sets.</p>"},{"location":"docs/events/builtin/syscalls/capset/#uprobes","title":"uprobes","text":""},{"location":"docs/events/builtin/syscalls/capset/#type_1","title":"Type","text":"<p>Uprobes</p>"},{"location":"docs/events/builtin/syscalls/capset/#purpose_1","title":"Purpose","text":"<p>To detect if userspace execution attempts to change a process's capability sets.</p>"},{"location":"docs/events/builtin/syscalls/capset/#example-use-case","title":"Example Use Case","text":"<p>The capset() system call can be useful in order to monitor changes to a  process's capability sets. For example, if a vulnerable process is detected, monitoring its capability sets can help detect if an attacker is attempting to set the capability sets to a different state.</p>"},{"location":"docs/events/builtin/syscalls/capset/#issues","title":"Issues","text":"<p>No significant issues with the system call were found in the manual page.</p>"},{"location":"docs/events/builtin/syscalls/capset/#related-events","title":"Related Events","text":"<ul> <li>get_this_capable() - get the current process's capability sets</li> <li>set_thread_capability() - Associate thread or process with an additional capability set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chdir/","title":"chdir","text":""},{"location":"docs/events/builtin/syscalls/chdir/#intro","title":"Intro","text":"<p>chdir - Change the current working directory</p>"},{"location":"docs/events/builtin/syscalls/chdir/#description","title":"Description","text":"<p>The chdir syscall allows the user to set the current working directory and affects the behavior of subsequent path-related syscals. The argument provided is a const char pointer, which points to the directory to which the working directory should be set. If a path is specified that does not exist or is not accessible, a -1 error code is returned</p>"},{"location":"docs/events/builtin/syscalls/chdir/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:const char* - Pointer to a C-style string that holds the path of the directory to be set as the current working directory</li> </ul>"},{"location":"docs/events/builtin/syscalls/chdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chdir/#sys_chdir","title":"sys_chdir","text":""},{"location":"docs/events/builtin/syscalls/chdir/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/chdir/#purpose","title":"Purpose","text":"<p>To monitor and measure execution of the chdir syscall </p>"},{"location":"docs/events/builtin/syscalls/chdir/#example-use-case","title":"Example Use Case","text":"<p>In some situation, it is useful to monitor chdir syscall invocations and to get various stats regarding their execution. One example of a situation that could benefit from this is separate attempts to change the working directory in a program. This data can be used to better understand the program's behavior or to detect any suspicious activity.</p>"},{"location":"docs/events/builtin/syscalls/chdir/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/chdir/#related-events","title":"Related Events","text":"<ul> <li>execve - Execute program</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chmod/","title":"chmod","text":""},{"location":"docs/events/builtin/syscalls/chmod/#intro","title":"Intro","text":"<p>chmod - change the permissions of a file</p>"},{"location":"docs/events/builtin/syscalls/chmod/#description","title":"Description","text":"<p>The chmod() system call is used to change the permission of a given file path, determined by the parameter <code>pathname</code>. The permission bits of a file are set using the second parameter of the call, <code>mode</code>.</p> <p>The permission are set base on the user or group that own the file, setuid and setgid bit and matrix of user, group and other. For more detail the man page of chmod should be consulted.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U,TOCTOU] - Path to the file whose permission bits are to be changed.</li> <li><code>mode</code>:<code>mode_t</code>[K] - A bitmask of permission bits that will be used to set the new permission.</li> </ul> <pre><code>* `S_ISUID (04000)`: Set-user-ID (sets process effective user ID on `execve(2)`)\n* `S_ISGID (02000)`: Set-group-ID (sets process effective group ID on `execve(2)`; mandatory locking as described in `fcntl(2)`; takes a new file's group from parent directory as described in `chown(2)` and `mkdir(2)`)\n* `S_ISVTX (01000)`: Sticky bit (restricted deletion flag as described in `unlink(2)`)\n* `S_IRUSR (00400)`: Read by owner\n* `S_IWUSR (00200)`: Write by owner\n* `S_IXUSR (00100)`: Execute/search by owner (\"search\" applies for directories, allowing access to entries within)\n* `S_IRGRP (00040)`: Read by group\n* `S_IWGRP (00020)`: Write by group\n* `S_IXGRP (00010)`: Execute/search by group\n* `S_IROTH (00004)`: Read by others\n* `S_IWOTH (00002)`: Write by others\n* `S_IXOTH (00001)`: Execute/search by others\n</code></pre>"},{"location":"docs/events/builtin/syscalls/chmod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/chmod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chmod/#sys_chmod","title":"sys_chmod","text":""},{"location":"docs/events/builtin/syscalls/chmod/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/chmod/#purpose","title":"Purpose","text":"<p>To get a context of the bits which are being used to change the mode and who initiated the call.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#example-use-case","title":"Example Use Case","text":"<p>In order to collect events about every time files permissions inside of a directory are modified, you can use this event.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#issues","title":"Issues","text":"<p>The <code>chmod()</code> system call can be subjected to TOCTOU issues because because a program may check the permissions of a file using the <code>stat</code> system call and, before the program can call <code>chmod</code>, another process changes the permissions of the file OR replaces it with a symlink to a different file.</p> <p>Using <code>fchmodat()</code> deals with the symlink situation, removing the TOCTOU issue in that case.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>fchmodat()</li> <li>chown()</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/chown/","title":"chown","text":""},{"location":"docs/events/builtin/syscalls/chown/#intro","title":"Intro","text":"<p>chown - change the owner and group of a file.</p>"},{"location":"docs/events/builtin/syscalls/chown/#description","title":"Description","text":"<p>The <code>chown()</code> system call is used to change the owner and group of a specified file or directory, determined by the parameter <code>pathname</code>. The new owner and group are specified by the <code>owner</code> and <code>group</code> arguments respectively.</p>"},{"location":"docs/events/builtin/syscalls/chown/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U,TOCTOU] - Path to the file or directory whose owner and group are to be changed.</li> <li><code>owner</code>:<code>uid_t</code>[K] - User identifier of the new owner.</li> <li><code>group</code>:<code>gid_t</code>[K] - Group identifier of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/chown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/chown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chown/#sys_chown","title":"sys_chown","text":""},{"location":"docs/events/builtin/syscalls/chown/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/chown/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>chown()</code> system call is performed, collecting information about the file or directory, and the new owner and group.</p>"},{"location":"docs/events/builtin/syscalls/chown/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in file or directory ownership in a system, especially when dealing with sensitive or critical files and directories.</p>"},{"location":"docs/events/builtin/syscalls/chown/#issues","title":"Issues","text":"<p>The <code>chown()</code> system call can be subjected to TOCTOU issues, where the file or directory specified by <code>pathname</code> could be changed between the time of check and the time of use, leading to potential security risks.</p> <p>Using <code>fchownat()</code> deals with the symlink situation, removing the TOCTOU issue in that case.</p>"},{"location":"docs/events/builtin/syscalls/chown/#related-events","title":"Related Events","text":"<ul> <li>fchown()</li> <li>fchownat()</li> <li>lchown()</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/chown16/","title":"chown16","text":""},{"location":"docs/events/builtin/syscalls/chown16/#intro","title":"Intro","text":"<p>chown16 - System call to change the owner and group of a given file pathname. </p>"},{"location":"docs/events/builtin/syscalls/chown16/#description","title":"Description","text":"<p>The chown16 syscall is a system call used to change the owner and group of a given file pathname. It is an important system call because it allows the owner of a file to control who can read, write and perform operations with said file. Furthermore, it also is important for administrators to be able to set permissions for sensitive costs.</p> <p>There are some edge-cases to be considered when using this syscall, such as race conditions, since changes can be made between the check time and the use time, causing inconsistent results. Furthermore, since old_uid_t and old_gid_t are used as parameters, there can be issues with overflows when dealing with high IDs numbers.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Pathname of the file to change the owner and group.  </li> <li><code>owner</code>:<code>old_uid_t</code>[K] - UID (owner ID) to set as owner of the file.  </li> <li><code>group</code>:<code>old_gid_t</code>[K] - GID (group ID) to set as group of the file.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/chown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> </ul>"},{"location":"docs/events/builtin/syscalls/chown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chown16/#sys_chown16","title":"sys_chown16","text":""},{"location":"docs/events/builtin/syscalls/chown16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#purpose","title":"Purpose","text":"<p>To track every time chown16 is called, as well as its arguments and return value.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#example-use-case","title":"Example Use Case","text":"<p>A system administrator can use chown16 in order to give access to a group of users to a restricted file, by setting a given group or owner for it.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#issues","title":"Issues","text":"<p>There is a vulnerability known as TOCTOU (time-of-check to time-of-use), which can cause a race condition allowing execution of malicious code.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#related-events","title":"Related Events","text":"<ul> <li>chown - similar system call, but with 32-bit UID and GID parameters.</li> <li>fchown - system call to change the owner and group of a given file descriptor.</li> <li>lchown - system call to change the owner and group of a given symbolic link pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chroot/","title":"chroot","text":""},{"location":"docs/events/builtin/syscalls/chroot/#intro","title":"Intro","text":"<p>chroot() - changes the root directory of a process</p>"},{"location":"docs/events/builtin/syscalls/chroot/#description","title":"Description","text":"<p>The chroot() system call changes the root directory of the calling process to the path specified in the path argument. This directory will be the new root directory for the calling process and all its children. The chroot() system call restricts the ability of a process to access files outside the new root directory. The process must have root privileges in order to  successfully call chroot().</p> <p>Edge cases/drawbacks:  * This call should only be used under extreme circumstances since it is not reversible.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - path of the new root directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/chroot/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chroot/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chroot/#execve","title":"execve","text":""},{"location":"docs/events/builtin/syscalls/chroot/#type","title":"Type","text":"<p>kprobe.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#purpose","title":"Purpose","text":"<p>Hooked to detect a process that has been successfully chrooted.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#example-use-case","title":"Example Use Case","text":"<p>It can be used to detect malicious activity when a process inside the system is attempting to break out of its jailed environment.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#issues","title":"Issues","text":"<p>The chroot() syscall should be used with extreme caution since it is not reversible and can be easily misused.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#related-events","title":"Related Events","text":"<ul> <li>chdir - changes the current working directory of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/","title":"clock_adjtime","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#intro","title":"Intro","text":"<p><code>clock_adjtime()</code> - set, get and adjust a clock's offset and frequency</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#description","title":"Description","text":"<p>The clock_adjtime() system call sets, gets and adjusts (i.e. corrects) the time or frequency of the clock designated by clock_id. buf is a pointer to a <code>struct timex</code> data structure which is used to obtain further details about the operation to be performed by clock_adjtime.</p> <p>The main purpose of this system call is to allow an applications to modify the offset and/or frequency of a time source/clock to ensure time-stamp accuracy, as well as to compensate for any skews in the clocks' frequency caused by environmental factors such as temperature variations. Furthermore, it allows the clock offset of a given clock to be set, directly, to a given value.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#arguments","title":"Arguments","text":"<ul> <li><code>clk_id</code>: <code>const clockid_t</code> - Identifies the clock to be affected by the call. There are a number of predefined clocks which can exist in the system, each given a specific clock ID, and further application-defined clocks can be created with <code>timer_create()</code>. </li> <li><code>buf</code>: <code>struct timex*</code> - A pointer to a <code>struct timex</code> data structure, which contains the clock adjustments to be made as well as a number of other related parameters.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#available-tags","title":"Available Tags","text":"<p>No available tags.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#sys_clock_adjtime","title":"<code>sys_clock_adjtime</code>","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#purpose","title":"Purpose","text":"<p>Determine clock offset and frequency.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#do_adjtimex","title":"<code>do_adjtimex</code>","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#type_1","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#purpose_1","title":"Purpose","text":"<p>The purpose of hooking do_adjtimex is to determine whether the clock offset and frequency is being adjusted by a given clock, as well as to record any error values that may be returned.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#example-use-case","title":"Example Use Case","text":"<p>Consider an application for which time stamp accuracy is paramount. This system could use the <code>clock_adjtime()</code> system call to make adjustments to the clock's frequency and offset. This could be, for example, when the clock source is experiencing temperature-based frequency drift. The <code>clock_adjtime()</code> can be used to correct this drift, ensuring that timestamps are accurate and allowing the application to continue functioning without any substantial interruptions.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#issues","title":"Issues","text":"<p>This system call requires root privileges. This can be a potential security issue if too many users have access to the call. Furthermore, the system call can be prone to TOCTOU (Time of check, time of use) attacks, as some of the values provided by the caller might have changed by the time the call is executed by the kernel.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#related-events","title":"Related Events","text":"<ul> <li><code>clock_gettime</code> - returns the time information from the specified 'clock_id'</li> <li><code>clock_settime</code> - sets the given clock to a specified time value</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/","title":"clock_adjtime64","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#intro","title":"Intro","text":"<p>clock_adjtime64 - Sets clock adjustment for a specific clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#description","title":"Description","text":"<p>The clock_adjtime64 function allows for an application to adjust the clock for a specific clock. The clock is specified by its id if the id is available. The new adjustment will be applied to the clock immediately if the clock is current, otherwise the adjustment is made relative to the present adjustment. The adjustment given consists of (1) a time value specifying when the adjustment should be made, and (2) a time value specifying the amount of time to be added or subtracted from the clock\u2019s current time. The adjustment is always relative to the system time; that is, the adjustment represents the difference between the system time and the time to be set with the adjustment.</p> <p>When an adjustment is applied, the clock\u2019s \u2018tick counter\u2019 is reset to the adjusting ratio. This means that the number of clock ticks (or \u2018tick counts\u2019) since the last adjustment will remain fixed until the next adjustment.</p> <p>The clock_adjtime64 function is useful for applications which require precise timing, like audio and video applications. Since the clock time is adjusted to the system time, applications can use this function to align their time-referenced activities with the system time.</p> <p>However, applications must be aware of a few parameters when using clock_adjtime64. One is that if a change of the clock times is made, the process must also handle any updates to the system time. Another is that the adjustment may take longer than expected if the system clock is being heavily used. </p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#arguments","title":"Arguments","text":"<ul> <li><code>clock_id</code>:<code>__kernel_clockid_t</code>[K] - The clock id of the clock to adjust. The clock id is a positive integer specifying the clock to modify.</li> <li><code>ts</code>:<code>const struct __kernel_timespec *</code>[K] - A pointer to a <code>struct __kernel_timespec</code> object containing the desired adjustment value (<code>adjustmenttime</code>) and the time of the adjustment (<code>adjustmenttime</code>).</li> <li><code>old_ts</code>:<code>struct timespec *</code>[K] - A pointer to a <code>struct timespec</code> object to receive the time of the last clock adjustment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#do_adjtimex","title":"do_adjtimex","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#type","title":"Type","text":"<p>Raw kernel probes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#purpose","title":"Purpose","text":"<p>Logging when clock_adjtime64 is called.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#sys_clock_adjtime","title":"sys_clock_adjtime","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#purpose_1","title":"Purpose","text":"<p>Logging of clock_adjtime64 parameters.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#example-use-case","title":"Example Use Case","text":"<p>An audio software that uses clock_adjtime64 to keep a consistent clock time throughout the application. This provides a bulwark against timing issues that could otherwise lead to distortion or lost data.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#issues","title":"Issues","text":"<p>Since the results of a successfully called clock_adjtime64 are non-deterministic, applications must handle the cases where the clock is determined to be too slow or too fast.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#related-events","title":"Related Events","text":"<ul> <li>clock_settime</li> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/","title":"clock_getres","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#intro","title":"Intro","text":"<p>clock_getres - This system call knows the resolution (precision) of the specified clock, i.e. the period between successive readings.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#description","title":"Description","text":"<p>The <code>clock_getres</code> system call gets current clock resolution for the specified clock.  It returns the resolution of the clock, that is, how often clock periods occur.  It is expressed in seconds and nanoseconds. It is allowed for the target of the <code>res</code> argument to be NULL. In this case, the resolution is not returned though the system call does succeed.</p> <p>One advantage of using this system call instead of other system calls to measure time is that  it provides an accurate enough resolution to measure even small chunks of time. As such,  it is widely used in benchmarking and performance testing applications.  A potential drawback of using this system call to measure time is that the resolution of the clock is  based on the system, so the accuracy of the measurement may vary across different system configurations. </p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code> - The clock ID to get the resolution of. </li> <li><code>res</code>:<code>struct timespec*</code>[K] - Pointer to a timespec structure filled by the kernel with the resolution of the clock. </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#sys_clock_getres","title":"sys_clock_getres","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#purpose","title":"Purpose","text":"<p>Hooking the <code>sys_clock_getres</code> function allows us to properly measure the time of execution of the <code>clock_getres</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#example-use-case","title":"Example Use Case","text":"<p>The <code>clock_getres</code> system call can be used in performance tests or benchmarking applications  in order to accurately measure the time spent in certain parts of the code.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/","title":"clock_getres_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#intro","title":"Intro","text":"<p>clock_getres_time32 - retrieves the resolution of the specified clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#description","title":"Description","text":"<p>clock_getres_time32 retrives the resolution of the specified clock in struct old_timespec32 variable provided in the tp argument. This function allows information about the resolution of the clock to be queried, for use in accurately measuring time intervals. </p> <p>clock_getres_time32 exists for backward compatibility with 32bit systems, in replacement to clock_getres which takes timespec structure as an argument.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code>[K] - clock id use to query its resolution.  Supported clocks are the same as with clock_gettime.</li> <li><code>tp</code>:<code>struct old_timespec32*</code>[KU] - pointer to a buffer where the resolution of the clock will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#sys_clock_getres_time32","title":"sys_clock_getres_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#purpose","title":"Purpose","text":"<p>To monitor and trace the execution of clock_getres_time32 syscall.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#example-use-case","title":"Example Use Case","text":"<p>clock_getres_time32 can be useful in various timing-related projects. For example, it can be used to compare the resolution of different clocks, or query a clock's resolution before a precise time measurement is taken with clock_gettime.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime - query the current time</li> <li>clock_getres - query the resolution of a clock (64bit version)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/","title":"clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#intro","title":"Intro","text":"<p>clock_gettime - Retrieve the current time of a specific clock</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#description","title":"Description","text":"<p>clock_gettime() retrieves the current time from the clock specified by clockid. The tp argument is a pointer to a struct timespec, in which the current time is stored. It supports the following clock ids: - CLOCK_REALTIME: system-wide realtime clock - CLOCK_MONOTONIC: system-wide monotonically increasing clock - CLOCK_PROCESS_CPUTIME_ID: per-process accounting clock - CLOCK_THREAD_CPUTIME_ID: per-thread accounting clock</p> <p>Using clock_gettime() is a much more accurate approach than calling <code>time()</code> to retrieve the current time, as the latter will return the timestamp of the System Time Zone.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code>[K] - Id of the clock whose current time should be retrieved.</li> <li><code>tp</code>:<code>struct timespec*</code>[KU] - Pointer to a timespec structure where the current time will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#sys_clock_gettime","title":"sys_clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#purpose","title":"Purpose","text":"<p>Capture all calls to clock_gettime and monitor the process that calls it.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the wall clock time of a process and calculating the total execution time.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#issues","title":"Issues","text":"<p>This API may suffer from resource contention when multiple processes call it simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#related-events","title":"Related Events","text":"<p>N/A</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/","title":"clock_gettime32","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#intro","title":"Intro","text":"<p>clock_gettime32 - get the time of a specific clock, with a 32-bit version of <code>struct timespec</code></p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#description","title":"Description","text":"<p>clock_gettime32 is a Linux system call that retrieves the current time of the clock specified in the argument <code>which_clock</code>. The time is returned in <code>struct old_timespec32</code> pointed to by the argument <code>tp</code>. This version of the call is for 32-bit applications using an old version of <code>struct timespec</code>.</p> <p>The call can be subject to races if the time is retrieved between the check, at which point the output is known, and the use, at which point there are no guarantees the output is still valid. It's related to the time-of-check-time-of-use (TOCTOU) vulnerability, and it can be mitigated by applying locks or other synchronization techniques.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code> - The identifier of the clock whose time is requested.</li> <li><code>tp</code>:<code>struct old_timespec32*</code>[U] - Pointer to a buffer in user-space that is used to return the current time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#sys_clock_gettime","title":"sys_clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#purpose","title":"Purpose","text":"<p>To log the system calls for clock_gettime and clock_gettime32 at the entry point of syscall sys_clock_gettime.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#example-use-case","title":"Example Use Case","text":"<p>clock_gettime32's usage requires a clockid_t and a pointer to an old timespec structure. It can be used to get the current time of the requested clock, and then store and compare it in the future.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#issues","title":"Issues","text":"<p>Since clock_gettime32 is vulnerable to TOCTOU, care should be taken that the returned time might be stale by the time it is used. This can be mitigated by applying locks or other synchronization techniques.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#related-events","title":"Related Events","text":"<ul> <li>clock_nanosleep - Suspend the execution of the current thread until the time pointed by tp.</li> <li>timerfd_gettime - Retrieve the current expiry time of the timer associated with the timerfd.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/","title":"clock_nanosleep","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#intro","title":"Intro","text":"<p>clock_nanosleep - cause the current thread to sleep until a given time</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#description","title":"Description","text":"<p>The clock_nanosleep() system call causes the current thread to be suspended from execution until the absolute time specified by *tsp. The suspesion time may be shorter than requested because of the delivery of a signal. If the call is interrupted by the delivery of a signal, the remaining sleep time is returned in the remain argument of type struct timespcae, or is 0 if the timer expired. Two flags for use with nanosleep() are available, and defined in time.h</p> <ul> <li>TIMER_ABSTIME - set absolute timer value</li> <li>TIMER_RELTIME - set relative timer value</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#arguments","title":"Arguments","text":"<ul> <li> <p><code>clockid</code>: <code>const clockid_t</code> - The following clocks IDs are available; </p> <ul> <li>[CLOCK_REALTIME] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_MONOTONIC] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_MONOTONIC_RAW] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_BOOTTIME] (https://man7.org/linux/man-pages/man7/timer_create.7.html)</li> </ul> </li> <li> <p><code>flags</code>: <code>int</code> - If this is set to 0, the timer expiration value is specified in the <code>request</code> argument and is an absolute value. If the flag is set to TIMER_ABSTIME, ts is an absolute time. If TIMER_RELTIME is specified in flags, ts is a relative time.</p> </li> <li> <p><code>request</code>: <code>const struct timespec*</code>K - pointer to the timespec structure contains the expcation time of the nanosleep call. For the TIMER_ABSTIME the expiration time is an absolute time specified by <code>request</code>. For the TIMER_RELTIME the expiration time is a relative time specified by <code>request</code>.</p> </li> <li> <p><code>remain</code>: <code>struct timespec*</code>K - pointer to the timespec structure containing the remaining sleep time left or 0 if the timer expired.</p> </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#nanosleep","title":"nanosleep","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#type","title":"Type","text":"<p>Probed</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#purpose","title":"Purpose","text":"<p>Hooked to track execution of clock_nanosleep syscall.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#example-use-case","title":"Example Use Case","text":"<p>clock_nanosleep can be used to set a timer that will cause the current thread of a process to be suspended for a given amount of time. This can be useful for implementing algorithms such as synchronization, where it is necessary to wait for a certain amount of time before proceeding.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#issues","title":"Issues","text":"<ul> <li>clock_nanosleep is vulnerable to TOCTOU (Time-of-Check-Time-of-Use) attack</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime()</li> <li>clock_settime()</li> <li>clock_getres()</li> <li>timer_create()</li> <li>timer_settime()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/","title":"clock_nanosleep_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#intro","title":"Intro","text":"<p>clock_nanosleep_time32 - suspend the execution of the calling thread until the time pointed to by rqtp is reached</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#description","title":"Description","text":"<p>The clock_nanosleep_time32() function is used to suspend the execution of the calling thread until the time pointed to by rqtp is reached. If flags is 0, the thread will be suspended until the time pointed by rqtp is reached. The which_clock argument specifies the clock to use for measuring this timeout, the value can be either CLOCK_REALTIME or CLOCK_MONOTONIC. If rmtp (remaining time pointer) is a non-null pointer then the remaining time is stored in the old_timespec32(include  for details) structure referenced by rmtp. If rmtp is non-null and the clock_nanosleep_time32() time is interrupted by a signal while the thread is suspended, the remaining time is written to rmtp and -1 is returned with errno set to EINTR. This is the most reliable and portable way to implement timeout guards."},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code>[K] - The clock to use for measuring this timeout. The value can be either CLOCK_REALTIME or CLOCK_MONOTONIC.</li> <li><code>flags</code>:<code>int</code>[K] - If flags is 0, the thread will be suspended until the time pointed by rqtp is reached.</li> <li><code>rqtp</code>:<code>struct old_timespec32</code>*[K] - Pointer to the address of structure containing the requested time value.</li> <li><code>rmtp</code>:<code>struct old_timespec32</code>*[K, OPT] - Pointer to an old_timespec32 structure, if it is non-null, the remaining time will be stored in the old_timespec32 structure referenced by it. If it is null the remaining time will be ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#do_nanosleep_time32","title":"do_nanosleep_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#purpose","title":"Purpose","text":"<p>To trace Nanosleep calls made from user-space.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#example-use-case","title":"Example Use Case","text":"<p>The clock_nanosleep_time32() function can be used by applications to easily manage their timeouts while they are waiting for a given event or condition to be satisfied.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#issues","title":"Issues","text":"<p>The clock_nanosleep_time32() call relies on the kernel's scheduling policy, so the system may lag if there is heavy activity and the thread may not wake up exactly when it was supposed to.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#related-events","title":"Related Events","text":"<ul> <li><code>do_nanosleep_time32</code> - kernel entry point.</li> <li><code>clock_nanosleep</code> - Older syscall which can still be used for the same purpose.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/","title":"clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#intro","title":"Intro","text":"<p>clock_settime - Used to set the time of the specified clock</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#description","title":"Description","text":"<p>The clock_settime() system call sets the time of the specified clock, clk_id, to the broken-down time, *tp.   </p> <p>If clk_id is CLOCK_REALTIME or CLOCK_MONOTONIC, the time values tp is interpreted as a time value relative to the Epoch, satisfying the constraint that the Epoch + the seconds field in the tp structure must not exceed the maximum value supported by the kernel.</p> <p>The clock can be adjusted with respect to another clock, which is specified by the clockid argument. It is also possible to set a processor-specific clock with the types of CLOCK_PROCESS_CPUTIME_ID or CLOCK_THREAD_CPUTIME_ID.  </p> <p>Using CLOCK_REALTIME, CLOCK_MONOTONIC, or CLOCK_REALTIME_COARSE will guarantee a representable time, satisfying the constraint mentioned above.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>: <code>const clockid_t</code> - Identifies a particular clock. The supported clocks depends on the implementation.</li> <li><code>tp</code>: <code>const struct timespec *</code> - Pointer to a timespec structure that contains the new time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#do_sys_clock_settime","title":"do_sys_clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#purpose","title":"Purpose","text":"<p>To monitor and record the time setting events.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#example-use-case","title":"Example Use Case","text":"<p>The clock_settime() system call can be used to set the clocks of real-time applications with an accuracy of around one microsecond. It is useful for ensuring events are accurately timed and synchronized.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#issues","title":"Issues","text":"<p>If the specified clock id is invalid, the kernel will return an invalid argument error.  </p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/","title":"clock_settime32","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#intro","title":"Intro","text":"<p>clock_settime32 - set the time of the specified clock</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#description","title":"Description","text":"<p>clock_settime32() sets the time of the clock specified by which_clock to the time given by tp.  </p> <p>Advantages of using clock_settime32 is that it provides a way to set the time of the specified clock with a precision of nanoseconds, while drawbacks are that it doesn't change the system time, nor the time obtained with other clocks such as CLOCK_REALTIME.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code> - ID of the clock to set. </li> <li><code>tp</code>:<code>struct old_timespec32*</code> - pointer to a struct containing the new time of the specified clock. </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#do_sys_clock_settime","title":"do_sys_clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#purpose","title":"Purpose","text":"<p>Hooked for observability purposes, to measure the execution time of clock_settime32 syscall and collect per-thread and per-process scenarios, such as library calls and user delay calls.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#example-use-case","title":"Example Use Case","text":"<p>clock_settime32 can be used to synchronize multiple applications running on the same machine by setting the same clock time with the same specified clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#related-events","title":"Related Events","text":"<p>clock_gettime32 syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clone/","title":"clone","text":""},{"location":"docs/events/builtin/syscalls/clone/#intro","title":"Intro","text":"<p>clone - creates a child process</p>"},{"location":"docs/events/builtin/syscalls/clone/#description","title":"Description","text":"<p>The <code>clone</code> syscall creates a child process that shares parts of its execution context with its parent process. The parts of the context which are shared are defined by the flags parameter.  Advantages of using clone include the ability to modify the child process in the parent process using signals and ptrace, as well as the ability to share memory between the parent and child process without having to use the traditional Unix fork and exec. </p> <p>Drawbacks of using clone include the complexity of managing the execution context of multiple processes, as well as the potential for unintended sharing of address spaces or execution contexts between processes.</p>"},{"location":"docs/events/builtin/syscalls/clone/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned long</code> - flags specifying how the process will be created. See the flags section for more information.</li> <li><code>stack</code>:<code>void*</code> - pointer to the stack space for the child process. Passing <code>NULL</code> will cause the system to allocate the stack space.</li> <li><code>parent_tid</code>:<code>int*</code> - pointer to the thread ID for the parent process. This parameter is only used in the non-thread primitive case.</li> <li><code>child_tid</code>:<code>int*</code> - pointer to the thread ID for the child process. This parameter is only used in the non-thread primitive case.</li> <li><code>tls</code>:<code>unsigned long</code>- pointer to a structure containing the thread local storage data for the child process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clone/#sys_clone","title":"sys_clone","text":""},{"location":"docs/events/builtin/syscalls/clone/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/clone/#purpose","title":"Purpose","text":"<p>To capture the arguments passed to the <code>clone</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/clone/#example-use-case","title":"Example Use Case","text":"<p>The <code>clone</code> syscall can be used to create a new process with its own address space, but sharing the same execution context as another process. This can be used to create daemons or other services which run alongside an existing process or application.</p>"},{"location":"docs/events/builtin/syscalls/clone/#issues","title":"Issues","text":"<p>One potential issue is that the <code>clone</code> syscall can cause the parent process to enter an inconsistent state if it is interrupted while the child process is being created.</p>"},{"location":"docs/events/builtin/syscalls/clone/#related-events","title":"Related Events","text":"<ul> <li><code>fork</code> - syscall which creates a child process with its own address space, but sharing its execution context with the parent process.</li> <li><code>exec</code> - syscall which reloads a new execution context into a process, destroying the existing execution context.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clone3/","title":"clone3","text":""},{"location":"docs/events/builtin/syscalls/clone3/#intro","title":"Intro","text":"<p>clone3 - sys_clone3() creates a new process (child process)</p>"},{"location":"docs/events/builtin/syscalls/clone3/#description","title":"Description","text":"<p>Clone3() creates a new process, with a new PID, that shall be a copy of the parent process. This can be used to customize the way a process is created and allows for passing arguments. It includes the standard behavior of clone() along with new features such as customizing the execution domain (which will determine which flags and resources will be used when creating a new process) and allowing for anonymous mapping of memory.</p> <p>The clone3() entry point allows for customizing the execution configuration. If the invocation of the clone3() entry point is successful then the new child process is returned in the variables pointed to by the cl_args struct.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#arguments","title":"Arguments","text":"<ul> <li><code>cl_args</code>:<code>struct clone_args*</code>[KU] - Pointer to a structure containing arguments to customize the execution configuration.</li> <li><code>size</code>:<code>size_t</code>[K] - Size of cl_args structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone3/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone3/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clone3/#sys_clone3","title":"sys_clone3","text":""},{"location":"docs/events/builtin/syscalls/clone3/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clone3/#purpose","title":"Purpose","text":"<p>To track the execution of clone3 system call in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#example-use-case","title":"Example Use Case","text":"<p>This could be used for running services in Docker containers, as it is possible to customize the execution domain by using clone3.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#issues","title":"Issues","text":"<p>It is vulnerable to TOCTOU (time of check, time of use) attacks due to the fact that the arguments passed to the syscall are user supplied.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#related-events","title":"Related Events","text":"<ul> <li>execve - execution of a new program.</li> <li>unshare - creating a process by sharing resources to selectively.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/close/","title":"close","text":""},{"location":"docs/events/builtin/syscalls/close/#intro","title":"Intro","text":"<p>close - Closes a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/close/#description","title":"Description","text":"<p>The <code>close()</code> system call closes a file descriptor, so that it no longer refers to any file and may be reused. Any file descriptor that is closed is automatically removed from the range of descriptors checked forready-ness in <code>select()</code> or <code>poll()</code>. The resources associated with a file descriptor are released when all file descriptors reference the same file or pipe are closed.</p> <p>close also performs a form of synchronization. When all of the file descriptors associated with a pipe have been closed, any process that had the pipe open can detect the termination of the other end of the pipe, and the process can unblock if it was blocked on a read operation.</p> <p>It is important to close all file descriptors when they are no longer needed, rather than rely on the kernel to do it. Some implementations of <code>select()</code> and <code>poll()</code> attach a copy of the file descriptor table of the process to the kernel data structure associated with the call, for use during the call. If the process has a large file descriptor table and has made a <code>select()</code> or <code>poll()</code> system call, closing a file descriptor could result in the kernel consuming a lot of memory.</p>"},{"location":"docs/events/builtin/syscalls/close/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K,U] - A file descriptor indicating the open file to close. </li> </ul>"},{"location":"docs/events/builtin/syscalls/close/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/close/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/close/#sys_close","title":"sys_close","text":""},{"location":"docs/events/builtin/syscalls/close/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/close/#purpose","title":"Purpose","text":"<p>Allow the tracing of successful close system calls to a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/close/#example-use-case","title":"Example Use Case","text":"<p><code>close()</code> can be used to end the use of a file descriptor during the opening of a file descriptor. It can also be used to close resources that are automatically released, such as network sockets.</p>"},{"location":"docs/events/builtin/syscalls/close/#issues","title":"Issues","text":"<p>It is important to note that <code>close()</code> only works on file descriptors, and does not work on file objects as different platforms have different methods for handling file objects.</p>"},{"location":"docs/events/builtin/syscalls/close/#related-events","title":"Related Events","text":"<p>open, read, write, fsync</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/close_range/","title":"close_range","text":""},{"location":"docs/events/builtin/syscalls/close_range/#intro","title":"Intro","text":"<p>close_range - sys call to close a range of file descriptors</p>"},{"location":"docs/events/builtin/syscalls/close_range/#description","title":"Description","text":"<p>The close_range system call closes the file descriptors in the range [first,last], inclusive. This can be used in UNIX systems to reduce the number of times the same file descriptor is opened, as well as to free up resources and prevent resource leaks.</p> <p>There are some edge cases to consider when using close_range. If a file descriptor is already open, it may not be possible to close it. Also, if multiple processes have the same file descriptor open, closing it within a single process may not free up the resource.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#arguments","title":"Arguments","text":"<ul> <li><code>first</code>:<code>unsigned int</code>[K] - the lowest file descriptor to be closed.</li> <li><code>last</code>:<code>unsigned int</code>[K] - the highest file descriptor to be closed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/close_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/close_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/close_range/#sys_close_range","title":"sys_close_range","text":""},{"location":"docs/events/builtin/syscalls/close_range/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/close_range/#purpose","title":"Purpose","text":"<p>To track the closing of a range of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#example-use-case","title":"Example Use Case","text":"<p>A system might use <code>close_range</code> to close all unnecessary file descriptors when loading a new process to maintain resources.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#issues","title":"Issues","text":"<p>The <code>close_range</code> system call may not be able to close open file descriptors if they are already open in another process.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#related-events","title":"Related Events","text":"<p>The <code>open</code> and <code>close</code> system calls may accompany <code>close_range</code> calls, as they are used to open and close individual file descriptors. Additionally, the <code>dup</code>, <code>dup2</code> and <code>dup3</code> calls can be used to copy/move file descriptors around.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/connect/","title":"connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#intro","title":"Intro","text":"<p>connect() - establish a connection to a remote socket.</p>"},{"location":"docs/events/builtin/syscalls/connect/#description","title":"Description","text":"<p>This system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. It attempts to make a connection to another socket specified by the addr argument. The addrlen argument specifies the size of the address structure pointed to by addr.</p> <p>The type of socket used is determined by the parameters specified. The addr argument is void which allows for the address to be any type of socket address structure including internet socket address structures.</p> <p>In addition, the connect system call can allow for the passing of flags that can be used to provide functionality such as non-blocking mode, or address reuse.</p> <p>Are there any edge-cases, drawbacks or advantages of using it? One drawback of using connect() is that it is vulnerable to TOCTOU (time of check, time of use) attacks. This can occur if the address being connected to is not valid. Also, the socket being connected may be changed by a malicious actor between the time the connect() call is made and when the connection attempt is completed, thus making the connection vulnerable. In addition, connect() only provides unidirectional communication between the two endpoints, which is more vulnerable to attack in certain scenarios.</p>"},{"location":"docs/events/builtin/syscalls/connect/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[KU] - file descriptor referring to the socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[KU] - pointer to a socket address structure.</li> <li><code>addrlen</code>:<code>int</code>[KU] - length in bytes of the socket address structure pointed to by addr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/connect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/connect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/connect/#sys_connect","title":"sys_connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/connect/#purpose","title":"Purpose","text":"<p>To hook the kernel entry point for the connect system call to allow for tracing of all of the system calls arguments.</p>"},{"location":"docs/events/builtin/syscalls/connect/#sock_connect","title":"sock_connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/connect/#purpose_1","title":"Purpose","text":"<p>To hook the socket layer implementation of connect to allow for additional tracing of the arguments associated with this system call.</p>"},{"location":"docs/events/builtin/syscalls/connect/#example-use-case","title":"Example Use Case","text":"<p>The connect system call can be used to establish a network connection between two clients, such as a chat client. The connect system call could be used to connect the two clients over a TCP/IP connection, and then the two could communicate using the write() and read() system calls.</p>"},{"location":"docs/events/builtin/syscalls/connect/#issues","title":"Issues","text":"<p>The connect system call is vulnerable to TOCTOU attacks. This can occur if the address being connected to is not valid. Also, the socket being connected may be changed by a malicious actor between the time the connect() call is made and when the connection attempt is completed, thus making the connection vulnerable.</p>"},{"location":"docs/events/builtin/syscalls/connect/#related-events","title":"Related Events","text":"<ul> <li>accept() - used to accept a connection on a socket.</li> <li>bind() - used to bind a socket to an address.</li> <li>listen() - used to listen for connections on a socket.</li> <li>send() - used to send data on a connected socket.</li> <li>recv() - used to receive data on a connected socket.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/","title":"copy_file_range","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#intro","title":"Intro","text":"<p>copy_file_range - copies data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#description","title":"Description","text":"<p>The copy_file_range() function copies up to len bytes from the file referenced by fd_in to the file referenced by fd_out at the given offset of off_in and off_out respectively. The flags argument specifies the behavior if the range specified straddles a file boundary. copy_file_range() allows to copy data the same way that splice() does, but the data is copied from one file descriptor to another one instead of to/from a pipe.</p> <p>This function does not work on a file opened with O_DIRECT. An ESYSNOTSUPP error is expected in that case.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[K] - file descriptor of the input file.</li> <li><code>off_in</code>:<code>off_t *</code>[K] - starting offset of the input file.</li> <li><code>fd_out</code>:<code>int</code>[K] - file descriptor of the output file.</li> <li><code>off_out</code>:<code>off_t *</code>[K] - starting offset of the output file.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of data that needs to be copied.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Possible values are COPY_FILE_RANGE_WAIT_BEFORE, COPY_FILE_RANGE_WAIT_AFTER, and COPY_FILE_RANGE_NONBLOCK.</li> </ul>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#sys_copy_file_range","title":"sys_copy_file_range","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#purpose","title":"Purpose","text":"<p>To trace data that is being copied between files.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#sys_copy_file_range2","title":"sys_copy_file_range2","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#purpose_1","title":"Purpose","text":"<p>To trace data that is being copied between files.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#example-use-case","title":"Example Use Case","text":"<p>An example use case of copy_file_range() is using it to compare two files and detect differences between them.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#issues","title":"Issues","text":"<p>copy_file_range() does not work on files opened with O_DIRECT flags and an ESYSNOTSUPP error is expected in such cases.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#related-events","title":"Related Events","text":"<ul> <li>preadv2</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/creat/","title":"creat","text":""},{"location":"docs/events/builtin/syscalls/creat/#intro","title":"Intro","text":"<p>creat - system call to create a new, or overwrite an existing, file with certain permissions</p>"},{"location":"docs/events/builtin/syscalls/creat/#description","title":"Description","text":"<p>The creat() syscall creates a new file or overwrites an existing file, in the file system pointed to by the given pathname, with the given permissions.</p> <p>If the file does not exist, it will be created with the given permissions. If the file does exist, it will be overwritten, and set to the given permissions.</p> <p>It should be noted that the creat() syscall is essentially the same as an open call to <code>pathname</code> with the following flags: <code>O_WRONLY|O_CREAT|O_TRUNC</code>.</p>"},{"location":"docs/events/builtin/syscalls/creat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U,TOCTOU] - a pointer to a string containing the path to file being modified.</li> <li><code>mode</code>:<code>mode_t</code>[K] - permissions to be applied to the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/creat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/creat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/creat/#sys_creat","title":"sys_creat","text":""},{"location":"docs/events/builtin/syscalls/creat/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/creat/#purpose","title":"Purpose","text":"<p>To observe and trace when the creat() system call is performed.</p>"},{"location":"docs/events/builtin/syscalls/creat/#example-use-case","title":"Example Use Case","text":"<p>A logging system which keeps track of when files are created or modified.</p>"},{"location":"docs/events/builtin/syscalls/creat/#issues","title":"Issues","text":"<p>When creating a file, there is an atomic race condition which could lead to the file being left in an unexpected state if the creat() syscall fails and the file is overwritten.</p> <p>The <code>creat()</code> system call is also subjected to TOCTOU issues because it does not allow the <code>O_EXCL</code> flag to be set when creating a file. Anyone relying on it has to check if a file exists before calling <code>creat</code> system call. In between the check and the call the file could have been created, for example.</p>"},{"location":"docs/events/builtin/syscalls/creat/#related-events","title":"Related Events","text":"<p>open() - Creates or opens a file, modifier relating to the creat() syscall.</p> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/create_module/","title":"create_module","text":""},{"location":"docs/events/builtin/syscalls/create_module/#intro","title":"Intro","text":"<p>create_module - a system call that creates a new loadable kernel module.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#description","title":"Description","text":"<p>The <code>create_module</code> syscall allows user-space programs to create and register a new kernel module. This syscall provides the necessary parameters for defining the module's code, data, name and description, which are then compiled into a loadable kernel object file. After being created, the kernel module can be used for performing various operations such as extending the kernel's functionality or adding device drivers to the kernel.</p> <p>The main advantages of using <code>create_module</code> are that it offers a reliable method of loading and registering a new kernel module, while also providing a degree of flexibility that allows the programmer to customize the module to their needs. Additionally, it is worth noting that <code>create_module</code> can be more efficient than manually creating a kernel module, since it handles most of the necessary steps for creating a kernel module automatically.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>char *</code>[K, U] - the name of the kernel module. Must be unique.</li> <li><code>code</code>:<code>void *</code>[U] - a pointer to the module's code.</li> <li><code>len</code>:<code>unsigned long</code>[K] - the size of the module's code.</li> <li><code>mode</code>:<code>mode_t</code>[K] - specifies the kernel module's access privileges.</li> <li><code>flags</code>:<code>int</code>[K] - flags to specify additional parameters for the module.</li> </ul>"},{"location":"docs/events/builtin/syscalls/create_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/create_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/create_module/#sys_init_module","title":"sys_init_module","text":""},{"location":"docs/events/builtin/syscalls/create_module/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/create_module/#purpose","title":"Purpose","text":"<p>Hook <code>sys_init_module</code> to validate the arguments of the <code>create_module</code> syscall before the module is loaded.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#example-use-case","title":"Example Use Case","text":"<p>The <code>create_module</code> syscall can be used to create a new kernel module that extends the kernel's functionality, or adds device drivers to the kernel. For example, a kernel module could be used to detect new hardware in the system, or to add a new system call that could be used to perform a specific operation.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#issues","title":"Issues","text":"<p>Some versions of the <code>create_module</code> syscall are vulnerable to TOCTOU (Time of Check Time of Use) race conditions, which can be exploited by malicious users to subvert the loading process of the module. To mitigate this issue, it is recommended to hook the <code>sys_init_module</code> function using a KProbe and to validate the module's code and arguments before allowing it to be loaded.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#related-events","title":"Related Events","text":"<ul> <li>delete_module: the syscall used to unload a module created with <code>create_module</code>.</li> <li>sys_init_module: the kernel entry point for the <code>create_module</code> syscall, which can be hooked to validate the arguments of the <code>create_module</code> syscall before the module is loaded.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/","title":"delete_module","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#intro","title":"Intro","text":"<p>delete_module - system call to delete a module from the running kernel</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#description","title":"Description","text":"<p>The delete_module() system call deletes the specified module from the running kernel. It does not delete the associated files from the disk; for this, use rmmod(8). It takes two arguments - name, which is a pointer to the module name, and flags, an integer.</p> <p>The flags argument serves to specify the behavior of delete_module(). If the module has any active users, the call can either block until all users have freed the module (flags set to 0 or O_NONBLOCK) or just return with an EAGAIN error.</p> <p>Advantage of using delete_module() system call is that it allows to dynamically manage the behavior of the running kernel configuration.</p> <p>Disadvantage is that when the call is blocked, other processes might be delayed because they were not able to wait until the delete_module() system call was completed. This may lead to race conditions, which might cause issues with system stability.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>: const char*[K|U] - pointer to the module name</li> <li><code>flags</code>: int[K] - integer to specify the behavior of delete_module()</li> </ul>"},{"location":"docs/events/builtin/syscalls/delete_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/delete_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#do_delete_module","title":"do_delete_module","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#purpose","title":"Purpose","text":"<p>Hooks do_delete_module to detect when the delete_module() system call is invoked and to monitor the behavior of delete_module()</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#example-use-case","title":"Example Use Case","text":"<p>delete_module() system call can be used to dynamically manage the running kernel configuration. In a production environment, for instance, it can be used to disable certain features or to enable debug mechanisms without restarting the machine.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#issues","title":"Issues","text":"<p>Race conditions can arise from blocking delete_module() system calls, delaying other processes.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#related-events","title":"Related Events","text":"<p>The use of delete_module() system call is connected with kprobe_event_handler and rmmod system calls.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup/","title":"dup","text":""},{"location":"docs/events/builtin/syscalls/dup/#intro","title":"Intro","text":"<p>dup - duplicate an existing file descriptor</p>"},{"location":"docs/events/builtin/syscalls/dup/#description","title":"Description","text":"<p>The dup() system call creates a duplicate of the file descriptor oldfd. It returns the new glass reference to the same open file description and shares the same file offset and file status flags as the original file descriptor. This system call allows the programmer to use the file descriptor multiple times in the same process.</p> <p>The dup() system call has several advantages, compared to other system calls such as open() and dup2(). It does not require the user to specify a pathname, since it operates on existing file descriptors. Furthermore, it does not perform a separate open() operation and all of the related system call overhead. Finally, dup() properly handles the underlying open file description reference count. </p> <p>There are two edge-cases to be aware of when using the dup() system call. First, the oldfd argument must refer to an open file descriptor in order for the operation to succeed. If the oldfd argument does not refer to an open file descriptor, the system call will return an error. Second, a file descriptor created with the dup() function should also be closed with close() and not with a call to free().</p>"},{"location":"docs/events/builtin/syscalls/dup/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K] - file descriptor of an open file description.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup/#syscall_entry_dup","title":"syscall_entry_dup","text":""},{"location":"docs/events/builtin/syscalls/dup/#type","title":"Type","text":"<p>kretprobe + kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup/#purpose","title":"Purpose","text":"<p>The syscall_entry_dup function is hooked in order to intercept the dup() system call and record its associated arguments.</p>"},{"location":"docs/events/builtin/syscalls/dup/#example-use-case","title":"Example Use Case","text":"<p>The dup() system call can be used to create multiple pointers to the same open file description. This is useful for applications that need to read from the same file from multiple places at the same time. For example, an antivirus program may need to read several chunks of a file in order to scan it for viruses.</p>"},{"location":"docs/events/builtin/syscalls/dup/#issues","title":"Issues","text":"<p>The dup() system call can be vulnerable to TOCTOU (time of check, time of use) attacks, as the open file description of the oldfd argument may have been modified between the time of the check and the time of use. </p>"},{"location":"docs/events/builtin/syscalls/dup/#related-events","title":"Related Events","text":"<ul> <li>open() - open a file descriptor</li> <li>close() - close a file descriptor</li> <li>dup2() - clone existing file descriptor with a given new descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup2/","title":"dup2","text":""},{"location":"docs/events/builtin/syscalls/dup2/#intro","title":"Intro","text":"<p>dup2 - Duplicate an open file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#description","title":"Description","text":"<p>The dup2() system call performs the equivalent of dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd.  If the file descriptor newfd was previously open, it is silently closed before being reused.</p> <p>The dup2() system call can be used, for example, to convert a disk file descriptor fd into a network socket descriptor (which is really just a file descriptor number). If newfd is already open, it is first closed. Then its value is applied as the new duplicate descriptor so that dup2(fd, newfd) is equivalent to close(newfd); dup2(fd, newfd).</p> <p>The dup2() system call does not cause the file offset (See lseek(2)) and file status flags to be changed.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K] - Descriptor of the file that is going to be duplicated.</li> <li><code>newfd</code>:<code>int</code>[K] - Descriptor that is going to contain the duplicate.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup2/#dup2_1","title":"dup2","text":""},{"location":"docs/events/builtin/syscalls/dup2/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup2/#purpose","title":"Purpose","text":"<p>To trace the duplication of an open file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#example-use-case","title":"Example Use Case","text":"<p>A use case for the dup2 system call is to duplicate a file descriptor that has been opened in order to write to an alternate location, while still leaving the file descriptor that was opened pointing to the original location. This might be useful if you want to preserve the original file descriptor, but need to make modifications to a different location.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#issues","title":"Issues","text":"<p>The dup2() system call does not cause the file offset and file status flags to be changed.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#related-events","title":"Related Events","text":"<p>The relation between dup2() and dup() and fork().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup3/","title":"dup3","text":""},{"location":"docs/events/builtin/syscalls/dup3/#intro","title":"Intro","text":"<p>dup3 - duplicate a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#description","title":"Description","text":"<p>The dup3() system call creates a copy of the given file descriptor <code>oldfd</code>, and uses the given <code>flags</code> argument to control the behavior of the copy. It then stores the copy as <code>newfd</code>.</p> <p>The advantage of using dup3() over dup2() is that the file descriptor flags are not copied over to the duplicate file descriptor. The flags argument can be used to set new flags on the duplicate fd, but they do not affect the original file descriptor. Any special requests (such as asking for a non-blocking file descriptor) can be set with flags.</p> <p>Duplicating a file descriptor which has already been closed results in an error.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K,U] - the file descriptor to duplicate.</li> <li><code>newfd</code>:<code>int</code>[K,U] - the new file descriptor.</li> <li><code>flags</code>:<code>int</code> - flags that control how the descriptor is handled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup3/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup3/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup3/#dup3_1","title":"dup3","text":""},{"location":"docs/events/builtin/syscalls/dup3/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup3/#purpose","title":"Purpose","text":"<p>To observe when a process attempts to duplicate a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#example-use-case","title":"Example Use Case","text":"<p>Monitoring application performance can be improved by identifying when a process is spending too much time duplicating file descriptors. A trace can be taken of any process that is seen to repeatedly call dup3(), and the root cause of the inefficiency can be investigated.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#issues","title":"Issues","text":"<p>No notable issues have been found with the dup3() system call.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#related-events","title":"Related Events","text":"<p>The dup2() system call creates a copy of a file descriptor with the same flags as the original, and can be used as an alternative to dup3().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/","title":"epoll_create","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#intro","title":"Intro","text":"<p>epoll_create - create an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#description","title":"Description","text":"<p>The epoll_create() system call creates an epoll instance. It takes a single argument size, which defines the maximum number of file descriptors that can be monitored by the instance. The size argument is used to determine the amount of memory consumed by the epoll instance, which is allocated upon creating the instance. This memory is released when the instance is closed by calling the close() system call.</p> <p>The epoll_create() system call has several advantages: * Allows the registration of multiple file descriptors. * Registering of multiple processes and signals. * It has an efficient memory usage. * It has a low latency for waking up appliy so the system can acquire data.</p> <p>epoll_create() can be used for monitoring non-blocking or non-blocking sockets. It can also be used to keep track of multiple processes and signals.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code> - Maximum number of file descriptors that can be monitored by the instance.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#ep_create_files_struct","title":"ep_create_files_struct","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#purpose","title":"Purpose","text":"<p>To intercept the system call when creating a new epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#files_free","title":"files_free","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#purpose_1","title":"Purpose","text":"<p>To intercept the system call when closing an epoll instance to free the allocated memory.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#example-use-case","title":"Example Use Case","text":"<p>The epoll_create() system call can be used to monitor a directory for changes. For example, in an application that monitors a directory for new files, the epoll_create() system call can be used to create an epoll instance for the directory, and then the application can wait for the incoming files using the epoll_wait() system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#issues","title":"Issues","text":"<p>The performance of epoll_create() degrades on large datasets due to the added complexity of the constant addition and removal of file descriptors from the instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_ctl</code> - control interface for an epoll instance</li> <li><code>epoll_wait</code> - wait for an I/O event on an epoll instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/","title":"epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#intro","title":"Intro","text":"<p>epoll_create1 - create a new instance of an epoll set for monitoring file descriptors</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#description","title":"Description","text":"<p>The epoll_create1() system call performs the same task as epoll_create(), but it allows for additional features that are beneficial for certain applications. Flags specifies the behavior of the system call and may be used to specify a maximum number of descriptors that the target epoll instance will be able to contain (flags is a bitmask, and only one of the flags in the mask should be used). This syscall is useful in applications that depend on high performance and scalability, such as network servers.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[OPT] - bits that specify the behavior of the system call. The flags may be a bitmask specifying the behavior of the system call. The only flag that should be used is EPOLL_CLOEXEC, which creates the epoll instance with the close-on-exec flag.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#epoll_create1_1","title":"epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#purpose","title":"Purpose","text":"<p>To monitor the execution of the epoll_create1 system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#example-use-case","title":"Example Use Case","text":"<p>The epoll_create1 system call can be used to create a new instance of an epoll set for monitoring a large number of file descriptors. This system call is particularly useful for servers that constantly need to monitor a large number of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#related-events","title":"Related Events","text":"<ul> <li>epoll_ctl - used to control an instance of an epoll set</li> <li>epoll_wait - used to wait for events from an instance of an epoll set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/","title":"epoll_ctl","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#intro","title":"Intro","text":"<p>epoll_ctl - program the event filter for an epoll instance </p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#description","title":"Description","text":"<p>The epoll_ctl() system call is used to add, modify, or delete entries in an epoll instance's kernel struct associated with a file descriptor. An application creates an epoll instance using epoll_create1() and receives notification of I/O events through that instance.</p> <p>For each file descriptor, the process can register multiple associated events along with a user-supplied file descriptor reference. The set of registered events and their associated user data for a given file descriptor can be changed using epoll_ctl().</p> <p>Note that the epoll_ctl() system call does not generalize I/O event monitoring to other kinds of The epoll_wait() thread-safe system call. Objects like signals and timers - use different system calls to program these special kinds of events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code> - epoll instance file descriptor </li> <li><code>op</code>:<code>int</code>[K] - operation code</li> <li><code>fd</code>:<code>int</code>[K] - file descriptor to be monitored </li> <li><code>event</code>:<code>struct epoll_event*</code>[K] - structure with epoll events </li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#sys_epoll_ctl","title":"sys_epoll_ctl","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#purpose","title":"Purpose","text":"<p>The purpose for hooking the sys_epoll_ctl kernel entry point is to trace the epoll_ctl system call and its arguments, as well as the return code.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#sys_epoll_create1","title":"sys_epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#purpose_1","title":"Purpose","text":"<p>The purpose for hooking the sys_epoll_create1 kernel entry point is to trace the epoll_create1 system call and its arguments, as well as the return code.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#example-use-case","title":"Example Use Case","text":"<p>The epoll_ctl system call can be used to add, modify, or delete entries in an epoll instance's kernel struct associated with a file descriptor. This can be useful for monitoring I/O on a large number of file descriptors. For example, an application can use epoll_ctl to monitor activity on a large number of sockets, and be alerted when one of the sockets has data ready to be read.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#issues","title":"Issues","text":"<p>epoll_ctl does not generalize I/O event monitoring to other kinds of objects like signals and timers - use different system calls to program these special kinds of events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_create1</code> - creates an epoll instance </li> <li><code>__x64_sys_epoll_pwait</code> - waits for an I/O event on an epoll instance</li> <li><code>epoll_wait</code> - suspends the calling thread until an I/O event occurs on an epoll instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/","title":"epoll_ctl_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#intro","title":"Intro","text":"<p>epoll_ctl_old - Used to control the interest list used by an epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#description","title":"Description","text":"<p>The epoll_ctl_old call tries to add or remove an epoll instance (also referred  to as \"epollfd\") to an interest list. It is used to tell the kernel which events  should be monitored for a given file descriptor.It is the older version of the  epoll_ctl system call and is used to control the interest list used by an epoll  instance.</p> <p>The epoll_ctl_old call can be used to register a file descriptor for events that  were previously not handled by epoll. It can also be used to update an existing  file descriptor with its previous events (e.g.,masking out events that were  previously enabled).</p> <p>When an epoll instance is created, it is initialised with an empty interest  list. Events are then registered using the epoll_ctl_old call. After registering, the epoll instance can start monitoring for events with the epoll_wait call.</p> <p>The epoll_ctl_old call has two different flags which can be used to control the behavior of the call: * EPOLL_CTL_ADD - adds a given file descriptor to the interest list of the    epoll instance. * EPOLL_CTL_DEL - removes a given file descriptor from the epoll instance.</p> <p>The epoll_ctl_old call can also take a third argument which is a pointer to an  epoll_event structure. This argument is used to specify which events are monitored for a given file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code>[K] - File descriptor of epoll instance.</li> <li><code>op</code>:<code>int</code>[K] - Operation that is requested.</li> <li><code>event</code>:<code>struct epoll_event *</code>[KU] - Structure that contains event to be monitored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#epoll_ctl_old_1","title":"epoll_ctl_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#purpose","title":"Purpose","text":"<p>To monitor epoll_ctl_old calls and the arguments they take.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#example-use-case","title":"Example Use Case","text":"<p>A use case for epoll_ctl_old could be for a security monitoring application that  wants to monitor for certain file descriptor events. This application could use epoll_ctl_old to register the file descriptor associated with the event it wants  to monitor and to then use epoll_wait to wait for events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#issues","title":"Issues","text":"<p>There are no known issues with epoll_ctl_old.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#related-events","title":"Related Events","text":"<ul> <li>epoll_wait</li> <li>epoll_create</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/","title":"<code>epoll_pwait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#intro","title":"Intro","text":"<p>The <code>epoll_pwait</code> system call - wait for an I/O event on an epoll filedescriptor with the option for user-space signal masking.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#description","title":"Description","text":"<p><code>epoll_pwait</code> was added to Linux to extend the capabilities of the previous <code>epoll_wait</code> system call. Instead of just waiting for an I/O event to happen on an epoll file descriptor, <code>epoll_pwait</code> accepts an additional argument <code>sigmask</code> which is a pointer to a user-space signal mask. This signal mask defines which signals the process is to block while waiting for the I/O event.</p> <p>This system call adds an additional level of control to the process while it's waiting, allowing to have full control over the signals it''ll receive while waiting, making it easier to control in scenarios where it needs to be woken up due to incoming signals.</p> <p>The other arguments, <code>epfd</code>, <code>events</code>, <code>maxevents</code> and <code>timeout</code> are the same as the <code>epoll_wait</code> system call. <code>epfd</code> holds the epoll filedescriptor to query, <code>events</code> is a pointer to a memory space that will store the I/O events info, <code>maxevents</code> is a maximum size of <code>events</code> given, and <code>timeout</code> is the number of milliseconds the process will wait before timing out.</p> <p>It's important to note that this system call is vulnerable to time-of-check/time-of-use (TOCTOU) attacks, as the signal mask used can be changed between the time it checks and the time it waits, with disastrous results in some architectures.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code>[K] - epoll filedescriptor to query for I/O events.</li> <li><code>events</code>:<code>struct epoll_event*</code>[K] - pointer to a memory space that will store the I/O events info.</li> <li><code>maxevents</code>:<code>int</code>[K] - maximum size of <code>events</code> given.</li> <li><code>timeout</code>:<code>int</code>[K] - number of milliseconds the process will wait before timing out.</li> <li><code>sigmask</code>:<code>const sigset_t*</code>[KU] - pointer to a user-space signal mask used to block certain signals.</li> <li><code>sigsetsize</code>:<code>size_t</code>[KU] - size of <code>sigmask</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#sys_epoll_pwait","title":"<code>sys_epoll_pwait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#purpose","title":"Purpose","text":"<p>To monitor or trace the use of the epoll_pwait system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#ep_poll_callback","title":"<code>ep_poll_callback</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#type_1","title":"Type","text":"<p>Kretprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#purpose_1","title":"Purpose","text":"<p>To log information about the returned data from the epoll_pwait system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#example-use-case","title":"Example Use Case","text":"<p>When dealing with a multithreaded application, it's important to be able to control which signals the application will react to while waiting. <code>epoll_pwait</code> allows to have full control over the user-space signal mask, making it easy to decide which signals will be blocked while waiting.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#issues","title":"Issues","text":"<ul> <li>Vulnerability to TOCTOU attacks - the signal mask used in the system call can be changed between the time of check and the time of use, which can lead to issues in some architectures.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_wait</code> - similar event but without the possibility of signal masking.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/","title":"epoll_pwait2","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#intro","title":"Intro","text":"<p>epoll_pwait2 - wait for an I/O event on an epoll file descriptor with optional behavior for handling signals</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#description","title":"Description","text":"<p>The epoll_pwait2 system call provides a wait for an I/O event on an epoll file descriptor. It is an extension to the epoll_pwait system call, which allows for the specification of an optional signal set for atomically unblocked signals. This is particularly useful for applications that need to ensure the correctness of behavior in a multithread environment where multiple threads might be blocked using the same epoll file descriptor, and one thread might unblock a signal that should eventually be handled by a different thread.</p> <p>The advantages of using this system call include allowing signals to be handled atomically (without being interrupted by other signals), and allowing multiple threads to wait on the same epoll file descriptor.</p> <p>However, one drawback to using this system call is that it requires a single set of signals to be specified for all threads, as opposed to the epoll_wait system call which allows for signals to be specified on a per-thread basis.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - epoll instance file descriptor</li> <li><code>events</code>:<code>struct epoll_event*</code>[K] - a memory region where epoll_event structures are featured</li> <li><code>maxevents</code>:<code>int</code>[K] - the maximum number of events to be returned</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K] - a timeout interval, or NULL for no timeout</li> <li><code>sigset</code>:<code>const sigset_t*</code>[K] - a signal set mask, or NULL for the current set</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#sys_epoll_pwait2","title":"sys_epoll_pwait2","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#purpose","title":"Purpose","text":"<p>To capture the entrance and exit of the epoll_pwait2 system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#example-use-case","title":"Example Use Case","text":"<p>An application that needs to ensure the correctness of its behavior in a multithread environment where multiple threads might be blocked using the same epoll file descriptor and where one thread might unblock a signal that should eventually be handled by a different thread could use this system call to ensure that signals are handled atomically without being interrupted by other signals, and that multiple threads can wait on the same epoll file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#related-events","title":"Related Events","text":"<p>epoll_wait, epoll_pwait</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/","title":"<code>epoll_wait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#intro","title":"Intro","text":"<p><code>epoll_wait</code> - waits for an I/O event on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#description","title":"Description","text":"<p><code>epoll_wait</code> is a system call used to wait for I/O events on an epoll file descriptor. It is similar to <code>poll</code>, but with better scalability for large numbers of monitored file descriptors. It returns when either an I/O event has been detected or the timeout has expired.</p> <p>The main advantage of using <code>epoll_wait</code> is increased scalability, since <code>poll</code> and <code>select</code> perform worse as the number of monitored events increases. However, there are some drawbacks to using <code>epoll_wait</code>. For example, <code>epoll_wait</code> is not a real-time system call, meaning that there can be a significant lag between events being triggered and them being handled by <code>epoll_wait</code>. Additionally, <code>epoll_wait</code> can be more complicated to use since it requires a more involved setup procedure.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code> - the epoll file descriptor created with <code>epoll_create</code></li> <li><code>events</code>:<code>struct epoll_event*</code>[U] - pointer to a buffer where the events will be returned</li> <li><code>maxevents</code>:<code>int</code> - the maximum number of events that can be returned</li> <li><code>timeout</code>:<code>int</code> - the timeout in milliseconds; or -1 to wait indefinitely</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#sys_epoll_wait","title":"<code>sys_epoll_wait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#purpose","title":"Purpose","text":"<p>To trace I/O events on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#example-use-case","title":"Example Use Case","text":"<p>An example use case for <code>epoll_wait</code> would be a real-time application that needs to process incoming network traffic.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#issues","title":"Issues","text":"<p>There is a known bug in <code>epoll_wait</code> related to the <code>maxevents</code> argument. If the <code>maxevents</code> argument is greater than the number of available events, the <code>timeout</code> argument may not be taken into account correctly.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_ctl</code> - add or delete file descriptors to/from an epoll file descriptor</li> <li><code>epoll_create</code> - create a new epoll file descriptor</li> <li><code>epoll_create1</code> - create a new epoll file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/","title":"epoll_wait_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#intro","title":"Intro","text":"<p>epoll_wait_old - waits for events on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#description","title":"Description","text":"<p>The <code>epoll_wait_old</code> function is used to retrieve events associated with an epoll instance. It will block until an event from the epoll instance is available, and then return a list of events that were associated with the epoll instance when the call occurred. The maximum number of events returned by a single call is specified by the <code>maxevents</code> argument. </p> <p>This system call is the older version of the <code>epoll_wait()</code> system call which itself is replaced by the <code>epoll_pwait()</code> system call which allows for setting a timeout value for the total amount of time to wait for events. The <code>epoll_wait_old</code> system call does not support a timeout value and instead only blocks until an event is available. </p> <p>The epoll event type of the returned events can be determined from the <code>events</code> field of the <code>struct epoll_event</code> returned from the call. The data associated with the returned events can be determined from the <code>data</code> field of the struct.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>: <code>int</code>[K] - The file descriptor for the epoll instance. Must be a valid file descriptor that was returned from a call to <code>epoll_create()</code>. </li> <li><code>events</code>: <code>struct epoll_event *</code>[K] - A pointer to an array of <code>struct epoll_event</code>s to be filled with events associated with the epoll instance.</li> <li><code>maxevents</code>: <code>int</code>[K] - The maximum number of events to be present in the <code>events</code> array when the call returns. </li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#do_sys_epoll_wait","title":"do_sys_epoll_wait()","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#purpose","title":"Purpose","text":"<p>To capture when the system call is called and have access to all the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#example-use-case","title":"Example Use Case","text":"<p><code>epoll_wait_old</code> might be used in a program that uses asynchronous I/O to read data from multiple sources. The program could use <code>epoll_create()</code> to create an instance of an epoll file descriptor, then use <code>epoll_ctl()</code> to add one or more file descriptors to the instance. The program could then call <code>epoll_wait_old()</code> to wait for events on the epoll file descriptor, when an event is available, the <code>events</code> array will be populated with events related to the epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#issues","title":"Issues","text":"<ul> <li>This system call does not support a timeout value and instead only blocks until an event is available. This may cause the program to hang if no events occur before the program is killed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_pwait()</code> - The newer version of the <code>epoll_wait()</code> system call.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/","title":"eventfd","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#intro","title":"Intro","text":"<p>eventfd - A kernel-level event notification system.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#description","title":"Description","text":"<p>The eventfd() function is used to create a file descriptor for event notification. This is similar to the poll and select system calls, but more efficient and with more features. It allows applications to setup application-level synchronization between processes or between threads. An eventfd descriptor can be used like a file descriptor, and can be monitored using poll, select or epoll, as well as flushing to user space when there is pending data. The initval parameter can be used to determine whether a specific eventfd descriptor has data available or not. The flags parameter is used to control the behavior of the eventfd descriptor.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#arguments","title":"Arguments","text":"<ul> <li><code>initval</code>:unsigned int[K] - Initial value. This is used to indicate whether a given eventfd descriptor has data available or not.</li> <li><code>flags</code>:int[K] - Flags controlling the behavior of the eventfd descriptor.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#sys_eventfd","title":"sys_eventfd","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#type","title":"Type","text":"<p>kprobe + uprobe.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#purpose","title":"Purpose","text":"<p>In order to provide efficient application-level synchronization, the eventfd system call is hooked so that the kernel can trigger an eventfd descriptor when necessary.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#example-use-case","title":"Example Use Case","text":"<p>The eventfd system call can be used in applications to create synchronization triggers. This can be useful in cases where synchronization between multiple threads is used, such as in the implementation of complex data structures.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#related-events","title":"Related Events","text":"<p>Other synchronization functions, such as futex.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/","title":"eventfd2","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#intro","title":"Intro","text":"<p>eventfd2 - create/get an eventfd file descriptor for improved asynchronous handling of events.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#description","title":"Description","text":"<p>eventfd2 creates an \"eventfd\" object that can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events. It is similar to the pipe system call, but the read/write operations on /dev/eventfd are atomic. The initval argument is a initial value of the counter; The flags argument is a bitmask of flags that affects the semantics of the create.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#arguments","title":"Arguments","text":"<ul> <li><code>initval</code>:<code>unsigned int</code>[U] - the initial value of the counter.</li> <li><code>flags</code>:<code>int</code>[U] - a bitmask which can be set to request specific eventfd features and/or classes of behavior.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#sys_eventfd2","title":"sys_eventfd2","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#purpose","title":"Purpose","text":"<p>To track the execution of eventfd2 syscall.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#example-use-case","title":"Example Use Case","text":"<p>An application may use an eventfd object as a notification of an event, for example an overflow of a threshold, by setting initval to zero, and storing the count that triggered the event in the user space, each time the kernel reads the count, it will add the trigger count and set the counter to the initial value.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#related-events","title":"Related Events","text":"<p>pipe(), poll()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/execve/","title":"execve","text":""},{"location":"docs/events/builtin/syscalls/execve/#intro","title":"Intro","text":"<p>execve - This system call causes the program referred to by pathname to be executed in a new process using the given parameters and environment.</p>"},{"location":"docs/events/builtin/syscalls/execve/#description","title":"Description","text":"<p>execve is used to start new processes. It takes a pathname and two arrays - argv and envp - as parameters and executes the program found at the given pathname. The argv array is a collection of NULL-terminated strings of command-line options to be passed to the new process, while the envp array is a collection of NULL-terminated strings that defines the environment of the new process. execve overwrites the current process image with a new process image, which is created based on the given parameters and environment. </p> <p>When execve is executed, it is important to keep in mind that the new process image is created but not executed yet. This means that the process might still need to allocate memory for itself, load code and initialize data before it can start executing. This can be vulnerable to Time Of Check, Time Of Use (TOCTOU) attacks, where the process checks the validity of a file at one point in time, and then later uses the file itself assuming the validity of it.</p>"},{"location":"docs/events/builtin/syscalls/execve/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code> - Pathname of the program to be executed.</li> <li><code>argv</code>:<code>const char*const*</code> [K] - Array of null-terminated strings that contain the arguments to be passed to the new process.</li> <li><code>envp</code>:<code>const char*const*</code> [K] - Array of null-terminated strings that contain the environment variables of the new process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/execve/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/execve/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/execve/#sys_execve","title":"sys_execve","text":""},{"location":"docs/events/builtin/syscalls/execve/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/execve/#purpose","title":"Purpose","text":"<p>Hooking sys_execve enables tracing of all processes executed on the system, including the process arguments and environment variables.</p>"},{"location":"docs/events/builtin/syscalls/execve/#example-use-case","title":"Example Use Case","text":"<p>Tracing an access control matrix to make sure sensitive programs are not executed without permission.</p>"},{"location":"docs/events/builtin/syscalls/execve/#issues","title":"Issues","text":"<p>execve is vulnerable to TOCTOU attacks, so checks should be done when using the execve call.</p>"},{"location":"docs/events/builtin/syscalls/execve/#related-events","title":"Related Events","text":"<ul> <li>fork - To create a new process before executing it.</li> <li>sigaction - To set the signal handling function of the new process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/execveat/","title":"execveat","text":""},{"location":"docs/events/builtin/syscalls/execveat/#intro","title":"Intro","text":"<p>execveat - execute a file in a directory relative to a directory file descriptor</p>"},{"location":"docs/events/builtin/syscalls/execveat/#description","title":"Description","text":"<p>The execveat() system call executes the program referred to by the combination of dirfd and pathname.  Pathname could either be an absolute pathname or a relative pathname, and dirfd could either be AT_FDCWD or a file descriptor corresponding to a directory. It is an analogous version of execve() which uses the current working directory.</p> <p>The argument argv and envp are passed to the new program as its argument and environment respectively, and flags could be a combination of the AT_* flags provided by the identically named execve() system call.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[KU] - file descriptor of the directory to use as a base, relative to which the pathname should be evaluated.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname of the program to execute.</li> <li><code>argv</code>:<code>const char*const*</code>[KU] - array of the arguments for the program, or NULL for none.</li> <li><code>envp</code>:<code>const char*const*</code>[KU] - array of environment variables for the program, or NULL for none.</li> <li><code>flags</code>:<code>int</code>[KU] - optional argument that could be combination of the AT_* flags provided by the identically named execve() system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/execveat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/execveat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/execveat/#sys_execveat","title":"sys_execveat","text":""},{"location":"docs/events/builtin/syscalls/execveat/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/execveat/#purpose","title":"Purpose","text":"<p>Hook sys_execveat to capture and count the number of times various programs are started.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for execveat is in an intrusion detection system. By hooking the system call and monitoring the arguments provided, malicious behavior could be detected and reported.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#issues","title":"Issues","text":"<p>While the execveat system call is a useful tool, it is also susceptible to time-of-check-time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#related-events","title":"Related Events","text":"<p>Other exec events, such as execve and execveatv, are related to execveat. In addition, fork and clone could be useful in the context of execveat.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/exit/","title":"Exit","text":""},{"location":"docs/events/builtin/syscalls/exit/#intro","title":"Intro","text":"<p>exit -- Cause normal process termination</p>"},{"location":"docs/events/builtin/syscalls/exit/#description","title":"Description","text":"<p>The <code>exit()</code> syscall is used to terminate the process that called it. All the  resources held by the process, such as open files and memory mappings, are released  as part of the process termination. The status code is passed to other processes  to inform them about the termination of the process.</p>"},{"location":"docs/events/builtin/syscalls/exit/#arguments","title":"Arguments","text":"<ul> <li><code>status</code>:<code>int</code> - The status code of process which is returned to the parent  process. The lower 8 bits of the status code contains the exiting status (please  check the manual for more details). The higher 8 bit bits of the status code  contain certain flags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/exit/#do_exit","title":"do_exit","text":""},{"location":"docs/events/builtin/syscalls/exit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/exit/#purpose","title":"Purpose","text":"<p>Hook the kernel entry point to trace process termination.</p>"},{"location":"docs/events/builtin/syscalls/exit/#example-use-case","title":"Example Use Case","text":"<p>Analyzing the exit status code of children processes.</p>"},{"location":"docs/events/builtin/syscalls/exit/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/exit/#related-events","title":"Related Events","text":"<p>The <code>fork()</code> and <code>exec()</code> syscalls are related to this event since they are used  to create and load a new process which will eventually terminate with the <code>exit()</code>  syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/","title":"exit_group","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#intro","title":"Intro","text":"<p>exit_group - cause all threads in the calling thread's thread group to exit</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#description","title":"Description","text":"<p>exit_group effectively calls _exit and terminates all threads in the calling thread's thread group. The return status passed to the parent (_exit) is the same as from the  terminating thread.</p> <p>The exit_group syscall is useful for applications requiring the termination of all threads before the application exits. It also has advantages over manual termination of threads, as it provides a reliable way for all threads to terminate, without race conditions and missing threads. However, it does have the limitation that it can only be used for threads within the same process, and not for threads in other processes.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#arguments","title":"Arguments","text":"<ul> <li><code>status</code>:<code>int</code> - This argument determines the status the process is finished with. It can be a negative number, signifying an error code, or 0 to signify a successful termination.</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit_group/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit_group/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#exit_group_1","title":"exit_group","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#purpose","title":"Purpose","text":"<p>Collecting information about the exit process</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#example-use-case","title":"Example Use Case","text":"<p>An application may use exit_group to ensure that all threads are properly terminated before the program ends. This can ensure that all resources the threads may be using are cleaned up correctly.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#issues","title":"Issues","text":"<p>exit_group can only terminate threads within the same process, and not threads from other processes.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#related-events","title":"Related Events","text":"<ul> <li>clone: used to be able to create multiple threads within the same process for the exit_group syscall to terminate.</li> <li>_exit: called by the exit_group syscall to terminate the process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/","title":"faccessat","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#intro","title":"Intro","text":"<p><code>faccessat</code> - Tests the accessibility of the file or directory referred to by file descriptor</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#description","title":"Description","text":"<p>The <code>faccessat</code> function checks whether the current user can access the file referred to by the file descriptor <code>dirfd</code> and <code>pathname</code>. It checks for the type of access indicated by <code>mode</code>, which is either F_OK (file existence check), R_OK (read permission check), W_OK (write permission check), or X_OK (execute permission check). The <code>flags</code> argument allows additional enhancements to the permission check. If <code>pathname</code> is an empty string, <code>faccessat</code> will check for the same permission in the directory referred to by <code>dirfd</code>.</p> <p>This function is useful when you want to check permissions of a file before opening it, in order to avoid any security issues related to time-of-check to time-of-use (TOCTOU) vulnerabilities.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd: int</code> - File descriptor of the directory containing the file to be checked  </li> <li><code>pathname: const char*</code> - Relative or absolute pathname of the file to be checked  </li> <li><code>mode: int</code> - Type of access to be checked, can be one of: </li> <li>F_OK - Permission existence check.</li> <li>R_OK - read permission check.</li> <li>W_OK - write permission check.</li> <li>X_OK - execute permission check. </li> <li><code>flags: int</code>[U,OPT] - Allows additional enhancements to the permission check. Currently only 0 and AT_EACCESS are supported.</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#sys_faccessat","title":"sys_faccessat","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#purpose","title":"Purpose","text":"<p>To capture syscalls made by processes and any errors that occur.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#example-use-case","title":"Example Use Case","text":"<p>One possible use case is to monitor user account permissions. This could be particularly useful for security monitoring of users and applications by using the <code>faccessat</code> syscall to check for allowed or denied access to files.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#issues","title":"Issues","text":"<p>There are potential TOCTOU (Time-of-check to Time-of-use) vulnerabilities associated with <code>faccessat</code>, as the permission check done by the syscall is not atomic, i.e. it can lead to inconsistent results because if permission is granted when checked, but then has changed to denied before the file is actually used, then the permission check may not be reliable.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#related-events","title":"Related Events","text":"<ul> <li><code>openat</code>: Used for opening files, and may be used in conjunction with <code>faccessat</code> to safely open files.</li> <li><code>stat</code>: Used for getting information about files, and can be useful to check for permission changes between checks done by the <code>faccessat</code> syscall.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/","title":"faccessat2","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#intro","title":"Intro","text":"<p>faccessat2 - check user's permissions for a file</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#description","title":"Description","text":"<p><code>faccessat2</code> is a system call that checks a given file's permission for the current user. It works by reading the permission bits of the file, then comparing those bits with the given mode. If the user has the requisite permission, the call succeeds; if not, the call fails with an error code. </p> <p>One limitation is that <code>faccessat2</code> works only on regular files - it is not able to make these checks on other kinds of objects such as devices, directories, UNIX sockets and so on. Additionally, the call is affected by Time-of-check/Time-of-use (TOCTOU) race conditions, thus extra care needs to be taken to ensure safety.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor from which the name of the file is to be read.</li> <li><code>path</code>:<code>const char*</code>[K,U] - Relative or absolute pathname for the file.</li> <li><code>mode</code>:<code>int</code>[K] - The mode to be checked for the given file descriptor and path.</li> <li><code>flag</code>:<code>int</code>[K,OPT] - Optional flags passed to the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#faccessat2_1","title":"faccessat2","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#purpose","title":"Purpose","text":"<p>To monitor the <code>faccessat2</code> syscall and keep track of the results of permission checks on files.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to solve the problem of unauthorized users trying to access files that they should not be able to access. Using the syscall one can check for the existence of files and their permission at the same time and in an atomic operation.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#issues","title":"Issues","text":"<p>There is a TOCTOU race condition, since between the time that the permission check is done and the time of use, the permission may have changed. Additionally, <code>faccessat2</code> will only work with regular files and not with other types such as directory, devices, etc.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#related-events","title":"Related Events","text":"<ul> <li>stat</li> <li>fstat</li> <li>fstatat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/","title":"fadvise64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#intro","title":"Intro","text":"<p>fadvise64 - system call that causes an advisory information about access pattern for a file region, in order to optimize file access.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#description","title":"Description","text":"<p>The fadvise64 system call advises the kernel about how a file will be accessed in the future, allowing the kernel to optimize its use of resources as appropriate. Given a file's descriptor <code>fd</code>, <code>offset</code> and <code>len</code> specify the size of the region offset that the advice applies to; the <code>advice</code> argument specifies the advice to be given.</p> <p>Advice is advisory only, and need not be followed. The <code>advice</code> argument is a bitmask the can take any combination of the following values:   - <code>POSIX_FADV_NORMAL</code>: No advice to give; the default assumption is that applications expect that read and write operations on the specified region will be performed in a reasonable amount of time.   - <code>POSIX_FADV_SEQUENTIAL</code>: The applications expects that the access will be a sequential access pattern.   - <code>POSIX_FADV_RANDOM</code>: The application expects that the access pattern will be a random access pattern.   - <code>POSIX_FADV_NOREUSE</code>: The application expects that the access pattern will be a read-only pattern and that the data will not be reused in the near future. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - File descriptor for the file in question.</li> <li><code>offset</code>:off_t[K] - Offset into the file for the start of the region the advice applies to.</li> <li><code>len</code>:size_t[K] - Length of the region to which advice applies.</li> <li><code>advice</code>:int[K] - Advice given. May be a combination of the available flags in bitmask form.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#sys_fadvise64","title":"sys_fadvise64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#purpose","title":"Purpose","text":"<p>To record information about the usage of fadvise64 and the advice being given.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#example-use-case","title":"Example Use Case","text":"<p>An example use case for fadvise64 would be a database application using a large file for its data. The application could call fadvise64 with the advice <code>POSIX_FADV_SEQUENTIAL</code> to indicate to the kernel that the data access on this file is likely to occur in a sequential fashion. This allows the kernel to optimize its disk scheduling, resulting in improved disk performance. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#issues","title":"Issues","text":"<p>When an application has not specified an access pattern to the kernel, it is not possible for the kernel to optimize its disk scheduling appropriately. As such, fadvise64 should not be used as a means of improving disk performance - it is only useful when an application can reliably determine an access pattern and communicate it to the kernel.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#related-events","title":"Related Events","text":"<ul> <li><code>fsync</code> - synchronizes a file's in-core state with storage device. </li> <li><code>openat</code> - opens a file from a given directory file descriptor. </li> <li><code>madvise</code> - system call advising the kernel about the address space access pattern.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/","title":"fadvise64_64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#intro","title":"Intro","text":"<p>fadvise64_64 - Informs the kernel of the application's advice on how it should handle the file associated with the given file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#description","title":"Description","text":"<p>The fadvise64_64 syscall is a system call that provides a mechanism for an application to advise the kernel of its behavior and access patterns for a file associated with a specified file descriptor. An application can provide strategies or smartly manage the page cache and associated hardware prefetch (e.g. disk read ahead) without accessing the data. fadvise64_64 provides an application with hints that allow it to better manage and group similar, potentially duplicate, data operations. </p> <p>The benefit of this syscall is that, since the kernel is more aware of an application's expectations, it can efficiently manage the operations, leading to improved performance and decreased user wait time. Additionally, fadvise64_64 allows an application to inform the kernel that a range of bytes, within a file, will not be accessed again in the foreseeable future. Thus, decreasing the work the kernel has to do and, thus, conserving system resources. </p> <p>On the other hand, the trade-off of using this syscall is that the kernel can no longer rely on application patterns in order to determine when to read ahead, or when to evict data from the page cache. This could lead to inefficiencies, as the application will now be responsible for data management.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor associated with the given data. </li> <li><code>offset</code>:<code>loff_t</code>[K] - Offset to which the advice is required for.</li> <li><code>len</code>:<code>loff_t</code>[K] - Length of the data which it is required to be effected by the given advice.</li> <li><code>advice</code>:<code>int</code>[K] - The advice which needs to be applied on the data associated with the given file descriptor. </li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#sys_fadvise64_64","title":"sys_fadvise64_64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#purpose","title":"Purpose","text":"<p>To allow the kernel to efficiently manage the operations of the application, leading to improved performance and decreased user wait time. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#example-use-case","title":"Example Use Case","text":"<p>As an example, an application that streams large chunks of data from a file to an output device. Since the data will be processed and sent off in large chunks, a streaming application can advise the kernel that the data will not be accessed again, eliminating the costly pagecache eviction operation.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#issues","title":"Issues","text":"<p>fadvise64_64 is currently unavailable on some architectures and platforms, such as MIPS. In other cases, a supported architecture or platform might be missing some features.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#related-events","title":"Related Events","text":"<ul> <li>read - to read data from a file descriptor.</li> <li>pread64 - to read from a file descriptor with a given offset.</li> <li>madvise - another syscall to advise the kernel on how it should manage memory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/","title":"fallocate","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#intro","title":"Intro","text":"<p>fallocate - System call to preallocate blocks of a file</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#description","title":"Description","text":"<p>The fallocate() system call is used to preallocate blocks for a file. The call guarantees the requested space for the file without allocating a physical storage, resulting in faster file access. This system call is not affected by the current size of a file, but rather allows it to extend the size immediately.  </p> <p>This syscall has some edge cases, such as when the file is on a filesystem which doesn't support fallocation, and when the file is located on a cluster filesystem. In such cases, a part of the requested area will be allocated, with the remaining blocks marked as needing allocation.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor. </li> <li><code>mode</code>:<code>int</code> - Operation type. A bitwise combination of the flags FALLOC_FL_KEEP_SIZE, FALLOC_FL_PUNCH_HOLE, FALLOC_FL_COLLAPSE_RANGE. FALLOC_FL_ZERO_RANGE is not supported from kernel 4.14 onwards.  </li> <li><code>offset</code>:<code>off_t</code> - Starting offset of requested space past the end of file.  </li> <li><code>len</code>:<code>off_t</code> - Length of requested space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fallocate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fallocate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#sys_fallocate","title":"sys_fallocate","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#purpose","title":"Purpose","text":"<p>To gather file descriptor and offset information, as well as the size of the file before and after the fallocation for a process.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to track a process' file write operations to disk. This can be helpful for debugging the performance of an application, as the syscall enables us to track how and when the application reserves and uses disk space.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#issues","title":"Issues","text":"<p>The fallocate syscall is not supported by some filesystems, thus the fallocation wont be completely successful. </p>"},{"location":"docs/events/builtin/syscalls/fallocate/#related-events","title":"Related Events","text":"<ul> <li>pwrite</li> <li>ftruncate</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/","title":"fanotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#intro","title":"Intro","text":"<p>fanotify_init - initialize fanotify handle</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#description","title":"Description","text":"<p>The fanotify_init() system call initializes the fanotify handle, which is  used  to  register  fanotify  events  and  mark  paths  and  files  to  be  monitored with the <code>fanotify_mark</code> system call. This call allocates the required structures, sets the given flags and allocates an event queue.</p> <p>A fanotify handle can be used to monitor events in multiple directories by calling the <code>fanotify_mark</code> system call and the returned file descriptor can be monitored with <code>select()</code>, <code>poll()</code> or <code>epoll_wait()</code>.</p> <p>The flags used in fanotify_init determine the behavior of the fanotify handle. Some of the available flags are <code>FAN_CLOEXEC</code>, <code>FAN_NONBLOCK</code> and <code>FAN_UNLIMITED_QUEUE</code>.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned int</code>[K] - set of flags used to determine the behavior of the fanotify handle.</li> <li><code>event_f_flags</code>:<code>unsigned int</code>[K] - set of event flags used to select the events to report to the fanotify handle.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#fanotify_init_1","title":"fanotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#purpose","title":"Purpose","text":"<p>To monitor events related to fanotify_init.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#example-use-case","title":"Example Use Case","text":"<p>A monitoring tool could use fanotify_init to create handles which it can then use to monitor files and directories for any changes and act on them.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#issues","title":"Issues","text":"<p>There is a known issue that fanotify_init does not support 64-bit arguments.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#related-events","title":"Related Events","text":"<ul> <li>fanotify_mark - set up fanotify notification</li> <li>fanotify_close - close fanotify notification</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/","title":"fanotify_mark","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#intro","title":"Intro","text":"<p>fanotify_mark - add an fanotify mark to a file or directory</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#description","title":"Description","text":"<p>The <code>fanotify_mark</code> system call adds an fanotify mark to a file or directory. The fanotify mark contains the mask argument, used to indicate the events we want to receive notifications about. This call allows for finer grained control over which filesystem events we monitor. The <code>fanotify_mark</code> system call also allows to set flags which control the behavior of the fanotify marks. This system call can be used to monitor files or directories on both block-level devices and in file systems.</p> <p>There are some drawbacks to using fanotify marks. First, when used on a directory, the <code>fanotify_mark</code> system call will only monitor the events related to the directory itself. It won't monitor any events occurring in the subdirectories or files underneath it. Second, fanotify marks only support limited types of events, such as open, read, write, and delete.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#arguments","title":"Arguments","text":"<ul> <li><code>fanotify_fd</code>:<code>int</code>[K] - File descriptor identifying fanotify instance.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags which control the behaviour of the fanotify marks.</li> <li><code>mask</code>:<code>u64</code>[K] - Mask of the filesystem events to be monitored.</li> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor identifying the directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - Pathname Relative to the file descriptor. The fanotify mark will be placed on all files and directories within this pathname, even if the file/directories don\u2019t exist yet.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#inotify_init","title":"inotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#purpose","title":"Purpose","text":"<p>To monitor the <code>inotify_init</code> functions</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#example-use-case","title":"Example Use Case","text":"<p>The fanotify_mark system call can be used to monitor access and changes made to files or directories. For example, this could be used to gain insight into application behavior. For example, an application could have access to a file and modify it, change the permission of a file, or delete a file, and these events would be tracked using the fanotify_mark system call.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#issues","title":"Issues","text":"<p>The fanotify_mark system call can only monitor fragments of the filesystem and can\u2019t track events that happen inside subdirectories or files. Also, some flags might not be supported in some kernel versions. </p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#related-events","title":"Related Events","text":"<p><code>fanotify_init</code> - create a file access notification event. <code>fanotify_init_group</code> - create a file access notification event (for groups).</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/","title":"fchdir","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#intro","title":"Intro","text":"<p>fchdir - Change the current working directory by file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#description","title":"Description","text":"<p>The fchdir() system call allows the application to change the current working directory by a file descriptor. This can be useful for applications that want to change the cwd for a child process without having to resort to absolute paths or up and down directory lookup. The file descriptor argument should refer to an open directory.</p> <p>There are some drawbacks to using fchdir(). Since it is an atomic operation, it will not take into account intervening changes to the directory structure. This can have security implications, therefore applications that are using fchdir() should be aware of potential time-of-check, time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor of an open directory that should be used as the new cwd.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#fchdir_1","title":"fchdir","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#purpose","title":"Purpose","text":"<p>To track changes in the current working directory and log the arguments associated with them.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#example-use-case","title":"Example Use Case","text":"<p>An application wants to change the cwd for its child process without having to resort to absolute paths or up and down directory lookup. </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#issues","title":"Issues","text":"<p>fchdir() is an atomic operation, so it will not take into account intervening changes to the directory structure. This can have security implications, as there may be potential time-of-check, time-of-use (TOCTOU) race conditions. </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#related-events","title":"Related Events","text":"<ul> <li>chdir - Change the current working directory</li> <li>open - Open a file (used to obtain the necessary file descriptor)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/","title":"fchmod","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#intro","title":"Intro","text":"<p>fchmod - change the permissions of an open file.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#description","title":"Description","text":"<p>The <code>fchmod()</code> system call is used to change the permissions of an open file, specified by the file descriptor <code>fd</code>. Unlike <code>chmod()</code>, <code>fchmod()</code> operates on an open file descriptor, which eliminates certain race conditions that might occur when using <code>chmod()</code>.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor of the file whose permissions are to be changed.</li> <li><code>mode</code>:<code>mode_t</code>[K] - A bitmask of permission bits that will be used to set the new permissions.</li> </ul> <pre><code>* `S_ISUID (04000)`: Set-user-ID (sets process effective user ID on `execve(2)`)\n* `S_ISGID (02000)`: Set-group-ID (sets process effective group ID on `execve(2)`; mandatory locking as described in `fcntl(2)`; takes a new file's group from parent directory as described in `chown(2)` and `mkdir(2)`)\n* `S_ISVTX (01000)`: Sticky bit (restricted deletion flag as described in `unlink(2)`)\n* `S_IRUSR (00400)`: Read by owner\n* `S_IWUSR (00200)`: Write by owner\n* `S_IXUSR (00100)`: Execute/search by owner (\"search\" applies for directories, allowing access to entries within)\n* `S_IRGRP (00040)`: Read by group\n* `S_IWGRP (00020)`: Write by group\n* `S_IXGRP (00010)`: Execute/search by group\n* `S_IROTH (00004)`: Read by others\n* `S_IWOTH (00002)`: Write by others\n* `S_IXOTH (00001)`: Execute/search by others\n</code></pre>"},{"location":"docs/events/builtin/syscalls/fchmod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#sys_fchmod","title":"sys_fchmod","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>fchmod()</code> system call is performed, collecting information about the file descriptor and the new permissions being set.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in file permissions in a system, especially when dealing with sensitive or critical files.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#issues","title":"Issues","text":"<p>The <code>fchmod()</code> system call avoids some of the TOCTOU issues associated with <code>chmod()</code> by operating on an open file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#related-events","title":"Related Events","text":"<ul> <li>chmod()</li> <li>fchmodat()</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/","title":"fchmodat","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#intro","title":"Intro","text":"<p>fchmodat - change permissions of a file relative to a directory file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#description","title":"Description","text":"<p>The <code>fchmodat()</code> system call allows changing the permissions of a specified file or directory, similar to <code>chmod()</code>.</p> <p>However, <code>fchmodat()</code> offers additional flexibility by operating relative to a directory identified by a file descriptor. This feature proves useful, especially when working with directory contexts where the absolute path to a target file or directory isn't directly known or accessible.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - File descriptor pointing to the directory relative to which the pathname is interpreted.</li> <li><code>pathname</code>: <code>const char *</code>[U] - The path of the file or directory whose permissions are to be changed.</li> <li><code>mode</code>: <code>mode_t</code>[K] - A bitmask specifying the new permissions to be set for the file or directory.</li> <li><code>flags</code>: <code>int</code>[K] - Flags that modify function behavior (e.g., <code>AT_SYMLINK_NOFOLLOW</code> ensures symbolic links aren't followed).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmodat/#permission-bits","title":"Permission Bits","text":"<ul> <li><code>S_ISUID (04000)</code>: Set-user-ID</li> <li><code>S_ISGID (02000)</code>: Set-group-ID</li> <li><code>S_ISVTX (01000)</code>: Sticky bit</li> <li><code>S_IRUSR (00400)</code>: Read by owner</li> <li><code>S_IWUSR (00200)</code>: Write by owner</li> <li><code>S_IXUSR (00100)</code>: Execute/search by owner</li> <li><code>S_IRGRP (00040)</code>: Read by group</li> <li><code>S_IWGRP (00020)</code>: Write by group</li> <li><code>S_IXGRP (00010)</code>: Execute/search by group</li> <li><code>S_IROTH (00004)</code>: Read by others</li> <li><code>S_IWOTH (00002)</code>: Write by others</li> <li><code>S_IXOTH (00001)</code>: Execute/search by others</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmodat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmodat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#sys_fchmodat","title":"sys_fchmodat","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#purpose","title":"Purpose","text":"<p>To observe and capture instances of the <code>fchmodat()</code> system call invocation, detailing the file or directory targeted, and the new permissions being set.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#example-use-case","title":"Example Use Case","text":"<p>In security-centric environments, tracking permissions alterations of files and directories is pivotal to ensure consistent access controls and prevent unauthorized access.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#issues","title":"Issues","text":"<p>Misuse of the <code>fchmodat()</code> system call can unintentionally expose sensitive files or directories, making them susceptible to unauthorized access or tampering.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#related-events","title":"Related Events","text":"<ul> <li><code>chmod()</code> - Change permissions of a file.</li> <li><code>fchmod()</code> - Change permissions of a file through its file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/fchown/","title":"fchown","text":""},{"location":"docs/events/builtin/syscalls/fchown/#intro","title":"Intro","text":"<p>fchown - change the owner and group of a file, using a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#description","title":"Description","text":"<p>The <code>fchown()</code> system call is used to change the owner and group of a specified file or directory, using a file descriptor to identify the file or directory. The new owner and group are specified by the <code>owner</code> and <code>group</code> arguments respectively.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor of the file or directory whose owner and group are to be changed.</li> <li><code>owner</code>:<code>uid_t</code>[K] - User identifier of the new owner.</li> <li><code>group</code>:<code>gid_t</code>[K] - Group identifier of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchown/#sys_fchown","title":"sys_fchown","text":""},{"location":"docs/events/builtin/syscalls/fchown/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/fchown/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>fchown()</code> system call is performed, collecting information about the file or directory, and the new owner and group.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in file or directory ownership in a system, especially in scenarios where file descriptors are used instead of file pathnames.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#issues","title":"Issues","text":"<p>Unlike <code>chown()</code>, the <code>fchown()</code> system call uses a file descriptor, which can provide a level of safety against TOCTOU (time of check, time of use) issues as the file descriptor references the actual object and not the pathname.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#related-events","title":"Related Events","text":"<ul> <li>chown()</li> <li>fchownat()</li> <li>lchown()</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/","title":"fchown16","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#intro","title":"Intro","text":"<p>fchown16 - Change the owner and group of the file referred to by the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#description","title":"Description","text":"<p>The fchown16() system call changes the ownership of the file referred to by the file descriptor fd.  The effective user ID of the process must match the existing owner of the file, or the process must have the appropriate privilege.</p> <p>This system call is equivalent to using fchownat() with the flag AT_EMPTY_PATH flag set.</p> <p>There are some drawbacks associated with using fchown16. First, fchown16 does not work on systems without a 16-bit UID/GID model, such as the Linux kernel. Second, it can potentially be insecure since it is not atomic, so it can be vulnerable to race conditions like TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>K - The file descriptor of the file.</li> <li><code>user</code>:<code>old_uid_t</code>K - The user ID of the new owner.</li> <li><code>group</code>:<code>old_gid_t</code>K - The group ID of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU- Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#sys_fchown16","title":"sys_fchown16","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#purpose","title":"Purpose","text":"<p>To track changes in the ownership of files.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#example-use-case","title":"Example Use Case","text":"<p>An application might use this system call to ensure that only certain users are able to access certain files or directories.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#issues","title":"Issues","text":"<p>This system call is not available on systems without a 16-bit UID/GID model, such as the Linux kernel. Additionally, the system call can be vulnerable to race conditions like TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#related-events","title":"Related Events","text":"<ul> <li>fchownat</li> <li>fstat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/","title":"fchownat","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#intro","title":"Intro","text":"<p>fchownat - change ownership of a file or directory relative to a directory file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#description","title":"Description","text":"<p>The <code>fchownat()</code> system call provides a mechanism to modify the ownership (both user and group) of a specified file or directory.</p> <p>Unlike the <code>chown()</code> system call, <code>fchownat()</code> allows operations relative to a directory referenced by a given file descriptor. This is particularly useful when working within specific directory contexts or when the exact path to a file or directory might not be directly accessible or known.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor pointing to the directory relative to which the pathname is interpreted.</li> <li><code>pathname</code>:<code>const char *</code>[U] - The path to the file or directory whose ownership is to be changed.</li> <li><code>owner</code>:<code>uid_t</code>[K] - The user ID to be set. If set to <code>-1</code>, the user ID isn't changed.</li> <li><code>group</code>:<code>gid_t</code>[K] - The group ID to be set. If set to <code>-1</code>, the group ID isn't changed.</li> <li><code>flags</code>:<code>int</code>[K] - Flags to modify function behavior (e.g., <code>AT_SYMLINK_NOFOLLOW</code> to not follow symbolic links).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchownat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchownat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#sys_fchownat","title":"sys_fchownat","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#purpose","title":"Purpose","text":"<p>To observe and record instances when the <code>fchownat()</code> system call is invoked, capturing details about the target file or directory, as well as the new ownership details.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#example-use-case","title":"Example Use Case","text":"<p>In environments with strict access controls, monitoring changes in file or directory ownership can be crucial to maintain security and data integrity.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#issues","title":"Issues","text":"<p>Inappropriate use or vulnerabilities linked to the <code>fchownat()</code> system call can potentially expose files or directories to unauthorized users, posing data integrity and security risks.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#related-events","title":"Related Events","text":"<ul> <li><code>chown()</code> - Change ownership of a file.</li> <li><code>lchown()</code> - Change ownership of a symbolic link.</li> <li><code>fchown()</code> - Change ownership of a file via its file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/","title":"fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#intro","title":"Intro","text":"<p>fcntl - Manipulates file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#description","title":"Description","text":"<p>The fcntl system call is used to manipulate a file descriptor.  It can be used to read and modify the flags associated with a particular file descriptor, including changing the non-blocking status and closing the file descriptor. It can also be used to implement file locking, sharing file descriptors between processes, and more.</p> <p>The function takes three arguments, a file descriptor <code>fd</code>, an action <code>cmd</code>, and an argument <code>arg</code>. Depending on the action, the argument may or may not be used and can contain various values.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - The file descriptor to manipulate.</li> <li><code>cmd</code>:<code>int</code> - The type of operation to perform.</li> <li><code>arg</code>:<code>unsigned long</code> - An optional argument for some of the operations.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#sys_fcntl","title":"sys_fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#purpose","title":"Purpose","text":"<p>To trace all calls to sys_fcntl and return values.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#example-use-case","title":"Example Use Case","text":"<p>Tracking all attempts to change the non-blocking status of any file descriptor for debugging or security purposes.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#related-events","title":"Related Events","text":"<ul> <li>open</li> <li>close</li> <li>read</li> <li>write</li> <li>lseek</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/","title":"fcntl64","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#intro","title":"Intro","text":"<p>fcntl64 - Used to manipulate file descriptor. </p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#description","title":"Description","text":"<p><code>fcntl64()</code> is a system call that is used to manipulate or get information about a file descriptor. It allows the caller to perform operations such as reading and writing to the descriptor, setting or clearing flags associated with the descriptor, or partitioning locks between processes.</p> <p>When manipulating file descriptors, there are several actions that can be performed: - <code>F_DUPFD</code>: Duplicates an existing file descriptor - <code>F_GETFD</code>: Gets the descriptor flags associated with the file descriptor - <code>F_SETFD</code>: Sets the descriptor flags associated with the file descriptor - <code>F_GETFL</code>: Gets the file status flags for the file descriptor - <code>F_SETFL</code>: Sets the file status flags for the file descriptor - <code>F_SETLK</code>: Sets a file lock - <code>F_GETLK</code>: Gets an existing lock from a given file</p> <p>When dealing with locks, it is important to note that there are two types of locks: - <code>F_RDLCK</code>: Places a read lock on a file - <code>F_WRLCK</code>: Places a write lock on a file</p> <p>There are also several advantages and drawbacks to using <code>fcntl64()</code>: - Advantage: Allows users to set or clear flags associated with a file descriptor without having to know the actual flag values themselves - Disadvantage: The <code>fcntl()</code> family of functions can be tricky to use correctly and require careful checking of return values to make sure that the desired actions were actually performed correctly</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor to manipulate or get information about</li> <li><code>cmd</code>:<code>int</code>[K] - Desired action to take on the file descriptor</li> <li><code>arg</code>:<code>unsigned long</code>[K] - Parameter associated with the command to be executed </li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#sys_fcntl","title":"sys_fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#type","title":"Type","text":"<p>KPROBES + KRETPROBES</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#purpose","title":"Purpose","text":"<p>To monitor requests to manipulate file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#example-use-case","title":"Example Use Case","text":"<p>A use case could be setting a read lock on a file before accessing it and then removing it immediately after, making sure that no other process can access it while it is being accessed. </p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#issues","title":"Issues","text":"<p>There are no known issues with using <code>fcntl64()</code>.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#related-events","title":"Related Events","text":"<ul> <li><code>open()</code> - Used to open a file descriptor.</li> <li><code>close()</code> - Used to close a file descriptor.</li> <li><code>dup()</code> - Used to duplicate a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/","title":"fdatasync","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#intro","title":"Intro","text":"<p>fdatasync - Synchronizes file data on disk with the fd.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#description","title":"Description","text":"<p>fdatasync is a system call used to synchronize the data stored in the memory with the disk associated to the fd. It ensures that the file will be written in the disk, as is visible to any process that has the file opened. This differs from fsync, which also synchronizes the file metadata (like access and modification times).</p> <p>The main advantage of using fdatasync is that it can be executed more efficiently, since it does not require a full flush of the file metadata. In addtion, the updated file data can be visible to other processes faster. However, this smaller efficiency comes with the cost of not being able to guarantee the integrity of the file metadata. A possible downside of using fdatasync is that it increases the chances of data corruption in case of power failures</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor associated to the file that will be synchronize.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fdatasync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fdatasync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#sys_fdatasync","title":"sys_fdatasync","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#purpose","title":"Purpose","text":"<p>To monitor when the fdatasync system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#example-use-case","title":"Example Use Case","text":"<p>fdatasync can be used in a backup software. By calling the fdatasync system call, it will make sure that the file is properly updated and synced in the disk before the backup takes place, thus avoiding any kind of data corruption if the system was to crash in the midst of the backup.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#issues","title":"Issues","text":"<p>Since the file metadata is not synced, in a power-loss situation it could lead to data inconsistency or corruption.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#related-events","title":"Related Events","text":"<ul> <li>fsync - Will make sure that the file data, and metadata, is correctly synchronize with the disk. This can provide a higher level of security but with a higher cost of performance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/","title":"fgetxattr","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#intro","title":"Intro","text":"<p>fgetxattr - get a extended attribute value in a file or directory</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#description","title":"Description","text":"<p>The <code>fgetxattr()</code> function retrieves the value of the extended attribute specified by name and associated with the file fd for the size of size bytes and places the result in value. </p> <p>The name argument points to a null-terminated string. The fd argument  is a file descriptor associated with an open file. The value argument is a pointer to a buffer that is at least size bytes in length. The size argument specifies the size of the buffer in bytes. Thus, if value points to a buffer that is too small a buffer to hold the value of the requested attribute, the size of the attribute is returned in size and no data is returned in value.</p> <p>There are several noteworthy edge cases with <code>fgetxattr()</code>. First, <code>fgetxattr()</code> will not follow symbolic links. Second, when used on relative paths, the path will be interpreted relative to the directory indicated by the fd argument. Lastly, if the value argument is NULL or the size argument is 0, then the size of the attribute will be returned in size without any data being returned in value.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor associated with an open file.</li> <li><code>name</code>:<code>const char*</code> - Name of the extended attribute. </li> <li><code>value</code>:<code>void*</code>[U] - Pointer to the buffer that will be filled with the attribute value. </li> <li><code>size</code>:<code>size_t</code> - Size of the buffer in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#do_fgetxattr","title":"do_fgetxattr","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#purpose","title":"Purpose","text":"<p>To spy on calls to the underlying <code>do_fgetxattr</code> kernel function and capture information about arguments and return values.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#example-use-case","title":"Example Use Case","text":"<p>Monitoring and auditing of programs that use <code>fgetxattr()</code> to retrieve extended attributes. </p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#issues","title":"Issues","text":"<p>The value argument must point to a buffer in user space. </p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#related-events","title":"Related Events","text":"<ul> <li>fsetxattr - Set a extended attribute value in a file or directory</li> <li>flistxattr - List extended attribute keys and associated values</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/","title":"finit_module","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#intro","title":"Intro","text":"<p>finit_module - load a kernel module from a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#description","title":"Description","text":"<p>The <code>finit_module()</code> system call allows for loading and initializing a kernel module using a file descriptor that points to the binary image of the module. This contrasts with <code>init_module()</code>, which directly uses a pointer to the binary image. By utilizing a file descriptor, <code>finit_module()</code> can effectively offer a safer means to load kernel modules, particularly in certain contexts where direct memory access is restricted or unsafe.</p> <p>Kernel modules serve as an essential mechanism to dynamically extend kernel functionalities without restarting the system, encompassing capabilities like device drivers, filesystems, and various protocols.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor corresponding to the binary image of the module.</li> <li><code>param_values</code>:<code>const char *</code>[U] - A string indicating module parameters, facilitating customization of the module's behavior. Parameters are generally denoted as \"param1=value1 param2=value2\".</li> <li><code>flags</code>:<code>int</code>[K] - Flags indicating how the module is to be loaded:<ul> <li><code>O_TRACE</code> - flag to trace module</li> <li><code>O_DEBUG</code> - debug flag</li> <li><code>O_ASYNC</code> - asynchronous initialization</li> <li><code>O_EXCL</code> - exclusive module initializing</li> </ul> </li> </ul>"},{"location":"docs/events/builtin/syscalls/finit_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/finit_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#sys_finit_module","title":"sys_finit_module","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#purpose","title":"Purpose","text":"<p>To observe and document the invocation of the <code>finit_module()</code> system call, capturing specifics about the module being loaded and its associated parameters.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#example-use-case","title":"Example Use Case","text":"<p>In security-sensitive scenarios, tracking the loading of kernel modules through file descriptors can be pivotal to detect unauthorized or anomalous behaviors, ensuring the integrity of the kernel environment.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#issues","title":"Issues","text":"<p>Introduction of malicious or defective kernel modules can introduce significant security threats or system instabilities. Rigorous validation and inspection of kernel modules before loading are paramount.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#related-events","title":"Related Events","text":"<ul> <li><code>init_module()</code> - Load a kernel module using a memory pointer.</li> <li><code>delete_module()</code> - Remove an already loaded kernel module.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/","title":"flistxattr","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#intro","title":"Intro","text":"<p>flistxattr - get a list of extented attributes of the file associated with a given file descriptor</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#description","title":"Description","text":"<p>The <code>flistxattr</code> system call is used to get the list of extended attribute names associated with a given file descriptor. It returns a buffer containing a list of the names of all of the extended attributes associated with the file, with each name separated by a null byte ('\\0'). The size of the buffer is specified in the argument <code>size</code>. If the size is not large enough, -1 is returned and <code>errno</code> is set to <code>ERANGE</code>.</p> <p>This system call is different from <code>listxattr</code> in the sense that instead of giving the path of the file in question, it receives its file descriptor, which means <code>flistxattr</code> only get the list of attributes of the exact file associated with the given descriptors, whereas <code>listxattr</code> can get the list of attributes of any file given its path.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of the target file, from which the extended attributes should be listed.</li> <li><code>list</code>:<code>char*</code>[U] - pointer to user-space memory, which will be filled with the list of extended attributes associated with <code>fd</code>.</li> <li><code>size</code>:<code>size_t</code>[K] - size of the <code>list</code> buffer. If not large enough to hold the list of all extended attributes associated with <code>fd</code>, the call fails with <code>error</code> set to <code>ERANGE</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/flistxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#do_flistxattr","title":"do_flistxattr","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#purpose","title":"Purpose","text":"<p>Monitor and log calls to <code>flistxattr</code>, as well as their return values, for debugging and security purposes.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#example-use-case","title":"Example Use Case","text":"<p>The <code>flistxattr</code> system call can be used as part of a larger application to get a list of all of the extended attributes associated with a file before attempting to access any of them. This can be especially useful for preventing potential Time-Of-Check To Time-Of-Use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#related-events","title":"Related Events","text":"<ul> <li><code>listxattr</code> - get the list of extended attributes associated with the file given the path</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/flock/","title":"flock","text":""},{"location":"docs/events/builtin/syscalls/flock/#intro","title":"Intro","text":"<p>flock - applies or removes an advisory lock on an open file</p>"},{"location":"docs/events/builtin/syscalls/flock/#description","title":"Description","text":"<p>The flock() system call applies or removes an advisory lock on an open file. A  lock is associated with an open file description (see open(2)). An open file  description locks a file against access by other open file descriptions. Locks  are established on a per open file description basis; these locks are unrelated to locks associated with the underlying inode.</p> <p>A call to flock() may block if an incompatible lock is held by another process. A nonblocking form of flock is defined in fcntl(2).</p>"},{"location":"docs/events/builtin/syscalls/flock/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - file descriptor of the file to lock/unlock</li> <li><code>operation</code>: <code>int</code>[K] - type of lock to perform (FLOCK_SH, FLOCK_EX, FLOCK_UN, etc)</li> </ul>"},{"location":"docs/events/builtin/syscalls/flock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/flock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/flock/#sys_flock","title":"sys_flock","text":""},{"location":"docs/events/builtin/syscalls/flock/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/flock/#purpose","title":"Purpose","text":"<p>Identify when processes are locking files.</p>"},{"location":"docs/events/builtin/syscalls/flock/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to analyse how long it takes a process to get a lock,  and also uncover cases of deadlocks.</p>"},{"location":"docs/events/builtin/syscalls/flock/#issues","title":"Issues","text":"<p>Since this is an advisory lock, if a process tries to get a lock on a file  that another process already has a lock on, the second process will block until  the lock is released, but there is no guarantee that the first process won't  modify the file before the second process can acquire the lock.</p>"},{"location":"docs/events/builtin/syscalls/flock/#related-events","title":"Related Events","text":"<ul> <li>fcntl - interfers with asynchronous input and output operations, file descriptor flags, and lock types</li> <li>open - creates or opens a file or devices</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fork/","title":"fork","text":""},{"location":"docs/events/builtin/syscalls/fork/#intro","title":"Intro","text":"<p>fork - create a copy of the process in the same address space.</p>"},{"location":"docs/events/builtin/syscalls/fork/#description","title":"Description","text":"<p>The Linux <code>fork()</code> system call creates a new process by duplicating the calling process. The new process is referred to as the child process and the calling process is referred to as the parent process. The child process created from the fork() system call has a copy of the parent process's entire address space. Therefore, when the parent process makes changes to any of its memory, these changes are visible to the child process - unlike <code>execve()</code> which completely overlays the address space of the creating process with the contents of the specified executable.</p> <p>The <code>fork()</code> system call returns twice; once in the parent process and once in the child process. In the parent process, the <code>fork()</code> system call returns the process ID (PID) of the newly-created child process. In the child process, the <code>fork()</code> system call returns 0.</p> <p>The <code>fork()</code> system call is synchronous, meaning the parent process waits for the child process to complete before proceeding. This is necessary for the parent and child processes to establish communication with each other.</p> <p>There are some drawbacks to using the <code>fork()</code> system call. First, the parent process should not change any of its memory before the child process exists, otherwise the child will inherit these changes which could lead to undefined behavior. Secondly, the overhead of switching between processes may adversely affect the performance of the system. Finally, the Linux <code>fork()</code> system call is limited to a maximum of 32 processes.</p>"},{"location":"docs/events/builtin/syscalls/fork/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[OPT] - Flags used to modify the behaviour of the <code>fork()</code> system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fork/#available-tags","title":"Available Tags","text":"<ol> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ol>"},{"location":"docs/events/builtin/syscalls/fork/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fork/#do_fork","title":"do_fork","text":""},{"location":"docs/events/builtin/syscalls/fork/#type","title":"Type","text":"<p>Tracepoint + Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/fork/#purpose","title":"Purpose","text":"<p>For usage and profiling analysis.</p>"},{"location":"docs/events/builtin/syscalls/fork/#example-use-case","title":"Example Use Case","text":"<p>The <code>fork()</code> system call can be used to create a child process so that the parent process can execute a separate task in parallel and communicate with the child process to return a result. In this way, the parent process does not have to wait for the child process to complete before continuing execution.</p>"},{"location":"docs/events/builtin/syscalls/fork/#issues","title":"Issues","text":"<p>Linux imposes a hard limit of 32 process creations via fork.</p>"},{"location":"docs/events/builtin/syscalls/fork/#related-events","title":"Related Events","text":"<ul> <li><code>execve</code> - execute a program.</li> <li><code>clone</code> - create a child processes or threads.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/","title":"fremovexattr","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#intro","title":"Intro","text":"<p>fremovexattr - an event that allows getting or removing an extended attribute associated with a file</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#description","title":"Description","text":"<p>The fremovexattr event is used to remove an extended attribute associated with a file specified by the file descriptor. This event allows for the removal of an attribute from any filetype, including regular files and directories. This event does not traverse through directories in order to remove extended attributes from subdirectories. Additionally, this event can also be used to securely delete files as it allows for file data blocks to be marked as deleted in the filesystem, thus preventing their recovery.</p> <p>The fremovexattr event takes two parameters: the filedescriptor of the file for which the attribute is being removed (fd) and the name of the extended attribute (name). This event does not return any information to the user and will return an error if the attribute was not found or if the user does not have the correct priviledges.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - A valid file descriptor of the file whose extended attribute should be removed.</li> <li><code>name</code>: <code>const char*</code>[K, U, TOCTOU] - Specifies the extended attribute to be removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#fremovexattr_1","title":"fremovexattr","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#purpose","title":"Purpose","text":"<p>Hook this function in order to detect the attempted removal of an extended attribute associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#example-use-case","title":"Example Use Case","text":"<p>fremovexattr can be used to detect privilege escalation attempts, as an attacker might try to change the extended attributes of files in order to gain access to confidential data. This event can also be used to detect a malicious user attempting to delete a sensitive file.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#issues","title":"Issues","text":"<p>Because of the TOCTOU vulnerability of this event, if an attacker manages to access the same file descriptor before the event is called, it may be possible for the argument value to change in between the time of check and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#related-events","title":"Related Events","text":"<ul> <li>fgetxattr</li> <li>fsetxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/","title":"fsconfig","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#intro","title":"Intro","text":"<p><code>fsconfig</code> - system call allowing to assign configurations to filesystem types</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#description","title":"Description","text":"<p>The <code>fsconfig</code> system call allows to assign configurations, expressed as a key-value pair, to the filesystem type (defined by the passed <code>fs_fd</code>). </p> <p>It is used as an extensible interface for programs and libraries to define, query and update configuration parameters. </p> <p>The same key might occur multiple times (path, then tag or namespace) so the <code>fsconfig</code> system call requires the passing of an auxiliary argument, the <code>aux</code> argument, to provide context.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#arguments","title":"Arguments","text":"<ul> <li><code>fs_fd</code>:<code>int*</code> - Pointer to a file descriptor pointing to the filesystem.</li> <li><code>cmd</code>:<code>unsigned int</code> - Command requesting a specific operation. It should be one of the <code>FSCONFIG_CMD_*</code> definitions defined in the include/uapi/linux/fsconfig.h - include/uapi/linux/fsconfig.h.  </li> <li><code>key</code>:<code>const char*</code> - Null-terminated key string whose format depends on the specific FS and context. Its length must not exceed <code>FSCONFIG_MAX_NAME</code>.</li> <li><code>value</code>:<code>const void*</code> - Pointer to a memory area containing the value for the configuration. Its length must not exceed <code>FSCONFIG_MAX_VALUE</code>.</li> <li><code>aux</code>:<code>int</code> - Auxiliary data used to provide context for the configuration (path, tag or namespace). Its length must not exceed <code>FSCONFIG_MAX_AUX</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsconfig/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsconfig/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#fsconfig_1","title":"fsconfig","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#purpose","title":"Purpose","text":"<p>To expose the data of the syscall request, the return code and the response value.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#example-use-case","title":"Example Use Case","text":"<p>fsconfig can be used to query and set configuration parameters on a filesystem. One example is setting access control lists on a filesystem in order to provide additional security measures.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#issues","title":"Issues","text":"<p>fsconfig is vulnerable to TOCTOU (Time of Check, Time of Use) attacks as its arguments are not checked on entry point and various events might have happened between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#related-events","title":"Related Events","text":"<ul> <li>fstatfs: get filesystem status.</li> <li>fscache: query the configuration from the filesystem cache.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/","title":"fsetxattr","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#intro","title":"Intro","text":"<p>fsetxattr - Set an extended attribute for a file</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#description","title":"Description","text":"<p>The <code>fsetxattr()</code> system call sets an extended attribute for the given file system object relative to the open file descriptor <code>fd</code>. The open file descriptor <code>fd</code> is used to reference the object which should have the attribute set.</p> <p>The <code>flags</code> argument determines how the attribute is set. Attributes are creation, security, scalability and installation related informations.</p> <p>Advantages of using <code>fsetxattr()</code> is that it provides more control than <code>setxattr()</code>, which is an analogous system call, that is used to affect the objects inside a file system.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor. The file descriptor should reference a regular file.</li> <li><code>name</code>:<code>const char*</code>[K] - Name of the attribute.</li> <li><code>value</code>:<code>const void*</code>[K U] - Pointer to the supplied value. Its format is determined by the implementation.</li> <li><code>size</code>:<code>size_t</code>[K] - Size of the value referenced in the <code>value</code> argument.</li> <li><code>flags</code>:<code>int</code>[K] - Flags designating how the attribute should be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#do_fsetxattr","title":"do_fsetxattr","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#purpose","title":"Purpose","text":"<p>To monitor the execution of <code>fsetxattr()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor the setting of custom attributes on files through the <code>fsetxattr()</code> system call. This is useful for implementing metadata management, security policies or system customization features.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#issues","title":"Issues","text":"<p>If the <code>flags</code> argument is not being checked, an attacker could set an extended attribute for a file that it shouldn't have access to.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#related-events","title":"Related Events","text":"<ul> <li><code>fgetxattr</code> - Get an extended attribute from a file</li> <li><code>setxattr</code> - Set an extended attribute to a file</li> <li><code>removexattr</code> - Remove an extended attribute from a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/","title":"fsmount","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#intro","title":"Intro","text":"<p>fsmount - Mounts a filesystem from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#description","title":"Description","text":"<p>The <code>fsmount</code> syscall is used to mount a filesystem from a file descriptor. This syscall was added in Linux 3.3 and does not support old filesystem types such as FAT or msdos. The flags and ms_flags arguments can be used to modify the mount, such as enabling optional mount features or changing mount propagation options.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#arguments","title":"Arguments","text":"<ul> <li><code>fsfd</code>:<code>int</code> - File descriptor for the existing superblock of the filesystem.</li> <li><code>flags</code>:<code>unsigned int</code> - Flags to modify the mount behavior, as described in the <code>MS_*</code> macros in <code>&lt;sys/mount.h&gt;</code>. This value can be 0 to perform a plain mount.</li> <li><code>ms_flags</code>:<code>unsigned int</code> - Special flags to modify the mount behavior, as described in the <code>MS_*</code> macros in <code>&lt;sys/mount.h&gt;</code>. This value can be 0 to perform a plain mount.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsmount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsmount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#do_mount","title":"do_mount","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#purpose","title":"Purpose","text":"<p>Hooked to investigate the mount call, such as which filesystem is being mounted or what arguments are used.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#example-use-case","title":"Example Use Case","text":"<p>The <code>fsmount</code> syscall can be used when developing distributed file systems, such as Gluster, to mount a remote filesystem in the local system.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#issues","title":"Issues","text":"<p>There is no direct way to specify the mount point for the filesystem that is being mounted when using <code>fsmount</code>.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#related-events","title":"Related Events","text":"<ul> <li>do_mount - Used to indicate when the system is mounting a filesystem.</li> <li>execve - Used to initiate processes that will mount a filesystem, such as <code>/sbin/mount</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/","title":"fsopen","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#intro","title":"Intro","text":"<p>fsopen - opens an existing filesystem for use with an allocated file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#description","title":"Description","text":"<p>The fsopen system call opens an existing filesystem for use with an allocated file descriptor. The file descriptor will provide access to the filesystem, and may be used with other system calls such as fsread, fswrite, and fstat. The filesystem must be specified by its name, which is given in the argument fsname. A set of flags, given in the argument flags, can be used to modify the behaviour of the fsopen system call.</p> <p>There are several potential scenarios and edge-cases in using the fsopen system call. In particular, the system call is vulnerable to TOCTOU (time-of-check-time-of-use) attacks, where the file or filesystem may have been changed between the time it was checked for existence and the time the fsopen system call is actually made. Additionally, the flags argument may not be available in some cases, in which case the call will be invoked with a value of 0.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#arguments","title":"Arguments","text":"<ul> <li><code>fsname</code>:<code>const char*</code>[KU] - name of the filesystem that is to be opened.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that modify the behaviour of the open system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsopen/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsopen/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#do_fsopen","title":"do_fsopen","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#purpose","title":"Purpose","text":"<p>To trace entry point for fsopen system call.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#example-use-case","title":"Example Use Case","text":"<p>The fsopen system call can be used to open an existing filesystem for access and, with other system calls such as fsread, fswrite, and fstat, allow programs to interact with the filesystem. For example, a program may read and write to files on the filesystem.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#issues","title":"Issues","text":"<p>The fsopen system call is vulnerable to TOCTOU attacks, where the file or filesystem may have been changed between the time it was checked for existence and the time the fsopen system call is actually made. Additionally, the flags argument may not be available in some cases, in which case the call will be invoked with a value of 0.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#related-events","title":"Related Events","text":"<ul> <li>fsread</li> <li>fswrite</li> <li>fstat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fspick/","title":"fspick","text":""},{"location":"docs/events/builtin/syscalls/fspick/#intro","title":"Intro","text":"<p>fspick - Select/open/unlink files in Linux systems.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#description","title":"Description","text":"<p><code>fspick</code> is used to open/select or unlink files from the file system. It is usually used to verify if a particular file exists in a certain directory. The <code>flags</code> parameter can be used to control how to open the file and if it should be opened exclusively.</p> <p>The <code>pathname</code> is supplied either as an absolute path or relative to an open file pointer pointed by <code>dirfd</code>. The value can be obtained from one of the <code>open</code>/<code>creat</code> syscalls. Thus, if the <code>dirfd</code> parameter is set to <code>AT_FDCWD</code>, the <code>pathname</code> should be an absolute path.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor to the directory from which <code>pathname</code> will be evaluated. If the value is set to <code>AT_FDCWD</code>, <code>pathname</code> should be an absolute path.</li> <li><code>pathname</code>:<code>const char*</code>[K] - The target filename or directory to open.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags defining whether or not the file should be opened in an exclusive mode, or just for reading and writing.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fspick/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fspick/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fspick/#sys_fspick","title":"sys_fspick","text":""},{"location":"docs/events/builtin/syscalls/fspick/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fspick/#purpose","title":"Purpose","text":"<p>Monitoring of incoming and outgoing calls to the <code>fspick</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#example-use-case","title":"Example Use Case","text":"<p>Using the <code>fspick</code> syscall to verify if a particular file exists in a certain directory before attempting to open it.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#related-events","title":"Related Events","text":"<p><code>open</code>, <code>access</code>, <code>stat</code>, <code>lstat</code>, <code>utimensat</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstat/","title":"fstat","text":""},{"location":"docs/events/builtin/syscalls/fstat/#intro","title":"Intro","text":"<p>fstat - get file status</p>"},{"location":"docs/events/builtin/syscalls/fstat/#description","title":"Description","text":"<p>The fstat() system call obtains information about an open file based upon the file descriptor fd argument. The information is stored in the stat buffer pointed to by statbuf\u2014which is of type struct stat, defined in . <p>One advantage of fstat() is that it does not require opening the file prior to obtaining information about it. This can be useful for supporting access control, logging file accesses, etc. It has some potential downfalls, including the fact that a file can be removed from the system by the time the fstat() function is executed, making it vulnerable to a Time of Check, Time of Use (TOCTOU) race condition attack.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor provided when the file was opened.</li> <li><code>statbuf</code>:<code>struct stat*</code>[KU] - Pointer to a struct stat that will have the information about the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstat/#fsys_fstat","title":"fsys_fstat","text":""},{"location":"docs/events/builtin/syscalls/fstat/#type","title":"Type","text":"<p>kprobe + uprobe.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#purpose","title":"Purpose","text":"<p>Hook the fstat() syscall entry point to get start latency and count how many times the syscall was called.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#example-use-case","title":"Example Use Case","text":"<p>For example, an application may use fstat() to determine whether or not a file is a directory. This can be useful for implementing access control mechanisms or logging accesses to files.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#issues","title":"Issues","text":"<p>Due to fstat() not requiring a file to be opened before calling the function, hense not locking it, it is vulnerable to TOCTOU race condition attacks.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#related-events","title":"Related Events","text":"<p>close, open, stat.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/","title":"fstat64","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#intro","title":"Intro","text":"<p>fstat64 - retrieves information about a specific file</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#description","title":"Description","text":"<p>The fstat64() system call is used to retrieve information about a specific file, given a file descriptor. This information includes the file size, the time of last access, etc. The function copies the information into a structure of type stat64, which is then filled with the information about the file. The file descriptor is typically used to identify a previously opened file.</p> <p>The fstat64() system call is most notably used when a file is opened, in order to obtain information about it. However, it can also be used to check the existence of the file and to check the permissions associated with it.</p> <p>The fstat64() system call has some drawbacks. It can only operate on a previously opened file, so it is not applicable if no file descriptor is associated with the file. Furthermore, since it is a system call, it can be expensive in terms of performance, particularly when called on a regular basis.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File Descriptor. The file on which the system call is to operate on. </li> <li><code>statbuf</code>:<code>struct stat64*</code>[U] - Pointer to a struct stat64, which contains the information retrieved by the system call. </li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#do_fstat64","title":"do_fstat64","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#purpose","title":"Purpose","text":"<p>Hooked function for the fstat64 system call, used to get information about a specific file given a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#example-use-case","title":"Example Use Case","text":"<p>The fstat64 system call can be used in cases when some basic information about a file is needed, such as its size, access time, or other similar info. For example, it could be used to implement a basic basename command which prints the basename, or file name, of a given file. In this case, fstat64 would be used to get information about the file, and then the basename could be extracted from that information.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#related-events","title":"Related Events","text":"<ul> <li>open: opens or creates a file or directory</li> <li>stat: stat() is the generic system call for getting information about a file. It can use the same underlying system call as fstat64() but is not limited to files that are opened using a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/","title":"fstatfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#intro","title":"Intro","text":"<p>fstatfs - retrieves information about a mounted file system</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#description","title":"Description","text":"<p><code>fstatfs()</code> is used to retrieve relevant information about a mounted file system. It returns information like the file system type, size, blocks, and block size. It is useful for getting information about drives and determining their capacity. The <code>fstatfs()</code> system call can be used to check for errors or malfunctioning disks.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - A file descriptor associated with the mounted file system.</li> <li><code>buf</code>: <code>struct statfs*</code> - A pointer to a <code>struct statfs</code> object which will contain information about the mounted file system after the system call returns.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#sys_fstatfs","title":"sys_fstatfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#purpose","title":"Purpose","text":"<p>To show when a filesystem is queried for information.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#sys_statfs","title":"sys_statfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#type_1","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#purpose_1","title":"Purpose","text":"<p>To show when a filesystem is queried for information.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#example-use-case","title":"Example Use Case","text":"<p>The <code>fstatfs()</code> system call can be used to check for errors or malfunctioning disks. For example, there may be an application that regularly checks disk space and reports errors if a disk is malfunctioning or full. The <code>fstatfs()</code> system call can be used to get the disk size, detect any errors, and report any issue to the user.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#issues","title":"Issues","text":"<p>There is no issue known with <code>fstatfs()</code>.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#related-events","title":"Related Events","text":"<p><code>fstatfs64()</code>, <code>statfs()</code>, <code>statfs64()</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/","title":"fstatfs64","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#intro","title":"Intro","text":"<p>fstatfs64 - get information about a mounted file system</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#description","title":"Description","text":"<p>The <code>fstatfs64()</code> system call is used to get file system statistics about a mounted file system. It is similar to the <code>statfs()</code> system call, but it uses a <code>struct statfs64</code> for the buffer argument. Since file systems can have large size values up to 8 bytes, this system call also allows for 8-byte aligned <code>struct statfs64</code> arguments.</p> <p>The <code>fstatfs64()</code> system call can be used to obtain information about mounted block devices or image files, and the returned information includes the mounted location, file system type, number of free blocks and free inodes, the block size, and the optimal transfer size.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[U] - file descriptor of a mounted file system</li> <li><code>sz</code>:<code>size_t</code>[K] - size of the <code>struct statfs64</code> which stores the information about the given file system</li> <li><code>buf</code>:<code>struct statfs64*</code>[U TOCTOU] - pointer to an allocated <code>struct statfs64</code> where the file system information will be stored</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#sys_fstatfs64","title":"sys_fstatfs64","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#purpose","title":"Purpose","text":"<p>The purpose of the sys_fstatfs64 hooks is to monitor the use of this system call by user processes.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#mount_fs","title":"mount_fs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#purpose_1","title":"Purpose","text":"<p>The purpose of the mount_fs hook is to monitor when a filesystem is mounted or unmounted.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#example-use-case","title":"Example Use Case","text":"<p>Using the fstatfs64 system call it is possible to get information about all mounted file systems. This information can be used to generate reports about system state or can be used to compare different mounts for various reasons.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#issues","title":"Issues","text":"<p>Since fstatfs64 uses a time of check to time of use technique, that means that the information might become outdated during the process. When this system call is used, it is important to consider if this type of race condition can occur and how it affects the application logic.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#related-events","title":"Related Events","text":"<ul> <li>statfs - similar system call but uses a <code>struct statfs</code> argument instead.</li> <li>getdents64 - get directory entries in a directory</li> <li>open - open a file or directory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsync/","title":"fsync","text":""},{"location":"docs/events/builtin/syscalls/fsync/#intro","title":"Intro","text":"<p>fsync - synchronizes a file's in-memory state with the physical storage device</p>"},{"location":"docs/events/builtin/syscalls/fsync/#description","title":"Description","text":"<p>The fsync function is a system call that is used to flush, or synchronize, the in-memory state of a file with the device containing the file. This is useful for ensuring that important data is not lost in the case of a system crash or  loss of power. The fsync call ensures that the contents of the file, as well  as associated data structures (such as the inode) are correctly written out to  the device before the call returns. It is also used when programs want to be  sure that their changes have been written back to the device.</p> <p>One of the drawbacks of using fsync is that it can be computationally expensive as it must ensure that all of the relevant data structures are correctly written out to the device.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of the file to be synchronized with the device.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsync/#sys_fsync","title":"sys_fsync","text":""},{"location":"docs/events/builtin/syscalls/fsync/#type","title":"Type","text":"<p>kprobe + prof</p>"},{"location":"docs/events/builtin/syscalls/fsync/#purpose","title":"Purpose","text":"<p>To track the invocation of the fsync syscall and evaluate its impact on performance or system resources.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#example-use-case","title":"Example Use Case","text":"<p>fsync could be used when a user wants to make sure that the changes they have made to a file have been written to the device before they do something else with the file.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#issues","title":"Issues","text":"<p>Some systems can be vulnerable to a Resource Attack when fsync is used. This can occur if an attacker is able to send a large number of requests which trigger the fsync call.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#related-events","title":"Related Events","text":"<ul> <li>open - used to open a file descriptor for use with fsync.</li> <li>close - used to close the file descriptor after the fsync call has been completed.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftime/","title":"ftime","text":""},{"location":"docs/events/builtin/syscalls/ftime/#intro","title":"Intro","text":"<p>ftime - Get and set the current system time</p>"},{"location":"docs/events/builtin/syscalls/ftime/#description","title":"Description","text":"<p>The ftime() function gets the current time of day, expressed in seconds and milliseconds since the Epoch (00:00:00 UTC, January 1, 1970). It has the following parameters:</p> <ul> <li><code>buf</code>:<code>struct timeb *</code>[K] - a pointer to a <code>struct timeb</code> which will be filled in with the current time and date.</li> <li><code>tz</code>:<code>struct timezone *</code>[K] - an optional pointer to a <code>struct timezone</code>, which if supplied, is filled in with information about the local timezone.</li> </ul> <p>For both of these parameters, passing <code>NULL</code> will simply indicate that you do not want to receive the corresponding information.</p> <p>Using ftime() is not recommended for obtaining the current date and time, as there are more accurate methods, but it is most commonly used for calculating the execution time of a program.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftime/#ftime_1","title":"ftime","text":""},{"location":"docs/events/builtin/syscalls/ftime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftime/#purpose","title":"Purpose","text":"<p>To observe the execution of ftime and observe the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#example-use-case","title":"Example Use Case","text":"<p>One use case for ftime would be to measure the time taken for a certain process or program to be completed. This can be done by obtaining the current time with ftime() before and after an operation, then subtracting the two to get the execution time.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#issues","title":"Issues","text":"<p>The resolution of ftime() is limited at milliseconds, so it is not suitable for performance tuning operations for which higher accuracy is required.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#related-events","title":"Related Events","text":"<p>clock_gettime</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/","title":"ftruncate","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#intro","title":"Intro","text":"<p>ftruncate - scan event that occurs when the function is called to truncate a file</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#description","title":"Description","text":"<p>The ftruncate() function truncates the file referenced by fd to the length specified by length. If the file previously was larger than length, the extra data is discarded. If the file previously was shorter, it is extended and the extended part reads as null bytes.</p> <p>The ftruncate() function can be used to resize just the size of the file, without altering its contents.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - file descriptor for the file to be truncated </li> <li><code>length</code>:off_t[K] - desired length of the file</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#sys_ftruncate","title":"sys_ftruncate","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#purpose","title":"Purpose","text":"<p>To measure the size of the file before and after the truncate.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#example-use-case","title":"Example Use Case","text":"<p>ftruncate() can be used to truncate a log file after it has exceeded a certain size. </p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#issues","title":"Issues","text":"<p>If the ftruncate operation fails, it returns -1 and sets errno.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#related-events","title":"Related Events","text":"<ul> <li>fstat - to obtain information about file size prior to truncating </li> <li>open - to obtain a file descriptor for a given file </li> <li>write - to write to a file </li> <li>read - to reed from a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/","title":"ftruncate64","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#intro","title":"Intro","text":"<p>ftruncate64 - Truncate a file to a specified length, 64 bit version.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#description","title":"Description","text":"<p>ftruncate64() truncates the given file to a specified length. It should not be assumed that the file offset is maintained or set to zero after a call to ftruncate64().  The specified length can be larger or smaller than the current size of the file, with the latter case causing the file to be truncated. The new size of the file can be obtained using fstat64().</p> <p>Edge-cases or drawbacks appear mostly if the file is opened in append mode or the file size is greater than the size allowed in the filesystem.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor for the file to be truncated.</li> <li><code>length</code>:<code>off_t</code> - Desired length of the file, after truncation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#sys_ftruncate64","title":"sys_ftruncate64","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#purpose","title":"Purpose","text":"<p>Observe the behavior of the ftruncate64 syscall.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#example-use-case","title":"Example Use Case","text":"<p>ftruncate64() could be used to improve performance of a program that reads and writes large chunks of data to the same file, when multiple threads are used for the task. When the thread reading from the file is finished, the file length can be reduced and the other thread will not need to process the extra data, as it will no longer be available.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#issues","title":"Issues","text":"<p>If the file is opened in append mode, it can lead to unexpected results.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#related-events","title":"Related Events","text":"<ul> <li>ftruncate() - The same functionality without the 64-bit length support.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futex/","title":"Futex","text":""},{"location":"docs/events/builtin/syscalls/futex/#intro","title":"Intro","text":"<p>Futex - a syscall to facilitate fast user-space locking.</p>"},{"location":"docs/events/builtin/syscalls/futex/#description","title":"Description","text":"<p>The <code>futex()</code> system call provides a method for a program to wait until a certain condition becomes true, or to signal that a certain condition has become true. The program specifies a pointer to the memory address (<code>uaddr</code>) in which it saves the condition, a value (<code>val</code>) which indicates the condition, and a timeout (<code>timeout</code>) after which the wait returns automatically. Additionally, a set of operations (<code>futex_op</code>) can be specified which act on the condition represented by <code>uaddr</code>.</p> <p>The <code>futex()</code> system call is useful for coordinating access to shared data structures between multiple processes, as the operations it provides can be used to create simple mutexes. It is typically used by higher-level libraries like POSIX Threads, which allows for the use of <code>pthread_mutex_lock()</code> and related functions to control access to shared memory.</p>"},{"location":"docs/events/builtin/syscalls/futex/#arguments","title":"Arguments","text":"<ul> <li><code>uaddr</code>:<code>int*</code>[K, TOCTOU] - A pointer to the memory address in which the caller saves the condition. If a valid pointer is passed, the system call will inspect and modify the value this pointer points to.</li> <li><code>futex_op</code>:<code>int</code>[K] - A set of flags which control the operation that should be performed on the wait queue.</li> <li><code>val</code>:<code>int</code>[K] - An integral value which represents the condition. This will be compared to the value pointed to by <code>uaddr</code> on each operation.</li> <li><code>timeout</code>: <code>const struct timespec*</code>[K] - A pointer to a <code>struct timespec</code> that indicates the timeout after which the wait returns automatically. If the pointer passed is a NULL pointer, the wait does not time out. </li> <li><code>uaddr2</code>:<code>int*</code>[K, TOCTOU] - A pointer to a second memory address with a second condition.</li> <li><code>val3</code>:<code>int</code>[K] - The second condition value. This will be compared to the value pointed to by  <code>uaddr2</code> on each operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futex/#sys_futex","title":"sys_futex","text":""},{"location":"docs/events/builtin/syscalls/futex/#type","title":"Type","text":"<p>Kprobes + Jprobes</p>"},{"location":"docs/events/builtin/syscalls/futex/#purpose","title":"Purpose","text":"<p>To allow deeper analysis of the system call, including arguments and its return value.</p>"},{"location":"docs/events/builtin/syscalls/futex/#example-use-case","title":"Example Use Case","text":"<p>The <code>futex()</code> system call is used to create simple user-space locks that can be used to coordinate access to shared resources in a multi-process environment.</p>"},{"location":"docs/events/builtin/syscalls/futex/#issues","title":"Issues","text":"<ul> <li>The values of both <code>uaddr</code> and <code>uaddr2</code> arguments are vulnerable to TOCTOU attacks, which may allow an attacker to bypass the lock and gain access to a shared resource.</li> <li>If the timeout is set too short, requests might not be able to complete in time and the application might deadlock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#related-events","title":"Related Events","text":"<p><code>futex_wait</code>, <code>futex_wake</code>, <code>futextime64</code>, <code>futextime64_wait</code>, <code>futex_wake_op</code>, <code>futex_wake_op_pi</code>, <code>futex_lock_pi</code>, <code>futex_unlock_pi</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/","title":"futex_time32","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#intro","title":"Intro","text":"<p>futex_time32 - wait on/fetch a word from user-space and potentially wait for a timeout</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#description","title":"Description","text":"<p>The <code>futex_time32</code> system call provides the ability to wait on a given word in user-space memory, potentially with a timeout. It allows the caller to specify an absolute timeout or a relative timeout with <code>CLOCK_MONOTONIC</code>. The return value contains information about the current value of the word at the address and whether a timeout was specified and/or was triggered.</p> <p>The <code>futex_time32</code> system call is atomic and requires no extra synchronization mechanisms. In addition, it supports operations like <code>FUTEX_WAIT</code> and <code>FUTEX_WAKE</code> using a single call, which can be useful in certain situations. However, the system call is vulnerable to the TOCTOU (Time of Check, Time of Use) race condition, as the user-space memory address is checked prior to being acted upon.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#arguments","title":"Arguments","text":"<ul> <li><code>uaddr</code>:<code>u32*</code>[KU] - pointer to a user-space word variable.</li> <li><code>op</code>:<code>int</code>[K] - operation to perform, one of the FUTEX_* constants listed in <code>&lt;linux/futex.h&gt;</code>.</li> <li><code>val</code>:<code>u32</code>[K] - operation-dependent value.</li> <li><code>utime</code>:<code>struct old_timespec32</code>[K] - timeout value in milliseconds or CLOCK_MONOTONIC based absolute value.</li> <li><code>uaddr2</code>:<code>u32*</code>[KU OPT] - second user-space word variable if two FUTEX_* operations need to be performed atomically.</li> <li><code>val3</code>:<code>u32</code>[K OPT] - second operaion-dependent value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#futex_wait_setup","title":"futex_wait_setup","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#purpose","title":"Purpose","text":"<p>Called before a FUTEX_WAIT system call is processed, which allows tracing of the arguments and the variable before the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#example-use-case","title":"Example Use Case","text":"<p>A multithreaded application might use <code>futex_time32</code> to synchronize between threads, performing an operation in an atomic manner and waiting on a condition with the possibility of a timeout.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#issues","title":"Issues","text":"<p>The <code>futex_time32</code> system call is vulnerable to the TOCTOU (Time of Check, Time of Use) race condition, as the user-space memory address is checked prior to being acted upon.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#related-events","title":"Related Events","text":"<p>The <code>futex_time32</code> system call is related to other futex system calls like <code>futex_wait</code> and <code>futex_wake</code>. In addition, it is related to futex-related events such as <code>futex_lock_contended</code> and <code>futex_lock_released</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futimesat/","title":"futimesat","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#intro","title":"Intro","text":"<p>futimesat - sets file access and modification times of a given file</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#description","title":"Description","text":"<p>The futimesat() system call is used to set the access and modification times of the file that is referenced by the dirfd argument, or the file at pathname relative to the current working directory, if dirfd is the specially defined value AT_FDCWD. The times argument points to a struct timeval type that contains the new time, in the form of seconds and microseconds, to be set. </p> <p>The futimesat() system call has a few advantages over its counterpart utimes() which is limited to modifying the time of a file pathname provided by its argument, as opposted to a file descriptor. Additionally, this system call can provide better performance than others if the file descriptor is already known. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - file descriptor that points to the directory containing the target file for the futimesat() system call.</li> <li><code>pathname</code>:<code>const char*</code>[K] - string that contains the relative path from the directory specified by dirfd to the target file for the futimesat() system call.</li> <li><code>times</code>:<code>struct timeval*</code>[K] - pointer to the struct timeval type that stores two time specifiers, each consisting of seconds and microseconds, to be set as the new access and modification times of the target file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futimesat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futimesat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#sys_futimesat","title":"sys_futimesat","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#purpose","title":"Purpose","text":"<p>Hooked to capture detailed information about the system call argumetns used, like the file descriptor and relative path.</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#example-use-case","title":"Example Use Case","text":"<p>An example use case of futimesat() could include an application that keeps track of activity associated with a certain file, such as when it was last modified. This system call can be used to update the time of the file so that the application can have accurate data. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#issues","title":"Issues","text":"<p>The futimesat() system call is not available in some older versions of Linux, or in their respective glibc libraries, and has been replaced by the <code>utimensat</code> system call. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#related-events","title":"Related Events","text":"<ul> <li>utimes() - similar system call for setting access and modification times for only pathname specified by user.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/","title":"get_kernel_syms","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#intro","title":"Intro","text":"<p>get_kernel_syms - export the symbol table of the kernel for use by other programs.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#description","title":"Description","text":"<p>The get_kernel_syms system call declares, to a calling user program, the current set of symbols exported by the running Linux kernel. This system call is not often used, as most of its work has been supplanted by /proc/kallsyms, /boot/System.map and other interfaces that enable applications to easily reach the symbols they need.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#arguments","title":"Arguments","text":"<ul> <li><code>symtab</code>:<code>struct kernel_symbol *</code>[K] - a pointer to a structure containing an array of symbol information.</li> <li><code>strtab</code>:<code>char *</code>[K] - a pointer to a string table corresponding to the symbols in the array.</li> <li><code>_syscalls</code>:<code>struct sysent *</code>[K] - a pointer to a table of system call descriptions.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#sys_get_kernel_syms","title":"sys_get_kernel_syms","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#purpose","title":"Purpose","text":"<p>To introduce a hook for the purpose of tracing the get_kernel_syms system call.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#example-use-case","title":"Example Use Case","text":"<p>The get_kernel_syms syscall can be used by an application to obtain symbol information from the kernel. The returned symbols can be used to better understand the behavior of the kernel, or for further debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#issues","title":"Issues","text":"<p>This system call may be subject to TOCTOU (Time Of Check, Time Of Use) attacks, as the symbol table and string table return by the system call may change during the use of the call.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#related-events","title":"Related Events","text":"<ul> <li>kprobed/sys_get_kernel_syms - this event is used to trace the get_kernel_syms system call.</li> <li>sys_set_kernel_syms - this system call is used to modify the symbol table and string table of the kernel.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/","title":"get_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#intro","title":"Intro","text":"<p>get_mempolicy - retrieve the current process memory placement policy</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#description","title":"Description","text":"<p>The get_mempolicy system call retrieves the current process memory placement policy. It can be used to find out if the process is in a specific NUMA (non-uniform memory access) node and to retrieve the preferred node or list of allowed nodes to allocate memory. The function reads the effective process memory placement policy and not necessarily the configurable policy. It can be used to set up a process-wide policy via a call to mbind.</p> <p>The <code>mode</code> argument can be either MPOL_F_NODE (retrieve a list of nodes) or MPOL_F_ADDR (retrieve a single node). If <code>mode</code> is set to MPOL_F_NODE and <code>maxnode</code> is greater than zero, the first <code>maxnode</code> numbers of the node set of <code>nodemask</code> will be copied to the policy. Note that no optional MPOL_F_MEMS_ALLOWED flag is supported by this call.</p> <p>The <code>addr</code> argument can be used when <code>mode</code> is set to MPOL_F_ADDR, which will report the local node on which the memory address resides.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#arguments","title":"Arguments","text":"<ul> <li><code>mode</code>: <code>int*</code>[K] - set to MPOL_F_NODE to copy a set of nodes and MPOL_F_ADDR to get a specific node for the address.</li> <li><code>nodemask</code>: <code>unsigned long*</code>[KU] - pointer to a node bitmask, from which a node set is returned.</li> <li><code>maxnode</code>: <code>unsigned long</code>[K] - maximum number of nodes to return. Must be non-zero if <code>mode</code> is set to MPOL_F_NODE.</li> <li><code>addr</code>: <code>void*</code>[KU] - pointer to an address in virtual memory. Must be set if and only if <code>mode</code> is set to MPOL_F_ADDR.</li> <li><code>flags</code>: <code>unsigned long</code>[K] - flags to control the system call behavior.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#sys_get_mempolicy","title":"sys_get_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#purpose","title":"Purpose","text":"<p>To collect information about changes in the current process memory placement policy.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#example-use-case","title":"Example Use Case","text":"<p>If a process is spawned from a parent process, it can be useful to check the memory placement policy of the given process. The get_mempolicy syscall can be used to check if a process is in a specific NUMA node, and to retrieve the preferred node or list of allowed nodes to allocate memory.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#issues","title":"Issues","text":"<p>No MPOL_F_MEMS_ALLOWED flag is supported by this call.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#related-events","title":"Related Events","text":"<ul> <li>mbind - set the memory policy for a region of memory</li> <li>set_mempolicy - change the current process memory placement policy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/","title":"get_robust_list","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#intro","title":"Intro","text":"<p>get_robust_list - get the list of robust futexes owned by the current task</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#description","title":"Description","text":"<p>The get_robust_list() system call gets the robust futex list owned by the task pointed to by its first argument. In addition, it stores a length of the list into the memory pointed to by the second argument.</p> <p>The robust futex list is a collection of robust futexes which have the FUTEX_WAITERS flag set. Such futexes are owned by the task, and can be used in conjunction with the FUTEX_WAIT and FUTEX_WAKE system calls to provide synchronization between threads.</p> <p>Robust futexes also ensure that all threads waiting for a given futex receive all the wake-up calls belonging to the futex, even if the owner of the futex dies (e.g. due to a kernel panic).</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[U] - define the task structure for the process for which the robust list is to be retrieved.</li> <li><code>head_ptr</code>:<code>struct robust_list_head**</code>[U] - location of the head of the returned list.</li> <li><code>len_ptr</code>:<code>size_t*</code>[U] - location of a size_t containing the length of the returned list, in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#sys_get_robust_list","title":"SyS_get_robust_list","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#type","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#purpose","title":"Purpose","text":"<p>To monitor the usage of the get_robust_list system call.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#example-use-case","title":"Example Use Case","text":"<p>The get_robust_list system call can be used to synchronizing events between threads in a multithreaded application.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#issues","title":"Issues","text":"<p>This system call is not available on all Linux system and is not available on some architectures.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#related-events","title":"Related Events","text":"<p>FUTEX_WAIT, FUTEX_WAKE, robust_list_del, set_robust_list</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/","title":"get_thread_area","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#intro","title":"Intro","text":"<p>get_thread_area - Retrieves the thread-local storage (TLS) area for the current process</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#description","title":"Description","text":"<p>The get_thread_area() system call retrieves the thread-local storage (TLS) area for the current process. It is used during the initialization of a thread to find the address of the thread's TLS segment. The TLS area consists of one or more segments, each of which contains zero or more thread-specific copies of TLS variables, with each variable in turn having a specific data type. This system call is only available in the x86 architecture.</p> <p>This call is typically used with the user_desc structure, which is used by the set_thread_area() system call to set a thread's TLS.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#arguments","title":"Arguments","text":"<ul> <li><code>u_info</code>:<code>struct user_desc*</code>[U] - Pointer to a user_desc structure that will contain the thread's TLS information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#sys_get_thread_area","title":"sys_get_thread_area","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#purpose","title":"Purpose","text":"<p>Hooked to check when and how this syscall is used.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#example-use-case","title":"Example Use Case","text":"<p>The get_thread_area() system call is used to retrieve the thread-local storage (TLS) area for the current process. This can be used in conjunction with the set_thread_area() system call to configure the thread's TLS.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#related-events","title":"Related Events","text":"<ul> <li>set_thread_area() - Used to set the TLS area for the current thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/","title":"getcpu","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#intro","title":"Intro","text":"<p>getcpu - Find the current processors system call.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#description","title":"Description","text":"<p>The getcpu() system call returns both the CPU and NUMA node on which the calling thread is currently executing as well as an abstract \u2018cache\u2019 (whose contents are only of use and meaning to the kernel) into two user-space arguments. This allows applications to, for instance, optimize data locality; i.e. determine if the data the thread is presently operating on is allocated in a way that the thread can maximize cache hits given its current CPU and node.</p> <p>There are no edge-cases, drawbacks or advantages of using getcpu() as compared to other system calls as its purpose is simply to report the current processor and NUMA node for the calling thread of execution and nothing else.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#arguments","title":"Arguments","text":"<ul> <li><code>cpu</code>:<code>unsigned int*</code>[KU] - pointer to an integer into which the CPU number will be written. If a null value is passed, no CPU number is returned.</li> <li><code>node</code>:<code>unsigned int*</code>[KU] - pointer to an integer into which the NUMA node number will be written. If a null value is passed, no NUMA node number is returned.</li> <li><code>tcache</code>:<code>struct getcpu_cache*</code>[KU] - pointer to a getcpu cache structure. If a null value is passed, no getcpu cache structure is returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcpu/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcpu/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#sys_getcpu","title":"sys_getcpu()","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#purpose","title":"Purpose","text":"<p>To track the usage of the getcpu() syscall and log any data that might be relevant to the developers.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#example-use-case","title":"Example Use Case","text":"<p>The getcpu() system call can be used in applications to optimize data locality, i.e. determine if the data the thread is presently operating on is allocated in a way that the thread can maximize cache hits given its current CPU and node. This can be especially useful for applications that are running on large systems with multiple processors and NUMA nodes.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#related-events","title":"Related Events","text":"<ul> <li>sched_migrate_task() - Used to migrate a task between different CPUs or NUMA nodes. </li> <li>sched_setaffinity() - Used to set an affinity mask for a process or thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/","title":"getcwd","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#intro","title":"Intro","text":"<p>getcwd - returns the working directory path of the current process</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#description","title":"Description","text":"<p>The getcwd() function uses the buf parameter to store the path of the current working directory of the process. The buf argument should point to a user allocated buffer of sufficient size (specified by the size argument) that can hold the absolute pathname of the working directory. If the size argument is greater than zero, the path string will be null-terminated. If size is 0, then buf must be a null pointer. If size is greater than zero and buf is NULL, error occurs.</p> <p>getcwd() returns a pointer to the user allocated buffer which stores the pathname of the working directory upon success. If there are issues relating to the size parameter being insufficient (too small) then the error \"ERANGE\" is returned.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>char*</code>[U] - <code>buf</code> should point to a user allocated buffer of sufficient size to hold the absolute pathname of the working directory.</li> <li><code>size</code>:<code>size_t</code>[U] - specifies the size of the user allocated buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcwd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcwd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#do_getcwd","title":"do_getcwd","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#purpose","title":"Purpose","text":"<p>To track the getcwd syscall.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#example-use-case","title":"Example Use Case","text":"<p>An example use case for getcwd is to use it to obtain the working directory of a process so it can be compared with a parent directory to validate that the process is in the correct directory.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#issues","title":"Issues","text":"<p>The errors returned by getcwd() are non-standard, so they may not be comparable across different systems.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#related-events","title":"Related Events","text":"<p>The readlink() and realpath() syscalls may be used in conjunction with getcwd() to normalize given paths.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getdents/","title":"<code>getdents</code>","text":""},{"location":"docs/events/builtin/syscalls/getdents/#intro","title":"Intro","text":"<p><code>getdents</code> - Reads directory entries from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/getdents/#description","title":"Description","text":"<p><code>getdents()</code> system call is used to read directory entries from an open file descriptor into a buffer. The entries are returned one after the other, and the entries contain information, such as the inode number, offset and type, of the entry. It is used by programs to read and parse directories in the filesystem. </p> <p>One of the advantages of using <code>getdents()</code> is that it is an efficient way to read directory entries without requiring the overhead of <code>opendir()</code> and <code>readdir()</code> system calls required for looking up a particular directory entry. On the other hand, one of the drawbacks is that <code>getdents()</code> does not guarantee that the file descriptor provided is a directory.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - File descriptor from which to read the entries.</li> <li><code>dirp</code>: <code>struct linux_dirent*</code> - Pointer to buffer of size <code>count</code> for the results.</li> <li><code>count</code>: <code>unsigned int</code> - Number of bytes of data that can be stored in <code>dirp</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getdents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getdents/#sys_getdents","title":"<code>sys_getdents</code>","text":""},{"location":"docs/events/builtin/syscalls/getdents/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getdents/#purpose","title":"Purpose","text":"<p>To trace directory entries read from a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to trace files and directories read by a process. This can be used to aid debugging as you can easily trace a program\u2019s file access operations to find out if it is reading unexpected files or directories.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#issues","title":"Issues","text":"<p>The <code>count</code> argument must be large enough to accommodate the data returned. Due to a kernel limitation, the maximum size of one <code>struct linux_dirent</code> is <code>2044</code> bytes. If the <code>count</code> argument is smaller than that, the syscall can read more data than the <code>count</code> argument allows, potentially leading to a buffer overflow.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#related-events","title":"Related Events","text":"<ul> <li><code>open()</code> - Reads directory entries from a file descriptor. </li> <li><code>readdir()</code> - Reads directory entries.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/","title":"getdents64","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#intro","title":"Intro","text":"<p>getdents64 - get directory entries from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#description","title":"Description","text":"<p>The getdents64() system call is used to read the contents of an open directory  into a buffer. It gives the caller access to an array of the directory entries  each containing information about a single file or subdirectory. This system  call is often used in conjunction with opendir() to allow an application to  walk a directory tree structure. </p> <p>One drawback of getdents64 is that data it returns is big-endian, while  some architectures are little-endian. This can be circumvented by using the  non-standard readdir64() function, which returns data in little-endian format. </p>"},{"location":"docs/events/builtin/syscalls/getdents64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - file descriptor of an open directory.</li> <li><code>dirp</code>:<code>struct linux_dirent64*</code>[KU] - pointer to  a buffer where the results are written.</li> <li><code>count</code>:<code>unsigned int</code>[K] - size of the buffer pointed by dirp.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#sys_getdents64","title":"SYS_getdents64","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#purpose","title":"Purpose","text":"<p>Produce extra information about the file and directory entries read from the directory.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#example-use-case","title":"Example Use Case","text":"<p>The getdents64 system call can be used, for example, to list the files and  sub-directories inside a given directory, in order to search for a specific  file.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#issues","title":"Issues","text":"<p>Due to the way getdents64 is implemented, it can not be used as a generic  directory iteration mechanism, since it is affected by the directory structure, which can vary across filesystems.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#related-events","title":"Related Events","text":"<p>The related events to getdents64 are open(), close(), readdir64(),  write_dirent64() and unlink().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getegid/","title":"getegid","text":""},{"location":"docs/events/builtin/syscalls/getegid/#intro","title":"Intro","text":"<p>getegid - get process effective group ID</p>"},{"location":"docs/events/builtin/syscalls/getegid/#description","title":"Description","text":"<p>The getegid() system call returns the effective group ID of the calling process. This is the group ID that the kernel uses when checking group permissions for the calling process. </p>"},{"location":"docs/events/builtin/syscalls/getegid/#arguments","title":"Arguments","text":"<p>This syscall does not accept any arguments.</p>"},{"location":"docs/events/builtin/syscalls/getegid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getegid/#getegid_1","title":"getegid","text":""},{"location":"docs/events/builtin/syscalls/getegid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getegid/#purpose","title":"Purpose","text":"<p>This function is hooked to collect data on process effective group ID </p>"},{"location":"docs/events/builtin/syscalls/getegid/#example-use-case","title":"Example Use Case","text":"<p>getegid() is useful in multi-user systems to ensure that every user has the correct set of resource access permissions.</p>"},{"location":"docs/events/builtin/syscalls/getegid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/getegid/#related-events","title":"Related Events","text":"<ul> <li>geteuid() - get process effective user ID</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/","title":"getegid16","text":""},{"location":"docs/events/builtin/syscalls/getegid16/#intro","title":"Intro","text":"<p>getegid16 - get real group ID for the calling process</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#description","title":"Description","text":"<p>getegid16 returns the real group ID of the calling process, as seen by the kernel. This call is functionally identical to getegid except that it takes a 16-bit argument, and returns 16-bit. </p> <p>The underlying system call returnes a 32-bit value, which is truncated and returned as a 16-bit integer. This call is mainly present on older systems, but new programs should rather use the getegid call if possible.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#arguments","title":"Arguments","text":"<p>This syscall does not take any arguments.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#hooks","title":"Hooks","text":"<p>The <code>sys_getegid16</code> function can be hooked.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#sys_getegid16","title":"sys_getegid16","text":""},{"location":"docs/events/builtin/syscalls/getegid16/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#purpose","title":"Purpose","text":"<p>Kprobes provide the highest level of kernel instrumentation and can measure time at any byte-code level in any part of the kernel. By hooking into this function, it is possible to measure the kernel execution time for system calls.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#example-use-case","title":"Example Use Case","text":"<p>For example, this call can be used for measuring the latency of the system call in an embedded system or a system under high load.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#related-events","title":"Related Events","text":"<ul> <li><code>getegid</code> - returns the real group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/","title":"geteuid","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#intro","title":"Intro","text":"<p>geteuid - Retrieve the effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#description","title":"Description","text":"<p>geteuid is a syscall used to retrieve the effective user ID of the current process. This value is used by the kernel when determining which operations are allowed to be executed by the current process. It can be used to enforce access control policies.</p> <p>The geteuid syscall does not take any parameters, which makes it simpler to use than other syscalls. However, it is important to note that the effective user ID may be different from the real user ID, as the kernel may allow certain processes to temporarily execute in a different user context.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#arguments","title":"Arguments","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#available-tags","title":"Available Tags","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#geteuid_1","title":"geteuid","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#purpose","title":"Purpose","text":"<p>To monitor the effective user ID of the current process</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#example-use-case","title":"Example Use Case","text":"<p>Using geteuid can be useful in a system that enforces access control policies, by ensuring that privileged operations are only allowed to be performed by processes with an effective user ID matching the expected one.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#related-events","title":"Related Events","text":"<p>getuid - Retrieve the real user ID.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/","title":"geteuid16","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#intro","title":"Intro","text":"<p>geteuid16 - Get the user ID of the current user.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#description","title":"Description","text":"<p>geteuid16 is a system call in Linux which returns the user id of the user associated with the current process. It does not take any arguments, and simply returns the requested user ID type. It is notable for being a compatibility call for older binaries which were intended to be used with different architectures.</p> <p>The advantages of using geteuid16 are that it is very simple to use, does not take any arguments and does not depend on any context; the user ID is simply returned as trivially as possible.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#arguments","title":"Arguments","text":"<ul> <li>This syscall does not take any arguments. </li> </ul>"},{"location":"docs/events/builtin/syscalls/geteuid16/#available-tags","title":"Available Tags","text":"<p>This syscall does not have any tags.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#sys_geteuid16","title":"sys_geteuid16","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#purpose","title":"Purpose","text":"<p>To detect when the geteuid16 system call has been called.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#example-use-case","title":"Example Use Case","text":"<p>A security policy may include the requirement that only privileged users should be able to call geteuid16. This syscall can be used in conjunction with other monitoring systems to detect any unauthorized access attempts.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#issues","title":"Issues","text":"<p>As geteuid16 is a compatibility syscall, there is a slight chance of it being obsolete and/or unavailable if its intended architecture is no longer supported.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#related-events","title":"Related Events","text":"<ul> <li>getuid16</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgid/","title":"getgid","text":""},{"location":"docs/events/builtin/syscalls/getgid/#intro","title":"Intro","text":"<p>getgid - Returns the real group ID of the calling process. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#description","title":"Description","text":"<p>The getgid function returns the real group ID of the calling process. This function can be used to get the group ID of a process, which is used to determine the group of the calling process. The group ID is set when the process is created, and can be modified using the setgid system call. The getgid function is a wrapper around the getgid system call. </p> <p>When called, getgid returns the real group ID of the calling process. It is important to note that this function will only return the real group ID, not the effective group ID or saved group ID. The real group ID is tied to the user credentials assigned to the process when it was created. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#arguments","title":"Arguments","text":"<ul> <li><code>void</code>:<code>void</code> - No arguments.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgid/#sys_getgid","title":"sys_getgid","text":""},{"location":"docs/events/builtin/syscalls/getgid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getgid/#purpose","title":"Purpose","text":"<p>Hooks the getgid system call to capture its output.</p>"},{"location":"docs/events/builtin/syscalls/getgid/#example-use-case","title":"Example Use Case","text":"<p>The getgid function could be used to capture a process' group ID. This can be useful in situations where the group ID needs to be checked to ensure that a process is running with the correct group credentials. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#issues","title":"Issues","text":"<p>The output from the getgid function only reflects the real group ID of the process. If the effective or saved group ID of the process is desired, other system calls such as getegid, or getresgid need to be used.</p>"},{"location":"docs/events/builtin/syscalls/getgid/#related-events","title":"Related Events","text":"<ul> <li>setgid - Sets the real, effective and saved group IDs of the calling process. </li> <li>getegid - Gets the effective group ID of the calling process. </li> <li>getresgid - Gets the real, effective and saved group IDs of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/","title":"getgid16","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#intro","title":"Intro","text":"<p>getgid16 - Get the real group ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#description","title":"Description","text":"<p>This system call gets the real group ID of the calling process.  This is a wrapper for the 64-bit system call, which is expected to be faster than the 32-bit system call. There are no edge cases, drawbacks or advantages when using this system call.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#arguments","title":"Arguments","text":"<ul> <li><code>None</code>: void - No arguments used</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid16/#available-tags","title":"Available Tags","text":"<ul> <li>None - This call does not have any available tags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#sys_getgid16","title":"sys_getgid16","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#purpose","title":"Purpose","text":"<p>Hooking this function is used for debugging and inspecting the state of the system call in order to gain insight into how the real group ID of the calling process is determined.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#example-use-case","title":"Example Use Case","text":"<p>This system call is used to get the group ID of the user that executed a specific process. This is useful for getting access control information or writing scripts based on process identities.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#issues","title":"Issues","text":"<p>There are no known issues with this system call. </p>"},{"location":"docs/events/builtin/syscalls/getgid16/#related-events","title":"Related Events","text":"<ul> <li>getuid16 - Get the real user ID of the calling process</li> <li>setgid16 - Set the real group ID of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/","title":"getgroups","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#intro","title":"Intro","text":"<p>getgroups - get group access list for user</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#description","title":"Description","text":"<p>The getgroups() system call gets the group access list for the current user, and places it in the array pointed to by list. It returns the size of the group access list in size.</p> <p>Access list is that set of supplementary group IDs associated with the calling process, initialised from the /etc/passwd file when each user first logs in. </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code>[K] - the size of the array in list</li> <li><code>list</code>:<code>gid_t*</code>[KU] - pointer to an array of gid_t which will be filled with the group access list</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#sys_getgroups","title":"sys_getgroups","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#purpose","title":"Purpose","text":"<p>To get group access list for user.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#example-use-case","title":"Example Use Case","text":"<p>getgroups() is often used before setgroups() to obtain the list of current group IDs associated with the calling process, so it can be used for auditing and logging changes to the group access list. </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#related-events","title":"Related Events","text":"<p>setgroups() - set group access list for user</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/","title":"getgroups16","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#intro","title":"Intro","text":"<p>getgroups16 - returns the supplementary group IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#description","title":"Description","text":"<p>getgroups16 is a syscall used to retrieve a list of supplementary group IDs of the calling process. This list is stored as an array of group IDs, with a size given by the first parameter. This array is written to the second parameter. The syscall is equivalent to calling getgroups() with a maximum of 16 entries in the array. </p> <p>If the flag <code>parse-arguments</code> is given, the list is parsed and written to a buffer containing a null-terminated array of strings, delimited by index numbers. This allows for a more user-friendly representation of the output. This can be a useful utility when kprobing related to supplementary groups.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code>[K] - number of entries in the supplementary group array. If <code>parse-arguments</code> is given, this is the maximum length of the output buffer.</li> <li><code>list</code>:<code>old_gid_t*</code>[K] - pointer to the array in which the list of group IDs is stored. If <code>parse-arguments</code> is given, this is a pointer to the output buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#getgroups16_1","title":"getgroups16","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#purpose","title":"Purpose","text":"<p>Hooking getgroups16 allows for recording when the process attempts to fetch its supplementary group IDs. By observing when and where this happens, performance and security issues can be detected, such as authentication problems, or attempts to access data that the user should not have access to, violating the principle of least privilege.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#example-use-case","title":"Example Use Case","text":"<p>getgroups16 can be used to watch for processes that fetch their supplementary group IDs and make sure that those calls happen when expected, such as during authentication. It can help identify processes that are misusing the supplementary groups for which it is not intended and give detailed information about where and when this happens, should that be occurring.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#issues","title":"Issues","text":"<p>The flag <code>parse-arguments</code> has not been tested thoroughly, so any issues while using it should be reported in order to ensure that the user gets the expected output.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#related-events","title":"Related Events","text":"<p>getgroups() - similar to getgroups16, but with a higher (32) limit for supplementary group IDs.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getitimer/","title":"getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#getitimer","title":"getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#intro","title":"Intro","text":"<p>getitimer - retrieves the current value of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#description","title":"Description","text":"<p>The getitimer function is used to retrieve the current value of an interval timer. The interval timer must have been set previously with the setitimer function.</p> <p>If the value curr_value is non-NULL, the getitimer function fills out the structure pointed to by curr_value with the current value of the timer.</p> <p>The which argument must be one of the flags, ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF.</p> <p>The main advantage of using the getitimer syscall is to retrieve the current value of an interval timer previously set with the setitimer syscall. A potential drawback is that the curr_value argument must be initialized before calling this syscall, and must point to valid memory. </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - the timer to retrieve, must be one of ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF. </li> <li><code>curr_value</code>:<code>struct itimerval*</code>[KU] - pointer to the structure that will contain the retrieved current value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getitimer/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getitimer/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#sys_getitimer","title":"sys_getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#purpose","title":"Purpose","text":"<p>To track the usage and parameters of the getitimer syscall.</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#example-use-case","title":"Example Use Case","text":"<p>The getitimer syscall can be used by an application to retrieve the current value of an interval timer previously set with the setitimer syscall. This allows an application to accurately keep track of how much time has elapsed until the next interrupts.   </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#issues","title":"Issues","text":"<p>None. </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#related-events","title":"Related Events","text":"<p>setitimer</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/","title":"getpeername","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#intro","title":"Intro","text":"<p>getpeername - Retrieve the name of the peer connected to the socket.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#description","title":"Description","text":"<p>getpeername is a system call that allows for the retrieval of the name of the peer socket connected to the given socket. Additionally, the system call can return more information about the peer, such as its address family, port, and more. By default, the system call does not check for the validity of the socket descriptor, so it is possible that an error is returned even when the arguments are valid. </p>"},{"location":"docs/events/builtin/syscalls/getpeername/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor referring to the socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[U] - A pointer to a buffer where the address of the remote socket is stored.</li> <li><code>addrlen</code>:<code>int*</code>[U] - A pointer to an integer indicating the size of the <code>addr buffer</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpeername/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpeername/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#sys_socketcall","title":"sys_socketcall","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#purpose","title":"Purpose","text":"<p>To trace all calls to the socketcall syscall.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#example-use-case","title":"Example Use Case","text":"<p>getpeername can be used to determine the address of the peer in a peer to peer networking setup. It can also be used to differentiate between different connection types, such as UDP or TCP.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#issues","title":"Issues","text":"<p>getpeername can cause a race condition in a multi-threaded application if the underlying socket is modified while the system call is in progress. </p>"},{"location":"docs/events/builtin/syscalls/getpeername/#related-events","title":"Related Events","text":"<ul> <li>accept</li> <li>connect</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/","title":"getpgid","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#intro","title":"Intro","text":"<p>getpgid - Get the process group ID of a process</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#description","title":"Description","text":"<p>The getpgid() system call retrieves the process group ID of the process that corresponds to the given PID. It is used to check if the process still exists, as well as its process group ID. It can be used with any PID - even a parent or its own process ID - but there are some restrictions, such as the process having to be in the same session and the process must have the same UID or effective UID as the process doing the syscall. Additionally, a process group can consist of multiple processes and one process can be part of multiple groups.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[N] - The process ID of the process for which the process group ID should be queried.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#sys_getpgid","title":"sys_getpgid()","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#purpose","title":"Purpose","text":"<p>To track the process group ID of a process.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#example-use-case","title":"Example Use Case","text":"<p>An example use case for getpgid() might be a process tracking application. This application wants to track the process group IDs of all processes running. To do this, it would hook the sys_getpgid() function using a kprobe and store the retuned process group ID in its own database.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#issues","title":"Issues","text":"<p>No major issues were found with this syscall. </p>"},{"location":"docs/events/builtin/syscalls/getpgid/#related-events","title":"Related Events","text":"<ul> <li>setpgid() - Set the process group ID of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/","title":"getpgrp","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#intro","title":"Intro","text":"<p>getpgrp - get the process group ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#description","title":"Description","text":"<p>The getpgrp() function returns the process group ID of the calling process. Process groups are the mechanism used by drivers implementing job control.</p> <p>getpgrp() is the equivalent of getpgid(0), getpgid() can be used to get the process group ID for another process; see getpgid(2). </p> <p>The main advantage of using getpgrp() is that it saves an expensive system call (in the case of getpgid(2)). On the other hand, getpgrp() can be only used with the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#arguments","title":"Arguments","text":"<p>No arguments for this system call.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#sys_getpgrp","title":"sys_getpgrp","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#purpose","title":"Purpose","text":"<p>To log a trace when the getpgrp() system call is called.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used by a service or daemon that needs to change the process group ID in order to run a command or to determine the process group ID to check if it is a child process.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#issues","title":"Issues","text":"<p>This system call does not have any known issues.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#related-events","title":"Related Events","text":"<p>getpgid(2) - get a process group ID of another process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpid/","title":"getpid","text":""},{"location":"docs/events/builtin/syscalls/getpid/#intro","title":"Intro","text":"<p>getpid - get process identification</p>"},{"location":"docs/events/builtin/syscalls/getpid/#description","title":"Description","text":"<p>getpid() calls the kernel API which returns the identification (ID) of the calling process. The ID returned is the Process ID (PID) which is a unique value that identifies each process within the system. </p> <p>This API is often used when a process needs to obtain its own pid for use within other API calls, such as getppid(), for example. While getting the PID for a process is relatively easy, some difficulties arise when the call needs to work across processes. This is where some synchronization is needed between processes to ensure that the correct PID value is returned.</p> <p>The getpid() API is usually found in the child process section of Linux, as it is one of the very few ways of obtaining the parent's PID from a child process. There are also other uses of getpid(), such as when checking whether or not a particular process is running, or when sending signals or associated information to a process that is running.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#arguments","title":"Arguments","text":"<p>There are no arguments for the getpid() API.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpid/#syscalltable","title":"SysCallTable","text":""},{"location":"docs/events/builtin/syscalls/getpid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getpid/#purpose","title":"Purpose","text":"<p>To prevent malicious processes from replacing the getpid() system call entry point with a malicious one, this function is hooked to verify that the system call operation is performed correctly.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#example-use-case","title":"Example Use Case","text":"<p>The getpid() system call can be used in any process to obtain the identifier (PID) of that process. It is a commonly used API for getting the parent process's PID from its child process. For example, a child process can use getpid() to obtain its own PID, and then use that to obtain the PID of its parent process using the getppid() API call.</p> <p>This system call can also be used to verify that a process is running, by obtaining its PID from the system and using this to check if it is running. In addition, it can also be used for sending signals and associated data to a running process.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/getpid/#related-events","title":"Related Events","text":"<ul> <li>getppid() - get parent process identification</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/","title":"getpmsg","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#intro","title":"Intro","text":"<p>getpmsg - delivers the next message on a STREAMS pipe</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#description","title":"Description","text":"<p>The getpmsg() system call is used to read message from a STREAMS pipe. A message from the pipe is either read into the buffers that are specified by the <code>ctrlptr</code>, <code>datptr</code>, <code>flags</code> and <code>bandp</code> arguments, or it is skipped depending on the settings of <code>flags</code>.</p> <p>getpmsg() is useful in applications dealing with STREAMS pipes where messages have different priority and should be read in different order than they are available.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor associated with the STREAMS pipe</li> <li><code>ctrlptr</code>:<code>void *</code>[K] - pointer to buffer for control information</li> <li><code>datptr</code>:<code>void *</code>[K] - pointer to buffer for data</li> <li><code>bandp</code>:<code>int *</code>[K] - pointer to a variable for indicating the band of the message</li> <li><code>flags</code>:<code>int</code>[K] - flags indicating how the messages should be delivered</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#getpmsg_1","title":"getpmsg","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#purpose","title":"Purpose","text":"<p>To measure the time taken by the getpmsg syscall.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#example-use-case","title":"Example Use Case","text":"<p>getpmsg() can be used in applications that read messages from STREAMS pipes. For example, a text editor can use getpmsg() to read messages from a STREAMS pipe and display them in the application window.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#issues","title":"Issues","text":"<p>Due to the asynchronous nature of STREAMS pipes, it is possible that getpmsg() will read an invalid message, or a message intended for a different application.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#related-events","title":"Related Events","text":"<ul> <li>getmsg</li> <li>putmsg</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getppid/","title":"getppid","text":""},{"location":"docs/events/builtin/syscalls/getppid/#intro","title":"Intro","text":"<p>getppid - return the process ID of the parent of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getppid/#description","title":"Description","text":"<p>The <code>getppid()</code> system call is used to determine the PID of the parent of the calling process. This is an important information for parent-child process relationships, as the PPID value for the parent of the process can be used to separate process hierarchies. The return value is a positive number, or zero if the parent process does not exist. </p> <p>There are some edge cases and drawbacks to using <code>getppid()</code>. For example, a process can check its parent process ID with <code>getppid()</code> but this value is not guaranteed to stay the same over the course of execution. Furthermore, if the parent process has exited, then getppid will return zero, which is not very helpful. </p>"},{"location":"docs/events/builtin/syscalls/getppid/#arguments","title":"Arguments","text":"<p>No arguments</p>"},{"location":"docs/events/builtin/syscalls/getppid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getppid/#sys_getppid","title":"sys_getppid","text":""},{"location":"docs/events/builtin/syscalls/getppid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getppid/#purpose","title":"Purpose","text":"<p>To trace all calls to <code>getppid()</code> in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#example-use-case","title":"Example Use Case","text":"<p>By generating trace events at each <code>sys_getppid</code> occurrence, one can get all of the process IDs in the parent-child process tree and maintain a timeline of process creation and exits.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#issues","title":"Issues","text":"<p>If the parent of a process exits and is replaced with a different process of the same PID, then <code>getppid</code> would return the same value, leading to potential confusion.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#related-events","title":"Related Events","text":"<ul> <li><code>execve</code> - checks whether the current process is the parent of a given process</li> <li><code>fork</code> - creates a new process that is the parent of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/","title":"getpriority","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#intro","title":"Intro","text":"<p>getpriority - get the priority of a process or process group.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#description","title":"Description","text":"<p>getpriority() gets the priority of a specified process (by the which and who arguments) compared to the priority of all other processes in the same process group. The return value is the priority value, which ranges from -20 (high priority) to 20 (low priority). It can also be used to get the priority of the specified process relative to the other processes in the same user ID.</p> <p>This function is useful for allowing privileged processes to set the priority of other processes. It is important to note that the values returned are dependent on the system's scheduling policy, and may not always return meaningful values for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - The which argument specifies what information to retrieve. The value PRIO_PROCESS retrieves the priority of the specified process. The value PRIO_PGRP retrieves the priority of the processes in the specified process group.</li> <li><code>who</code>:<code>int</code>[K] - The who argument specifies the process ID or process group ID whose priority should be retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpriority/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpriority/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#sys_getpriority","title":"sys_getpriority","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#purpose","title":"Purpose","text":"<p>To trace calls to the getpriority() system call.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#example-use-case","title":"Example Use Case","text":"<p>getpriority() can be used to control the process execution times for tasks with different priorities. For example, when running multiple jobs on a server or setting the priority of processes in a real-time system.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#issues","title":"Issues","text":"<p>This function is dependent on the system scheduling policy, which may not always return meaningful values for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#related-events","title":"Related Events","text":"<ul> <li>setpriority() - set the priority of a process or process group.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/","title":"Getrandom","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#intro","title":"Intro","text":"<p>Getrandom - Retrieves randomness from the kernel entropy pool</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#description","title":"Description","text":"<p>The getrandom() system call returns up to buflen bytes of randomness from the kernel entropy pool into the buffer pointed to by buf. The returned value is internally generated.</p> <p>This function has the advantage of providing a cryptographically secure source of randomness as it is based on an entropy pool of randomness that is maintained in the kernel. It is also faster than other random number generation functions as it does not have to perform any computationally intensive calculations. </p> <p>There are some potential drawbacks to using the getrandom() system call such as potential race conditions, where two or more processes are using the same getrandom() system call and may end up getting the same data in the same buffer. This means that the data returned by getrandom() can potentially be compromised. Additionally, the getrandom() system call will return an error instead of waiting for enough entropy to become available, so if it is called in a situation where there is not enough entropy available it will fail.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>void*</code>[K] - Pointer to the buffer which will hold the random data.</li> <li><code>buflen</code>:<code>size_t</code>[K] - Size of the buffer pointed to by buf, in bytes.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - If flags is set to 0, getrandom() will not return until it has retrieved the requested amount of data. If flags is set to GRND_NONBLOCK, getrandom() will return instantly, with the actual amount of retrieved data stored in the buffer pointed to by buf. If there is not enough entropy available immediately, getrandom will return -1 with errno set to EAGAIN.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrandom/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrandom/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#get_random_bytes","title":"get_random_bytes","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#purpose","title":"Purpose","text":"<p>To monitor the results of the getrandom() system call and log any attempts to retrieve random data from the kernel entropy pool.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#example-use-case","title":"Example Use Case","text":"<p>This is often used for cryptographic operations, or when developers need a secure source of randomness for their application.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#issues","title":"Issues","text":"<p>The getrandom() system call does not guarantee that the randomness returned will be unique as there is a potential for race conditions during execution. Additionally, there may not be enough entropy available when the call is made, so it is important to check that enough entropy is available before the call is made.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#related-events","title":"Related Events","text":"<ul> <li>getentropy() - similar system call - but with different parameters.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/","title":"getresgid","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#intro","title":"Intro","text":"<p>getresgid - gets the real, effective and saved user group IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#description","title":"Description","text":"<p>The getresgid() is used to get the current real, effective and saved user group ids of the calling process. These values are stored in the different parameters passed as pointers to the getresgid() syscall, and can be used for different process management operations, such as setting or rescinding privileges of specific users or groups, as well as for user authentication. The group IDs are stored as gid_t type values, which should be capable of holding the group IDs used in the system. </p> <p>There are some edge-cases that have to be taken into consideration when using getresgid() from within the kernel or from user space. In the kernel, getresgid() might return -1 if there is an error in accessing the user group ids, while from user space this is a valid return value. Furthermore, when using getresgid() from user space, the real, effective and saved user group ids should all be valid, as the kernel will check them against the user IDs in the system.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the real user group id of the calling process is stored.</li> <li><code>egid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the effective user group id of the calling process is stored.</li> <li><code>sgid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the saved user group id of the calling process is stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#ptrace_traceme","title":"ptrace_traceme","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#type","title":"Type","text":"<p>kprobe + ftrace</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#purpose","title":"Purpose","text":"<p>Hooking the ptrace_traceme function with both kprobes and ftrace allows for more precise control over the tracing of processes.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#example-use-case","title":"Example Use Case","text":"<p>Suppose we want to authenticate a user, as well as ensure that all privileges given to his user should only be used within a certain context. We can use the getresgid() syscall to get the real, effective and saved user group ids, and compare them with the ones stored in the system. If they match, the user is authenticated, and if not, the user has to be rejected.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#issues","title":"Issues","text":"<p>getresgid() is vulnerable to TOCTOU issues when used from user space, as the gid_t values could be manipulated between the time the user checks them and the time he uses them.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#related-events","title":"Related Events","text":"<p> setresgid() </p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/","title":"getresgid16","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#intro","title":"Intro","text":"<p>getresgid16 - get the real, effective, and saved group IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#description","title":"Description","text":"<p>The getresgid16() system call gets the real, effective, and saved group IDs of the calling process (in that order).</p> <p>Using this call, a process can be sure that its real, effective and saved group IDs are the same.  This can help with privilege elevation when changing credentials.</p> <p>Since it takes no arguments, there are no edge-cases or drawbacks, however, in kernel versions prior to 4.20 the <code>allocated</code> argument was present and had to be set to the size of the <code>old_gid_t</code> type, which might be confusing for some.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_gid_t*</code>[K] - Pointer to the real group ID of the caller.</li> <li><code>egid</code>:<code>old_gid_t*</code>[K] - Pointer to the effective group ID of the caller.</li> <li><code>sgid</code>:<code>old_gid_t*</code>[K] - Pointer to the saved group ID of the caller.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#do_getresgid16","title":"do_getresgid16","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#purpose","title":"Purpose","text":"<p>To allow users to trace or monitor calls to the getresgid16() system call from user space.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the progress of setting the caller's real, effective, and saved group IDs.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#issues","title":"Issues","text":"<p>In some kernels, the <code>allocated</code> argument had to be set to the size of the <code>old_gid_t</code> type, but this was deprecated in kernel 4.20.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#related-events","title":"Related Events","text":"<ul> <li>setresgid16 - set the real, effective, and saved group IDs of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/","title":"Getresuid","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#intro","title":"Intro","text":"<p>getresuid - Get the real, effective and saved user identity</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#description","title":"Description","text":"<p>The getresuid() system call gets the real, effective and saved user identity of the calling process, storing the results in the buffer pointed to by ruid, euid and suid, respectively.</p> <p>The real user ID is the user ID of the owner of the process. The effective user ID is the user ID used when checking user permissions. The saved user ID is the user ID used when the process calls execve().</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the real user ID will be stored.</li> <li><code>euid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the effective user ID will be stored. </li> <li><code>suid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the saved user ID will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#do_getrusage","title":"do_getrusage","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#purpose","title":"Purpose","text":"<p>To monitor when a process requests its own resource usage.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#sys_getresuid","title":"sys_getresuid","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#purpose_1","title":"Purpose","text":"<p>To retrieve the real, effective and saved user ID of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#example-use-case","title":"Example Use Case","text":"<p>The getresuid() system call can be used to check if a process has the same real and effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#issues","title":"Issues","text":"<p>There are no known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#related-events","title":"Related Events","text":"<ul> <li>getresgid() - Get the real, effective and saved group identity of the calling process.</li> <li>getuid() - Get the real user ID of the calling process.</li> <li>geteuid() - Get the effective user ID of the calling process.</li> <li>getegid() - Get the effective group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/","title":"getresuid16","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#intro","title":"Intro","text":"<p>getresuid16 - get the real user, effective user, and saved-set user IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#description","title":"Description","text":"<p>The <code>getresuid16</code> system call is used to get the current real user ID, effective user ID, and saved-set user ID of the calling process. This is useful for probing the security context of the running process, as the context changes when different user IDs are used. The real user ID is the original user ID of the process and cannot be changed; the effective user ID is what the process uses to determine file permissions, and the saved-set user ID is the user ID used when the effective user ID is reset, such as when the process drops privileges. </p> <p>Since the kernel view of user IDs is 32-bit while the user space view of them is 16-bit, this system call allows for the conversion between the two views. </p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the real user ID of the calling process is written to. The pointer must be 16-bit.</li> <li><code>euid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the effective user ID of the calling process is written to. The pointer must be 16-bit.</li> <li><code>suid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the saved-set user ID of the calling process is written to. The pointer must be 16-bit.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K \u2013 Originated from kernel-space.</li> <li>U \u2013 Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU \u2013 Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT \u2013 Optional argument \u2013 might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#sys_getresuid16","title":"sys_getresuid16","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#type","title":"Type","text":"<p>Kprobe + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#purpose","title":"Purpose","text":"<p>Hooked to get the real, effective and saved-set user IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor privileged processes, such as daemons, to ensure that they are running with the appropriate level of authority.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#issues","title":"Issues","text":"<p>Because this system call is only intended to perform a conversion between kernel and user space views of the user ID, it is vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#related-events","title":"Related Events","text":"<ul> <li><code>getresgid16</code> - get the real group, effective group, and saved-set group IDs of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/","title":"getrlimit","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#intro","title":"Intro","text":"<p>getrlimit - get resource limits on the process</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#description","title":"Description","text":"<p>getrlimit() returns the current value of a resource limit for the process identified by pid. Resource limits are kernel-imposed limits on the resources that a process can consume. The resource parameter is a resource to be retrieved; a list of known resources is given in the manual page. If a call to setrlimit() has not been made previously, then the returned limits will reflect the operating system's default limit values. </p> <p>There are some limitations associated with this syscall. The granularity of the returned data depends on the limits imposed by the underlying operating system. For example, some architectures may not support setting a limit for a resource type. Additionally, the returned resource limit may not exactly match the value that was set, as it is rounded up to the nearest valid limit by the kernel before it is returned. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code> - specifies the resource to retrieve information about.</li> <li><code>rlim</code>:<code>struct rlimit*</code>[K | U] - specifies the location of the buffer that should contain the resource limit. This buffer must be provided by user-space and must have enough space to contain the resource limit that is being requested.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrlimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#sys_getrlimit","title":"sys_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#purpose","title":"Purpose","text":"<p>To monitor the resource limits of the process and gather information about resource consumption.</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#example-use-case","title":"Example Use Case","text":"<p>getrlimit() can be used to track how many resources, like memory and file descriptors, a process is consuming and, potentially, help identify process that are growing in a very short amount of time or have too many resources allocated. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#issues","title":"Issues","text":"<p>The granularity of the resource limits depends on the system and there may not be support for some resource types. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#related-events","title":"Related Events","text":"<p>setrlimit() - set resource limits on the process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/","title":"getrusage","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#intro","title":"Intro","text":"<p>getrusage - get resource usage </p>"},{"location":"docs/events/builtin/syscalls/getrusage/#description","title":"Description","text":"<p>The getrusage() system call returns information about usage of system resources and accounting information of the current process or one of its children. This information can be used to determine from which parts of the program the time was spent or to estimate the current capacity of the process to perform operations.</p> <p>The <code>who</code> argument should be set to <code>RUSAGE_SELF</code> to return information about the current process, or <code>RUSAGE_CHILDREN</code> to return information about the process's children. The <code>usage</code> argument points to a structure, rusage, which upon the system call's return, is filled with the specified usage information.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#arguments","title":"Arguments","text":"<ul> <li><code>who</code>:int[KU] - The who argument describes which process the usage information is requested for. Must be set to <code>RUSAGE_SELF</code> or <code>RUSAGE_CHILDREN</code>.</li> <li><code>usage</code>:struct rusage*[K] - The usage argument is a pointer to a struct rusage, which upon the system call's return, is filled with the specified usage information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrusage/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrusage/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#do_getrusage","title":"do_getrusage","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/getrusage/#purpose","title":"Purpose","text":"<p>To observe the system call arguments and return values of getrusage for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#example-use-case","title":"Example Use Case","text":"<p>getrusage can be used to get resource usage information from a specific process, such as the CPU usage or the size of used memory. This information can be used to create performance profiles for a running program.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#issues","title":"Issues","text":"<p>When using the <code>RUSAGE_CHILDREN</code> flag, the information returned can be inconsistent  when dealing with processes that exit until all exited processes are reaped.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#related-events","title":"Related Events","text":"<ul> <li>getpid - gets the process id of the calling process</li> <li>wait4 - waits on a process or group of processes</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsid/","title":"getsid","text":""},{"location":"docs/events/builtin/syscalls/getsid/#intro","title":"Intro","text":"<p>getsid - get the session ID of a process</p>"},{"location":"docs/events/builtin/syscalls/getsid/#description","title":"Description","text":"<p>getsid() returns the session ID of the process specified in pid. If pid is zero, the  call applies to the calling process.  If pid is not a member of the current  session, getsid() returns -1 and sets errno to ESRCH. The current session ID is  determined by a call to getsid() for the process specified in pid equal to 0.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the PID of the process whose session ID will be returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsid/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getsid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsid/#sys_getsid","title":"sys_getsid","text":""},{"location":"docs/events/builtin/syscalls/getsid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getsid/#purpose","title":"Purpose","text":"<p>Enable more fine-grained tracing in the user and system level by tracing  through the process executed code.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#example-use-case","title":"Example Use Case","text":"<p>Example of a use case for getsid would be implementing a process that  replaces the current session's leader process with a new one, or getting  the PID and session ID of newly created processes to ensure they were not  orphaned.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#issues","title":"Issues","text":"<p>It needs to be monitored carefully when using getsid() on processes that  do not belong to the calling process\u2019s session in order to prevent malicious  actions such as hijacking of processes running in different sessions.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#related-events","title":"Related Events","text":"<p>getpgid, setpgid, setsid</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/","title":"getsockname","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#intro","title":"Intro","text":"<p>getsockname - get the name of the socket and the local address of a socket.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#description","title":"Description","text":"<p>The getsockname() function retrieves the current address to which the socket 'sockfd' is bound, and stores it in the sockaddr structure pointed to by the 'addr' argument. The 'addrlen' argument should be initialized to indicate the amount of space pointed to by 'addr'. On return it contains the actual size of the socket address.</p> <p>The getsockname() function provides the address of an unnamed socket, the address of a named socket that has not yet been bound to an address, or the address of a bound stream-oriented socket.</p> <p>There are not many advantages of using getsockname() over other socket functions, but one of the benefits is that a socket can be used to obtain the local address even before bind() is called.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Socket file descriptor.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[U] - Pointer to a sockaddr type that will be filled with the local address. </li> <li><code>addrlen</code>:<code>int*</code>[U] - Pointer to the size of the sockaddr struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#sys_getsockname","title":"sys_getsockname","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#purpose","title":"Purpose","text":"<p>Trace calls to sys_getsockname to get information about the local address.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor incoming and outgoing connections to a socket.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#issues","title":"Issues","text":"<p>This event may omit some addresses if they are not set yet, or if they are not bound to a socket yet.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#related-events","title":"Related Events","text":"<ul> <li>bind()</li> <li>connect()</li> <li>getpeername()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/","title":"getsockopt","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#intro","title":"Intro","text":"<p>getsockopt - Queries the state of a socket for the options associated with a given level.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#description","title":"Description","text":"<p>The getsockopt() system call allows a program to determine the current value of an option associated with a socket. This call takes the socket descriptor, the level at which the option is defined, and the number of the option to be retrieved. The value of the option is returned in the buffer pointed to by the optval argument.</p> <p>There are a number of possible options, depending on the protocol, level and particular option requested. The optlen argument should be initialized to the size of the buffer associated with the optval argument, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, optval and optlen should be NULL.</p> <p>Advantages of using getsockopt() include having a flexible and standards-compliant way to query a socket for the value of options associated with it. Likewise, drawbacks stem from being protocol- and implementation-dependent.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Specifies a socket created with the socket() system call. </li> <li><code>level</code>:<code>int</code>[K] - Defines the protocol level at which the option resides. The supported levels include: SOL_SOCKET for options at the socket-level; IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, and IPPROTO_UDP for options at the IP, IPv6, TCP, and UDP levels respectively.</li> <li><code>optname</code>:<code>int</code>[K] - Defines the type of option. The available types of options depend on the particular protocol in use.</li> <li><code>optval</code>:<code>void*</code>[K] - Pointer to a buffer which is used to store the option value.</li> <li><code>optlen</code>:<code>int*</code>[K] - Size of the buffer provided in optval. It is modified on return to indicate the actual size of the option value stored in optval.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockopt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#sys_getsockopt","title":"sys_getsockopt","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#purpose","title":"Purpose","text":"<p>Hooked by ftrace to measure execution time and other performance data.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#example-use-case","title":"Example Use Case","text":"<p>The getsockopt() system call is commonly used to retrieve information related to network communication, such as socket options, protocol information, and IP address binding.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#issues","title":"Issues","text":"<p>No known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#related-events","title":"Related Events","text":"<p>Other socket-related system calls that may be related to getsockopt(): * socket() * bind() * connect() * accept()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gettid/","title":"gettid","text":""},{"location":"docs/events/builtin/syscalls/gettid/#intro","title":"Intro","text":"<p>gettid - return the caller's thread ID (TID)</p>"},{"location":"docs/events/builtin/syscalls/gettid/#description","title":"Description","text":"<p>gettid() returns the caller's thread ID.  On success, the thread ID of the calling thread is returned.  On  error,  (pid_t)-1 is returned, and errno is set to indicate the cause of the error.</p> <p>A thread ID is only guaranteed to be unique within a process.  There are no two threads in the same process whose thread IDs are the same.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#arguments","title":"Arguments","text":"<ul> <li><code>None</code>:<code>N/A</code>[K] - gettid does not require any arguments</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettid/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gettid/#gettid_1","title":"gettid","text":""},{"location":"docs/events/builtin/syscalls/gettid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/gettid/#purpose","title":"Purpose","text":"<p>To get information about the thread ID of the calling thread.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#example-use-case","title":"Example Use Case","text":"<p>This event can be used in a multi-threaded program to get information about the threads running in the program.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/gettid/#related-events","title":"Related Events","text":"<p>getpid - return the caller's process ID</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/","title":"gettimeofday","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#intro","title":"Intro","text":"<p>gettimeofday - get the current time</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#description","title":"Description","text":"<p>gettimeofday is a system call used to retrieve the current system time in seconds and microseconds. It allows an application to read the date and time stamp of the system and also to be notified of significant timers occurrences. The system time is used for managing resources such as network services or for evidence of user activities.</p> <p>The call supports two argument parameters, <code>tv</code> and <code>tz</code>, either of which may be <code>null</code>. The <code>tv</code> parameter provides the seconds and microseconds since the epoch, and the <code>tz</code> parameter is used to provide an additional time-zone information, which is required by some standards or rules.</p> <p>Edge cases of using this system call include potential race conditions in programs using this call, since the exact time of execution cannot be guaranteed when multiple processes are running.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#arguments","title":"Arguments","text":"<ul> <li><code>tv</code>:<code>struct timeval*</code>[U] - Pointer to a <code>struct timeval</code>, which will be filled with the time.</li> <li><code>tz</code>:<code>struct timezone*</code>[U] - Pointer to a <code>struct timezone</code>, which will be filled with the time zone information, or <code>null</code> if there is no need for this information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from the kernel-space.</li> <li>U - Originated from user-space (for example, a pointer to user-space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#sys_gettimeofday","title":"sys_gettimeofday","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#purpose","title":"Purpose","text":"<p>To trace the invocation of this function so that its timestamp, tz argument value and argument length information can be retrieved. </p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#example-use-case","title":"Example Use Case","text":"<p>An example use case for gettimeofday would be a social media platform using the system time to limit the frequency of notifications to users. By using gettimeofday, the platform can keep track of when a notification was sent in order to ensure that the user does not receive multiple notifications in a set amount of time.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#issues","title":"Issues","text":"<p>When using gettimeofday, it is important to note that although this syscall provides accurate and reliable results, it still may suffer from clock jitter due to the multicore systems and timer interruptions, causing the resulting time value to be inconsistent.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#related-events","title":"Related Events","text":"<ul> <li>settimeofday - sets the system date and time</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getuid/","title":"getuid","text":""},{"location":"docs/events/builtin/syscalls/getuid/#intro","title":"Intro","text":"<p>getuid - Retrieve user identity</p>"},{"location":"docs/events/builtin/syscalls/getuid/#description","title":"Description","text":"<p>This event retrieves the user identity of the calling process. This is usually the real user ID of the calling process, but may be changed to the effective user ID or saved user ID depending on the implementation of the calling process.</p> <p>The getuid event is useful for authentication of process and user identities in systems which require privilege separation. However, there are some potential drawbacks: it may not be possible to differentiate processes across userid boundaries, or between related userids in certain implementations.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"docs/events/builtin/syscalls/getuid/#available-tags","title":"Available Tags","text":"<p>none</p>"},{"location":"docs/events/builtin/syscalls/getuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getuid/#getuid_1","title":"getuid","text":""},{"location":"docs/events/builtin/syscalls/getuid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getuid/#purpose","title":"Purpose","text":"<p>For auditing, logging or tracing purposes, the getuid event can be used to monitor and log the user identity of a process.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#example-use-case","title":"Example Use Case","text":"<p>The getuid event can be used to trace users who are using a program or an application in order to track the usage of the program.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#issues","title":"Issues","text":"<p>The getuid event may not be able to differentiate between processes running with different userids in certain implementations.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#related-events","title":"Related Events","text":"<ul> <li>geteuid - Retrieve effective user identity</li> <li>getresuid - Get real, effective and saved user identity</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/","title":"getuid16","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#intro","title":"Intro","text":"<p>getuid16 - get the real user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#description","title":"Description","text":"<p>The getuid16() system call returns the real user ID of the calling process. It may be used to check if the user has the appropriate privileges to perform certain operations. getuid16() and geteuid16() pair together in order to determine the effective and real user ID that the process is running under. There are no edge cases or drawbacks to using this system call, however, it is important to note that a process can only view the real user ID of itself, as opposed to other processes.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#arguments","title":"Arguments","text":"<ul> <li><code>void</code>: <code>void</code> - This system call takes no arguments.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#sys_getuid16","title":"sys_getuid16","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#purpose","title":"Purpose","text":"<p>To examine the processes that are making this system call.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to check for certain privileges or access rights of the user in order to allow certain operations to be executed. For example, a web application could use this system call to check for the user ID of the currently logged in user and then determine if that user has permission to delete or modify certain content.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#issues","title":"Issues","text":"<p>There are no known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#related-events","title":"Related Events","text":"<ul> <li>geteuid16 - get the effective user ID of the calling process</li> <li>setuid16 - set the real user ID and effective user ID of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/","title":"getxattr","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#intro","title":"Intro","text":"<p>getxattr - retrieves the value of the extended attribute identified by name and associated with the given path in the file system.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#description","title":"Description","text":"<p>The getxattr() system call gets the value of an extended attribute identified by name and associated with the given path in the file system. It is intended to be a companion to the setxattr(2) system call, which sets extended attributes. </p> <p>There are a number of advantages and edge-cases to using getxattr(). One major advantage is that extended attributes can store data not defined by standard file attributes, such as security labels and access control lists, and more. Furthermore, the value and size of an extended attribute may change from one call to the next, with certain flags and options. This makes getxattr() a useful tool for implementing certain security schemes that require precise control over data.</p> <p>A potential issue with using getxattr() is that it is vulnerable to Time of Check to Time of Use (TOCTOU) race conditions, which can be problematic for security-enhanced applications.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[KU] - the relative or absolute path name of the file or directory.</li> <li><code>name</code>:<code>const char*</code>[KU] - the name of the attribute to retrieve.</li> <li><code>value</code>:<code>void*</code>[K] - a buffer to store the attribute's value.</li> <li><code>size</code>:<code>size_t</code>[K] - the size of the buffer (size of the attribute's value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/getxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#getxattr_1","title":"getxattr","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#purpose","title":"Purpose","text":"<p>To monitor and audit when getxattr() system calls occur and what their associated arguments are.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#example-use-case","title":"Example Use Case","text":"<p>getxattr() can be used to determine the value of security labels or access control lists on files and directories. This is often necessary for implementing robust security systems for applications that must maintain the integrity of the data on the system.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#issues","title":"Issues","text":"<p>getxattr() is vulnerable to TOCTOU race conditions, which can result in unintended side-effects if not handled correctly.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#related-events","title":"Related Events","text":"<p>setxattr(2)</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gtty/","title":"gtty","text":""},{"location":"docs/events/builtin/syscalls/gtty/#intro","title":"Intro","text":"<p>gtty - Set or get terminal attributes</p>"},{"location":"docs/events/builtin/syscalls/gtty/#description","title":"Description","text":"<p>The gtty syscall is used to enable/disable certain terminal attributes. This includes toggling echoing of typed characters, the end-of-line behavior and special control characters. Additionally, these attributes can be set for the controlling terminal as well.</p> <p>The syscall also allows querying current terminal attributes. This can be useful for some applications to determine the current state of the terminal and set the same for the output.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#arguments","title":"Arguments","text":"<p>No arguments</p>"},{"location":"docs/events/builtin/syscalls/gtty/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gtty/#gtty_1","title":"gtty","text":""},{"location":"docs/events/builtin/syscalls/gtty/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/gtty/#purpose","title":"Purpose","text":"<p>To monitor the manipulation of terminal parameters.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#example-use-case","title":"Example Use Case","text":"<p>An application that uses several terminal attributes, like an ANSI escape sequence enabled terminal emulator. By using gtty, these terminal parameters can be applied to the terminal to ensure a correct display.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#issues","title":"Issues","text":"<p>There are no known issues with this syscall.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#related-events","title":"Related Events","text":"<ul> <li>stty: Set or get terminal attributes</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/idle/","title":"idle","text":""},{"location":"docs/events/builtin/syscalls/idle/#intro","title":"Intro","text":"<p>idle - the system call for resource de-allocation in kernel scheduling.</p>"},{"location":"docs/events/builtin/syscalls/idle/#description","title":"Description","text":"<p>The idle system call allows an application or processes to de-allocate CPU resources. The kernel scheduler can be instructed to keep the CPU available to process other threads without the application or process being interrupted. It is a blocking call and therefore can result in improved performance as it frees up resources to be used elsewhere. Using the idle system call may result in improved responsiveness, lower power consumption and better system utilization.</p>"},{"location":"docs/events/builtin/syscalls/idle/#arguments","title":"Arguments","text":"<p>No arguments are provided for this system call.</p>"},{"location":"docs/events/builtin/syscalls/idle/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/idle/#idle_1","title":"idle","text":""},{"location":"docs/events/builtin/syscalls/idle/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/idle/#purpose","title":"Purpose","text":"<p>To detect when an application or process de-allocates CPU resources.</p>"},{"location":"docs/events/builtin/syscalls/idle/#example-use-case","title":"Example Use Case","text":"<p>Idle can be used for monitoring in a variety of different contexts. It can be used to detect and understand general resource allocation and de-allocation behavior, as well as to look out for applications or processes utilizing too much CPU resources. It might also be used to monitor programs for unexpected CPU utilization, or to detect when an application is stalled for some reason.</p>"},{"location":"docs/events/builtin/syscalls/idle/#issues","title":"Issues","text":"<p>The idle system call may result in higher power consumption as it allows unneeded processes to keep running instead of being interrupted. This can be especially true when lower latency is needed, as the scheduler cannot pre-empt or adjust the process or application as it would with pre-emption.</p>"},{"location":"docs/events/builtin/syscalls/idle/#related-events","title":"Related Events","text":"<ul> <li><code>wait</code>: System call which allows a process to suspend execution until a certain condition is met.</li> <li><code>setpriority</code>: System call that allows a process to modify its scheduling priority.</li> <li><code>sched_yield</code>: System call to voluntarily relinquish the processor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/init_module/","title":"init_module","text":""},{"location":"docs/events/builtin/syscalls/init_module/#intro","title":"Intro","text":"<p>init_module - load a kernel module into the running Linux kernel.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#description","title":"Description","text":"<p>The <code>init_module()</code> system call is responsible for loading and initializing a kernel module into the running Linux kernel. Kernel modules are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionalities of the kernel without the need to reboot the system.</p> <p>This system call facilitates dynamic extension of kernel functionalities, enabling features like device drivers, filesystems, and network protocols to be added or removed on-the-fly.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#arguments","title":"Arguments","text":"<ul> <li><code>module_image</code>:<code>void *</code>[U] - Pointer to the binary image of the module.</li> <li><code>len</code>:<code>unsigned long</code>[K] - Length of the module image.</li> <li><code>param_values</code>:<code>const char *</code>[U] - A string of module parameters, used for customizing the module's behavior. Null-terminated and usually specified in the form \"param1=value1 param2=value2\".</li> </ul>"},{"location":"docs/events/builtin/syscalls/init_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/init_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/init_module/#sys_init_module","title":"sys_init_module","text":""},{"location":"docs/events/builtin/syscalls/init_module/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/init_module/#purpose","title":"Purpose","text":"<p>To monitor and document when the <code>init_module()</code> system call is employed, recording information about the module being loaded and its associated parameters.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#example-use-case","title":"Example Use Case","text":"<p>Detecting unauthorized or suspicious kernel module loadings in security-critical environments can prevent potential system breaches or malicious activities.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#issues","title":"Issues","text":"<p>Loading malicious or poorly designed kernel modules can pose severe security risks or destabilize the system. It's imperative to validate and ensure that only trusted and well-audited modules get loaded into the kernel.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#related-events","title":"Related Events","text":"<ul> <li><code>delete_module()</code> - Remove a loaded kernel module.</li> <li><code>finit_module()</code> - Load a kernel module from a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/","title":"inotify_add_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#intro","title":"Intro","text":"<p>inotify_add_watch - add watch for an open inotify instance</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#description","title":"Description","text":"<p>inotify_add_watch is a system call used to watch a given file or directory for certain events. It will return a watch descriptor that identifies the watch instance. This descriptor is used as an argument for other functions that manipulate the watch instance. Events such as changes in access time, modification time, deletion and close- write operations will trigger notifications. With this system call, the user can specify different types of events that should be monitored.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - the file descriptor associated with an open inotify instance</li> <li><code>pathname</code>:<code>const char*</code>[U] - the path to the file or directory to watch</li> <li><code>mask</code>:<code>u32</code>[K] - a bit mask of events to watch for</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#do_inotify_add_watch","title":"do_inotify_add_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#purpose","title":"Purpose","text":"<p>This function is used to hook inotify_add_watch in order to obtain notifications when a new watch is registered.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#example-use-case","title":"Example Use Case","text":"<p>inotify_add_watch could be used to detect access attempts to certain sensitive files on a system. Whenever the file is accessed, a notification will be sent to the user, allowing them to take appropriate action.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#issues","title":"Issues","text":"<p>Due to the asynchronous nature of inotify_add_watch, there is potential for a race condition when multiple watches are registered on the same file concurrently. Care must be taken to ensure that concurrent update operations don't make use of inconsistent data.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#related-events","title":"Related Events","text":"<ul> <li>inotify_rm_watch - remove watch associated with a given inotify instance associated with given file descriptor</li> <li>inotify_get_events - read the pending events on an inotify file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/","title":"inotify_init","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#intro","title":"Intro","text":"<p>inotify_init -  creates and initializes an inotify event queue</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#description","title":"Description","text":"<p>The inotify_init() system call is used to create an inotify event queue. Inotify event queues allow processes to monitor the file system for changes such as files being opened, deleted, or modified. Any process that has initiated a monitoring operation can be notified asynchronously when a monitored event occurs. </p> <p>Inotify event queues are global and persist until explicitly closed by the process that created them;  thus, inotify provides a means for tracking file changes across multiple processes. It is also useful for many other purposes such as detecting when a file is modified, deleted, or renamed. </p> <p>One of the advantages of using inotify is that it is easy to set up and monitor events in multiple locations; however, its biggest drawback is that it can be quite CPU and I/O intensive as it is eagerly waiting for file system changes.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>: <code>int</code> - Flags from inotify_init.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#purpose","title":"Purpose","text":"<p>To track the opening of files.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#sys_inotify_init","title":"sys_inotify_init","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#type_1","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#purpose_1","title":"Purpose","text":"<p>To track the inotify_init syscall.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#example-use-case","title":"Example Use Case","text":"<p>A use case for inotify might be tracking whether a specific list of files has been modified. A process can call inotify_init, then loop through the list of files and add a watch for each, then wait on the inotify event queue to be notified that a listed file has been modified. </p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#issues","title":"Issues","text":"<p>Certain kernel features may cause inotify to miss events or provide false positives. For example, the kernel may prefetch files, set modification times, and provide optimistic file reads, all of which can lead to unexpected notifications.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#related-events","title":"Related Events","text":"<ul> <li>inotify_add_watch \u2013 adds a watch to an existing inotify event queue</li> <li>inotify_rm_watch \u2013 removes a watch from an existing inotify event queue</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/","title":"inotify_init1","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#intro","title":"Intro","text":"<p>inotify_init1 - create and initialize an inotify instance</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#description","title":"Description","text":"<p><code>inotify_init1</code> is a system call that is used to create and initialize an inotify instance. It has one parameter, flags, which is used to pass flags for modifying the behavior of the inotify instance. If the flags are 0, then the instances is initialized with the default behavior.</p> <p>The inotify API provides a mechanism for monitoring file system events. Inotify supports watching a single file, a directory tree, or recursively all subdirectories.</p> <p>There are some drawbacks to using inotify API. For example, if an application is monitoring a lot of files or directories, then it may require a large amount of memory and kernel resources, as well as negatively impact the performance. Additionally, if too many watches are set up, the kernel may run out of inotify resources and fail the system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - flags that are used to modify the behavior of the inotify instance.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#inotify_init1_1","title":"inotify_init1","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#purpose","title":"Purpose","text":"<p>To monitor when inotify_init1 is called and for what flags values.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#example-use-case","title":"Example Use Case","text":"<p>Inotify API can be used to monitor file system events. For example, an application can detect when a file is modified, renamed, or deleted.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#issues","title":"Issues","text":"<p>Due to the large memory and kernel resources requirements, large numbers of watches can adversely affect the performance of the system. Additionally, if too many watches are set up, the kernel may run out of inotify resources and fail the system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#related-events","title":"Related Events","text":"<ul> <li><code>inotify_add_watch</code> - add a file or directory watch to an inotify instance</li> <li><code>inotify_rm_watch</code> - remove a file or directory watch from an inotify instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/","title":"Inotify_rm_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#intro","title":"Intro","text":"<p>inotify_rm_watch - remove an existing watch on a file system object</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#description","title":"Description","text":"<p>Inotify_rm_watch is a system call that removes existing watches on a file system object, specified by the watch descriptor <code>wd</code> created by the call <code>inotify_add_watch</code> for the file system object associated with the file descriptor <code>fd</code>.</p> <p>Inotify_rm_watch does not change the reference count of the file system object, so if a watch is removed for an object for twice, the object is still watched after the second <code>inotify_rm_watch</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - file descriptor associated to the filesystem object.</li> <li><code>wd</code>: <code>int</code>[K] - watch descriptor created by the call <code>inotify_add_watch</code> for the file system object associated with the file descriptor <code>fd</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#inotify_rm_watch_1","title":"inotify_rm_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#purpose","title":"Purpose","text":"<p>Used to identify calls to the system call <code>inotify_rm_watch</code>. Used for applications that are performing malicious operations on files or directories.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#example-use-case","title":"Example Use Case","text":"<p>Inotify_rm_watch can be used in a security system that keeps tracks on all changes in a directory. The system can set a watch on a directory and track the changes of all files and sub directories. Whenever a new file is created or a existing file is modified, the system can take the appropriate actions.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#issues","title":"Issues","text":"<p>There is currently no known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#related-events","title":"Related Events","text":"<ul> <li><code>inotify_add_watch</code> - used to add watch on a filesystem object.</li> <li><code>inotify_init</code> - used to initialize an inotify instance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/","title":"io_cancel","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#intro","title":"Intro","text":"<p>io_cancel() - cancels asynchronously submitted I/O operations</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#description","title":"Description","text":"<p>io_cancel() cancels asynchronous I/O operations previously submitted using the io_submit() system call or other related system calls. The ctx_id argument specifies the I/O context from which cancellations are done. This argument must point to an existing I/O context which must initially be obtained using the io_setup() system call. The iocb argument points to the I/O control block previously submitted for the corresponding I/O operation which should be cancelled. Finally, the result argument, if non NULL, points to a struct io_event structure which will be written to with the results of the cancelled op. If NULL is passed as the result argument, this indicates that no results should be returned.</p> <p>This call is useful when attempting to cancel previously-submitted I/O operations; however, since the I/O operations are already in progress, some operations may complete before being cancelled. Therefore, it is possible that some I/O operations may return even after this call. If this behaviour is undesired, an application should use the io_getevents() system call with a timeout of 0 and/or a small number of events to drain completed I/O operations before calling io_cancel().</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code> - the I/O context from which cancellations are done</li> <li><code>iocb</code>:<code>struct iocb*</code> - pointer to the I/O control block previously submitted for an I/O operation</li> <li><code>result</code>:<code>struct io_event*</code>[OPT] - pointer to the<code>struct io_event</code> structure which will be written to with the results of the cancelled op.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_cancel/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space. U - Originated from user space (for example, pointer to user space memory used to get it)</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#do_io_cancel","title":"do_io_cancel()","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#purpose","title":"Purpose","text":"<p>Hooked to capture instances of the io_cancel() syscall.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#example-use-case","title":"Example Use Case","text":"<p>The io_cancel() syscall can be used to cancel asynchronous I/O operations that have already been submitted, allowing the application to reclaim resources and/or abort operations that are no longer necessary.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#issues","title":"Issues","text":"<p>It is possible that some I/O operations may return even after the io_cancel() syscall. If this behaviour is undesired, an application should use the io_getevents() system call with a timeout of 0 and/or a small number of events to drain completed I/O operations before calling io_cancel().</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#related-events","title":"Related Events","text":"<ul> <li>io_submit()</li> <li>io_setup()</li> <li>io_getevents()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/","title":"io_destroy","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#intro","title":"Intro","text":"<p>'io_destroy' - destroys an io_context.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#description","title":"Description","text":"<p>The io_destroy() system call function is used to destroy the io_context structure and free operation associated with it. The io_context structure may be freed after all operations have finished executing. The return value specified the remaining number of IO contexts associated with this context_fd number. </p> <p>Generally this syscall is useful when multiple threads, or processes, require service from an asynchronous IO context and the context needs to be destroyed once the operations have completed. It's also possible to use this call with a NULL context_fd, which will temporarily suspend all operations associated with the current context.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[KU] - a pointer to an existing io context structure. </li> </ul>"},{"location":"docs/events/builtin/syscalls/io_destroy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_destroy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#io_destroy_1","title":"io_destroy","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#purpose","title":"Purpose","text":"<p>Trace asynchronous io operations.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#example-use-case","title":"Example Use Case","text":"<p>Tracking the progress of an asynchronous IO operation, or group of IO operations, from start to completion.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#related-events","title":"Related Events","text":"<ul> <li>io_submit</li> <li>io_cancel</li> <li>io_getevents</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/","title":"io_getevents","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#intro","title":"Intro","text":"<p>io_getevents - system call which get events from the completion queue</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#description","title":"Description","text":"<p>io_getevents() is a system call which can be used to retrieve events from the completion queue of specified <code>io_context_t</code> context, identified by ctx_id, if there was something written to the completion queue by an <code>io_io_submit</code> call. The number of events reads from the completion queue is equal to the returned <code>long</code> number, nr, which is equal to the requested maximum nr, or less if the queue doesn't have enough events. The <code>min_nr</code> parameter is the minimum number of events which should be available in the queue, else the call will be blocked. The <code>events</code> array will be filled with the events from the completion queue, or it will be allocated if the <code>events</code> parameter is null. Timeout will specify the time in which the call should finish, otherwise io_getevents will fail.  </p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[K] - io context which will hold the completion queue. </li> <li><code>min_nr</code>:<code>long</code>[K] - minimum number of events which should be available in the completion queue.</li> <li><code>nr</code>:<code>long</code>[K] - maximum number of events which should be read from the completion queue. </li> <li><code>events</code>:<code>struct io_event*</code>[KU] - array which should be filled with the events from the completion queue. If the argument is null, the array will be allocated.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - time in which the call should finish. </li> </ul>"},{"location":"docs/events/builtin/syscalls/io_getevents/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_getevents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#io_getevents_1","title":"io_getevents","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#purpose","title":"Purpose","text":"<p>Tracing the io_getevents syscall, with the goal of monitoring its behaviour.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#example-use-case","title":"Example Use Case","text":"<p>If a user needs to track when io_getevents is called, the io_getevents event is the ideal solution. It will provide information about the syscall such as parameters and duration. This is useful for monitoring low level kernel behavior or for performance analysis.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#issues","title":"Issues","text":"<p>If the <code>events</code> array is allocated in the user space, it could trigger a TOCTOU attack.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#related-events","title":"Related Events","text":"<ul> <li><code>io_submit</code> - This syscall is related to <code>io_getevents</code>, since its responsible for writing to the completion queue which is read by <code>io_getevents</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/","title":"<code>io_pgetevents</code>","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#intro","title":"Intro","text":"<p><code>io_pgetevents</code> - retrieves at least min_nr and at most nr of completed and ready aio operations</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#description","title":"Description","text":"<p>The <code>io_pgetevents</code> syscall retrieves at least <code>min_nr</code> and at most <code>nr</code> of completed and ready aio operations (submitted via <code>io_submit</code>) and up to <code>nr</code> jopbs wich have been canceled. The operations are identified by <code>ctx_id</code> - the AIO context which contains them.</p> <p><code>events</code> is a pointer to an array of <code>io_event</code> structures - to which the completed/ready events' results will be stored. <code>timeout</code> specifies a timeout which limits the amount of time this call will block. <code>usig</code> can be used to request a signal to be sent when ready/completed events are available.</p> <p>The buffers which were submitted with <code>io_submit</code> must not be changed until <code>io_pgetevents</code> is finished.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>aio_context_t</code> - The aio context which contains the operations to be retrieved.</li> <li><code>min_nr</code>:<code>long</code> - The minimum amount of operations to retrieve. If less than this amount of operations are available, the call will block until the desired amount is ready.</li> <li><code>nr</code>:<code>long</code> - The maximum amount of operations to retrieve.</li> <li><code>events</code>:<code>struct io_event*</code>[K] - A pointer to an array of <code>io_event</code> structures, to be filled in with the operations' results.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - A timeout value - the call will block no longer than this.</li> <li><code>usig</code>:<code>const struct __aio_sigset*</code>[K] - A pointer to an <code>__aio_sigset</code> structure which specifies an optional signal to be sent when events become available.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#sys_io_pgetevents","title":"<code>sys_io_pgetevents</code>","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#purpose","title":"Purpose","text":"<p>Analyze and profile AIO  operations in order to debug and improve system performance.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#example-use-case","title":"Example Use Case","text":"<p>An application utilizing AIO operations needs to be tested in order to find out if there are any issues with operation latency or the amount of calls with the same arguments. Using <code>io_pgetevents</code> in conjunction with a tracing software to retrieve AIO operation data can help identify issues and improve performance.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#issues","title":"Issues","text":"<p>Care must be taken with arguments which might change between the time they are checked (\"time of check\") and the time they are used (\"time of use\"), as they might result in errors.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#related-events","title":"Related Events","text":"<ul> <li><code>io_submit</code> - Submitting AIO operations</li> <li><code>io_cancel</code> - Cancel AIO operations</li> <li><code>aio_sigset</code> - Update aio code's signal settings.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/","title":"io_pgetevents_time32","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#intro","title":"Intro","text":"<p>io_pgetevents_time32 - syscall to retrieve data from an I/O controller</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#description","title":"Description","text":"<p>This system call reads (with a timeout) events generated by an I/O controller. The platforms that support this system call are x86-64,  arm64 and ia64. </p> <p>The timeout argument sets an upper bound on the amount of time that the call will block. Setting the timeout to <code>NULL</code> makes the call block until an event is generated. Data of the event is written  into the struct <code>io_event_t</code> which is passed to this call.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#arguments","title":"Arguments","text":"<ul> <li><code>ctx</code>: <code>struct iocb *</code>[U] - pointer to an array of  <code>io_context_t</code> structures. </li> <li><code>nr</code>: <code>long</code>[U] - number of events requested.</li> <li><code>events</code>: <code>struct io_event_t *</code>[U] - pointer to an array of <code>io_event_t</code> structures.</li> <li><code>timeout</code>: <code>struct timespec *</code>[U, TOCTOU] - pointer to a <code>timespec</code> structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#sys_io_pgetevents_time32","title":"sys_io_pgetevents_time32","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#purpose","title":"Purpose","text":"<p>To trace all invocation of <code>io_pgetevents_time32</code> and get the context of each invocation.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to test the responsiveness of a tracee. For example, when checking if a given process is unresponsive or hangs.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#issues","title":"Issues","text":"<p>This system call is vulnerable to Time Of Check/Time Of Use (TOCTOU) race conditions. </p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#related-events","title":"Related Events","text":"<ul> <li>io_destroy - destroys an I/O context assigned to a user</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/","title":"io_setup","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#intro","title":"Intro","text":"<p>io_setup - sets up a new asynchronous I/O context</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#description","title":"Description","text":"<p>The io_setup() system call prepares the data structures and initialization for subsequent use of asynchronous I/O operations. It creates a new asyncronous I/O context with the value nr_events being the maximum number of expected events to be queued for this context. ctx_idp is an output parameter that has null at the start and is assigned to the identifier of the AIO context created.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#arguments","title":"Arguments","text":"<ul> <li><code>nr_events</code>: <code>unsigned int</code> - Maximum number of expected event requests to be queued for this context.</li> <li><code>ctx_idp</code>: <code>io_context_t *</code>[U] - Address to store the identifier of the created AIO context.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_setup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_setup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#do_io_setup","title":"do_io_setup","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/io_setup/#purpose","title":"Purpose","text":"<p>Used to identify when a new asynchronous I/O context is being set up</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#example-use-case","title":"Example Use Case","text":"<p>The io_setup system call can be used in order to monitor the start of new asynchronous I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#related-events","title":"Related Events","text":"<p>io_submit, io_cancel, io_destroy</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/","title":"io_submit","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#intro","title":"Intro","text":"<p>io_submit - submit I/O request(s) to an io_context</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#description","title":"Description","text":"<p>io_submit requests the kernel to perform I/O specified in the given iocb array, which is a list of I/O request blocks. All the I/O operations occur in the given context. This can be used to submit multiple I/O operations within a single system call, reducing the overhead of invoking a system call for each I/O operation. </p> <p>The I/O request list may contain I/O operations on different types of files such as regular files, pipes, block devices, etc. However, it is circular in nature and any links pointing outside the given context must not be followed, since the context stores only the local file descriptors.</p> <p>Although this syscall is usually considered less error-prone than other syscalls that require manual memory management in the user space, it can be vulnerable to Time Of Check-Time Of Use (TOCTOU) attacks on the io_context_t structure. If a race condition exists between the io_context_t structure copying in the user space and the corresponding io_context_t structure's modification in the kernel space, an attacker can exploit this vulnerability to get the system call to fail.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[K] - This is an opaque context structure which is used to send multiple I/O operations within a single system call. </li> <li><code>nr</code>:<code>long</code>[K] - This is the number of elements in the iocbpp array. </li> <li><code>iocbpp</code>:<code>struct iocb**</code>[K] - This is the array of iocb structures which define the I/O operations to be performed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_submit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_submit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#cond_resched","title":"cond_resched","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#type","title":"Type","text":"<p>NONE</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#purpose","title":"Purpose","text":"<p>To prevent unbounded execution in kernel space.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#example-use-case","title":"Example Use Case","text":"<p>One example use case of io_submit is to submit multiple read requests to the kernel in one system call. This reduces the overhead of invoking a system call for each read operation, thereby improving the performance of the program.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#related-events","title":"Related Events","text":"<ul> <li>io_prep_pwrite</li> <li>io_cancel</li> <li>io_getevents</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/","title":"io_uring_enter","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#intro","title":"Intro","text":"<p>io_uring_enter - a system call that submits and optionally waits on a set of I/O operations</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#description","title":"Description","text":"<p>The io_uring_enter system call allows processes to perform I/O operations and optionally wait for their completion. This call combines the submission of a set of I/O operations with the ability to wait on them without making additional system calls. The operations used to fulfill the request are submitted via an io_uring instance associated with the process. The number of operations submitted is given in the to_submit argument and is expected to be a positive integer. </p> <p>The min_complete argument tells the system how many I/O operations need to be completed (or failed) before returning from the io_uring_enter call. This value is also expected to be a positive integer, or zero, if the caller is not interested in waiting on individual I/O completion events. The flags argument is a bitmask of flags that modify the caller's request. The flags can be used to indicate if I/O operations should remain in the submission queue on error, if any registered buffers can be safely reused without the caller double-checking their contents, or if the caller should be woken up if any operation within their submission set completes or fails. </p> <p>The sig argument contains a pointer to a signal set that may be used to unblock system calls being waited on. If set to NULL, the behavior will be the same as that of a call to io_uring_enter without a signal set.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>\u00a0- file descriptor associated with the io_uring instance used to submit I/O requests.</li> <li><code>to_submit</code>:<code>unsigned int</code>[OPT] - the number of I/O requests to submit. </li> <li><code>min_complete</code>:<code>unsigned int</code>[OPT] - the number of I/O requests that need to be completed before io_uring_enter returns.</li> <li><code>flags</code>:<code>unsigned int</code>[OPT] - flags modifying the request submission and completion.</li> <li><code>sig</code>:<code>sigset_t*</code>[U] - pointer to a signal set that may unblock system calls.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (in this case, the sig argument is a pointer to a signal set located in user space).</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#io_uring_enter_1","title":"io_uring_enter","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#type","title":"Type","text":"<p>Kprobe + Ringbuffer </p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#purpose","title":"Purpose","text":"<p>To monitor the submission and completion of I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#example-use-case","title":"Example Use Case","text":"<p>A use case for the io_uring_enter system call could be in an application that needs to monitor the status of a large number of I/O operations. This application could submit requests using the io_uring system and then use the io_uring_enter system call to wait on their completion, without the need to make additional system calls. </p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#issues","title":"Issues","text":"<p>The signal set passed to io_uring_enter is potentially vulnerable to a time of check to time of use (TOCTOU) attack if an unprivileged process can manipulate it before the system call is made.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#related-events","title":"Related Events","text":"<p>The io_uring_submit and io_uring_wait system calls are related to, and should be used in conjunction with, io_uring_enter.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/","title":"io_uring_register","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#intro","title":"Intro","text":"<p>io_uring_register - register an io_uring instance with the kernel</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#description","title":"Description","text":"<p>The io_uring_register() system call is used to register an io_uring instance with the kernel. It sets up various parameters such as io_uring buffers, the io_uring timeout, and the io_uring polled queue depths. It also attaches an io_uring instance to an existing file descriptor.</p> <p>The call allows for registering files, events, memory ranges and other data in an io_uring instance. The io_uring can then be used for operations such as application controlled buffering and queuing, as well as notifying when data is available. </p> <p>This system call is convenient when dealing with a range of I/O operations, as it only needs to be called once. </p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code> - a file descriptor for the io_uring instance.</li> <li><code>opcode</code>:<code>unsigned int</code> - the type of registration to perform with the kernel.</li> <li><code>arg</code>:<code>void*</code> - pointer to an array of structures that describe the data to register.</li> <li><code>nr_args</code>:<code>unsigned int</code> - the number of structures in said array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#io_uring_register_1","title":"io_uring_register()","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#purpose","title":"Purpose","text":"<p>Observe behavior of I/O threads undergoing registration </p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#example-use-case","title":"Example Use Case","text":"<p>The io_uring_register system call is useful for monitoring the activity around I/O complex operations such as file access and network communication. It can be used to identify latency issues, detect anomalous behavior, and catch system issues.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#issues","title":"Issues","text":"<p>The kernel documentation warns that while most of the features of the io_uring_register system call are stable, some internal details (as of 5.3) may still be in flux and may change in future releases.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#related-events","title":"Related Events","text":"<ul> <li>io_uring_submit</li> <li>io_uring_enter</li> <li>io_uring_cq_advance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/","title":"io_uring_setup","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#intro","title":"Intro","text":"<p>io_uring_setup - Setup/initialize an io_uring instance.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#description","title":"Description","text":"<p>The io_uring_setup() syscall sets up the io_uring instance associated with the file descriptor returned by the io_uring_get_fd() syscall. It returns -1 on error, or 0 on success. The io_uring_setup() syscall is used to configure various options on the io_uring instance, such as the sq_ring_size (the size of the submission queue ring in number of elements), cq_ring_size (the size of the completion queue ring in number of elements), flags (various IORING_SETUP_* flags, see below for a list), and other parameters.</p> <p>The io_uring_setup() syscall is used for initializing and configuring the io_uring instance. The caller should fill in the io_uring_params structure pointed to by the p argument, with the desired parameter values prior to calling io_uring_setup().</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#arguments","title":"Arguments","text":"<ul> <li><code>entries</code>:<code>unsigned int</code>[K] - Number of sq and cq entries, must be a power of 2, and size must be &gt;= IORING_MIN_ENTRIES and &lt;= IORING_MAX_ENTRIES. This argument is required.</li> <li><code>p</code>:<code>struct io_uring_params*</code>[K] - Points to struct io_uring_params containing various options. Optional unless the IORING_SETUP_PARAM_* flags are set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#system_call_after_io_uring_setup","title":"system_call_after_io_uring_setup","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#purpose","title":"Purpose","text":"<p>To trace the return value of the io_uring_setup syscall.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#example-use-case","title":"Example Use Case","text":"<p>The io_uring_setup syscall can be used to collect latency data for a particular request. By hooking the io_uring_setup syscall and instrumenting the request with a tracepoint, one can measure the time elapsed between a request being submitted and the completion being returned by the io_uring.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#related-events","title":"Related Events","text":"<ul> <li>io_uring_get_fd - get a file descriptor from an io_uring instance.</li> <li>io_uring_enter - submit IO requests to an io_uring instance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/","title":"ioctl","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#intro","title":"Intro","text":"<p>ioctl - manipulate the device parameters of special files</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#description","title":"Description","text":"<p>A program can control device by performing ioctl operations on the  relevant device files. It takes three parameters, an open file descriptor, a  request that indicates which device control is requested and an argument.  Most devices use their own specific ioctl commands for configuration. Some individual requests may be vulnerable to Time-of-check Time-of-use (TOCTOU)  race conditions.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K]  - File descriptor for the device to be controlled.</li> <li><code>request</code>:<code>unsigned long</code>[K]  -  Refers to a device specific request code.</li> <li><code>arg</code>:<code>unsigned long</code>[K] - Argument for the request. Optional and might not always be available (passed with null value), indicated by [OPT] tag.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#vfs_ioctl","title":"vfs_ioctl","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#purpose","title":"Purpose","text":"<p>The ioctl syscall is hooked to gather information when it is executed.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#example-use-case","title":"Example Use Case","text":"<p>An example of an use case for the ioctl syscall could be in a program that  reads and writes the content of user space memory from a device driver.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#issues","title":"Issues","text":"<p>Race conditions can occur between the moment the request is checked and the  values are used.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#related-events","title":"Related Events","text":"<p>The syscall <code>ioctl</code> is related to other syscalls like <code>read</code> and <code>write</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/","title":"ioperm","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#intro","title":"Intro","text":"<p>ioperm - set/get I/O permissions</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#description","title":"Description","text":"<p>The ioperm system call allows a user to set/get I/O port permissions. It takes a 16-bit starting I/O port, the number of ports to affect, and an enable/disable value (1 or 0). All the I/O ports, from the starting port to the starting port + num - 1, will be set according to the enable/disable value. It affects only the current thread/process.</p> <p>The ioperm system call is used to allow or disallow certain I/O operations on certain parts of the I/O address space. It is used for situations where low-level I/O operations are required, such as when writing device drivers or device access programs.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#arguments","title":"Arguments","text":"<ul> <li><code>from</code>:<code>unsigned long</code>[K] - The starting I/O port.</li> <li><code>num</code>:<code>unsigned long</code>[K] - The number of ports to affect.</li> <li><code>turn_on</code>:<code>int</code>[K] - Enable/disable value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioperm/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioperm/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#sys_ioperm","title":"sys_ioperm","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#purpose","title":"Purpose","text":"<p>Hook to trace when ioperm system call is invoked.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#example-use-case","title":"Example Use Case","text":"<p>An example use case of the ioperm system call is writing a device driver. If the device driver needs to access I/O ports and it needs low-level I/O operations, the ioperm system call can be used to enable/disable access to I/O ports as needed.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#issues","title":"Issues","text":"<p>This system call is limited in that it can only be used on the current thread/process. Additionally, it is only available on x86 architectures. This limits its use-case somewhat.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#related-events","title":"Related Events","text":"<ul> <li>iopl - manipulate I/O privilege level.</li> <li>ioctls (ioctl) - control device.</li> <li>perf_event_open - open a performance monitoring event.</li> <li>userfaultfd - create a userland fault handler.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/iopl/","title":"iopl","text":""},{"location":"docs/events/builtin/syscalls/iopl/#intro","title":"Intro","text":"<p>iopl - set the I/O privilege level of the current process</p>"},{"location":"docs/events/builtin/syscalls/iopl/#description","title":"Description","text":"<p>The <code>iopl</code> syscall sets the I/O privilege level of the current process. It allows a process to have access to I/O port addresses that would otherwise be unavailable. It requires supervisor privileges to execute. If the argument is 0, the I/O privilege level of the current process is set to 0, disabling I/O port access. </p> <p>The I/O privilege level is a construct used by some operating systems that allow for a higher level of control when performing input/output operations. The idea is that certain restricted operations can only be performed by processes that have been granted supervisory privileges.</p> <p>There are several drawbacks to using <code>iopl</code>, such as system instability and security risks. Since the caller has full access to the I/O ports, they could gain unauthorized access, modify or remove critical data, or cause the system to crash.</p>"},{"location":"docs/events/builtin/syscalls/iopl/#arguments","title":"Arguments","text":"<ul> <li><code>level</code>:<code>int</code>[K] - the privilege level the current process should be set to. If the argument is 0, all I/O port access for the current process is disabled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/iopl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/iopl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/iopl/#sys_iopl","title":"sys_iopl","text":""},{"location":"docs/events/builtin/syscalls/iopl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/iopl/#purpose","title":"Purpose","text":"<p>To capture and monitor calls to the <code>iopl</code> syscall, and the arguments passed to it. </p>"},{"location":"docs/events/builtin/syscalls/iopl/#example-use-case","title":"Example Use Case","text":"<p>The <code>iopl</code> syscall can be used by security moniroting applications to detect attempts to set the I/O privilege level, and log the corresponding information.</p>"},{"location":"docs/events/builtin/syscalls/iopl/#issues","title":"Issues","text":"<p>This syscall is not available on all architectures. Furthermore, it cannot be used on kernel versions before 4.7. </p>"},{"location":"docs/events/builtin/syscalls/iopl/#related-events","title":"Related Events","text":"<p>Other syscalls related to accessing I/O ports: <code>ioperm</code>, <code>iopl</code>, <code>portio_in</code>, <code>portio_out</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/","title":"ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#intro","title":"Intro","text":"<p>ioprio_get - get the I/O priority of a process, process group, or user</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#description","title":"Description","text":"<p>This system call returns the I/O priority of a process, process group, or user. It takes two parameters, which and who, which specify the entity for which the I/O priority is queried. The which parameter can be set to IOPRIO_WHO_PROCESS to query a process identified by the ID passed in the who parameter, IOPRIO_WHO_PGRP to query all processes in the process group specified by the who parameter, or IOPRIO_WHO_USER to query for all processes belonging to the user specified by the who parameter. The return value contains both the I/O priority class and the I/O priority value.</p> <p>The I/O priorities are used to order operations from I/O-bound processes so that I/O load on a system is distributed in an equitable manner.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code> - Specifies the entity for which the I/O priority is queried.</li> <li><code>who</code>:<code>int</code> - Specifies the process, process group, or user ID to query.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#sys_ioprio_get","title":"sys_ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#purpose","title":"Purpose","text":"<p>To measure the I/O priority of a process, process group, or user.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#ioprio_get_1","title":"ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#type_1","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#purpose_1","title":"Purpose","text":"<p>To record the process ID of all processes passed to the I/O priority getter.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#example-use-case","title":"Example Use Case","text":"<p>The ioprio_get syscall can be used to measure the efficiency of I/O load balancing in real-world workloads in order to optimize system performance.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#related-events","title":"Related Events","text":"<ul> <li>ioprio_set - set the I/O priority of a process, process group, or user</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/","title":"ioprio_set","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#intro","title":"Intro","text":"<p>ioprio_set - set the I/O scheduling class and priority of a process</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#description","title":"Description","text":"<p>The <code>ioprio_set()</code> system call is used to set the I/O scheduling class and priority of a process, or thread group. The <code>ioprio_set()</code> call takes three parameters: which, who and ioprio and sets the I/O scheduling class and priority of the process specified by which and who to the value specified by ioprio. The class of scheduling is determined by the upper bits of the ioprio argument; the lower bits of ioprio determine the actual priority within the class. The four classes available are IOPRIO_CLASS_RT (real-time class), IOPRIO_CLASS_BE (best effort class), IOPRIO_CLASS_IDLE (idle priority class) and IOPRIO_CLASS_NONE (no class, just the priority).</p> <p>The <code>ioprio_set()</code> call is advantageous because it allows the user to specify the I/O scheduling class and priority for individual applications, threads or thread-groups which makes it possible to ensure that only certain processes receive the I/O resources they need. However, it is important to remember that using this system call in conjunction with unscheduling classes can have adverse effects on other applications and the overall system performance.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>: <code>int</code> - Specifies whether to apply the setting to the current process or thread group (0=current, 1=thread group).</li> <li><code>who</code>: <code>int</code> - Specifies which pid or thread group (tgid) to apply the setting to. Set to 0 for the current thread.</li> <li><code>ioprio</code>: <code>int</code> - Specifies the I/O scheduling class and priority. The value consists of two parts: the class (the 5 most significant bits, bits 4-0 inclusive), and the priority within the class (the 19 least significant bits).</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#doiopriority","title":"DoIOPriority","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#purpose","title":"Purpose","text":"<p>To register IOPriority operations.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#example-use-case","title":"Example Use Case","text":"<p><code>ioprio_set()</code> could be used to ensure that specific applications receive a higher priority, or more resources, than others. For example, a multimedia application needs access to the disk more often than an e-mail application, so setting the I/O priority of the multimedia application to a higher level might help improve the performance of that application.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#issues","title":"Issues","text":"<p>This system call is sensitive to changes and may have unexpected results or have a performance impact if used indiscriminately. It is important to consider the implications before changing the default I/O scheduling class of a process.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#related-events","title":"Related Events","text":"<ul> <li><code>ioprio_get()</code> - get the I/O scheduling class and priority of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ipc/","title":"ipc","text":""},{"location":"docs/events/builtin/syscalls/ipc/#intro","title":"Intro","text":"<p>ipc - System call used traditionally to communicate between processes over a network or through I/O channels.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#description","title":"Description","text":"<p>The <code>ipc</code> system call is used to communicate between processes, either over a network or through I/O channels. It takes a set of arguments which indicate the direction of communication and the parameters needed to set up the communication. The call can be used to either send or receive messages and data to/from a remote process or I/O channel.</p> <p>This system call is useful for the exchange of information between processes without the need for a separate protocol or application-level code. It can also be used for process synchronization, where two or more processes wait for one another to take certain actions before proceeding.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#arguments","title":"Arguments","text":"<ul> <li><code>call</code>:<code>unsigned int</code> -  Specifies which action to take (e.g. send, receive, etc.)</li> <li><code>first</code>:<code>int</code> - Generally a process ID, or an identifier for the resource to be accessed.</li> <li><code>second</code>:<code>unsigned long</code>[OPT] - Additional information for the call, such as the address of a buffer for data transfer.</li> <li><code>third</code>:<code>unsigned long</code>[K] -  Optional data buffer address, used in some commands to transfer data between processes.</li> <li><code>ptr</code>:<code>void*</code>[K] - Pointer to a variable where the actual result of the call is stored if the call was successful.</li> <li><code>fifth</code>:<code>long</code>[OPT] - Used to specify additional flags or options for the call, such as permissions or timeouts.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ipc/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ipc/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ipc/#sys_ipc","title":"sys_ipc","text":""},{"location":"docs/events/builtin/syscalls/ipc/#type","title":"Type","text":"<p>Kprobes / Kretprobes </p>"},{"location":"docs/events/builtin/syscalls/ipc/#purpose","title":"Purpose","text":"<p>To monitor the interaction between processes and the IPC channels.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#example-use-case","title":"Example Use Case","text":"<p>The <code>ipc</code> system call could be used to send a simple message from one process to another. In this case, the message and all associated data could be sent and received within a single call.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#issues","title":"Issues","text":"<p>The <code>ipc</code> call is vulnerable to race conditions when used with the <code>IPC_NOWAIT</code> option, as the command may return before the requested operation is complete.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#related-events","title":"Related Events","text":"<ul> <li><code>msgget</code> - creates a System V message queue</li> <li><code>msgsnd</code> - sends a message to a System V message queue</li> <li><code>msgrcv</code> - receives a message from a System V message queue</li> <li><code>shmget</code> - creates a System V shared memory segment</li> <li><code>shmat</code> - attaches a System V shared memory segment to the calling process</li> <li><code>semget</code> - creates a System V semaphore set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/","title":"kcmp","text":""},{"location":"docs/events/builtin/syscalls/kcmp/#intro","title":"Intro","text":"<p>kcmp - system call used to compare two process id's</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#description","title":"Description","text":"<p>kcmp() is a system call used to compare two process identifiers and see if they have objects with the same index of a given type. This is useful for debugging and other system-level activities, such as running another process with similar resources.</p> <p>The arguments, pid1 and pid2, provide the process identifiers of the two processes to be compared. The type argument provides the type of object to compare and the idx1 and idx2, the indices within the corresponding objects of the two processes.</p> <p>The possible types and corresponding objects are:</p> <ul> <li>0: File descriptors</li> <li>1: Virtual memory areas</li> <li>2: Signals</li> <li>3: Timers</li> <li>4: Tasks (thread groups)</li> <li>5: Process Shared Semaphores</li> <li>6: Futexes</li> </ul> <p>If the two objects compared have the same index and type, the call returns 0. Otherwise, the call returns -1 and errno is set to ESRCH.</p> <p>Advantages of using this system call:</p> <ul> <li>It can be used to compare two processes quickly and safely.</li> <li>Can be used in debugging scenarios.</li> <li>Can detect any differences between two processes accurately.</li> </ul> <p>One of the drawbacks of kcmp is that it takes a long time to execute, since it has to traverse the objects of both processes.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#arguments","title":"Arguments","text":"<ul> <li><code>pid1</code>:<code>pid_t</code> - The process identifier of the first process</li> <li><code>pid2</code>:<code>pid_t</code> - The process identifier of the second process</li> <li><code>type</code>:<code>int</code> - The type of object to compare. See description for a list of possible types</li> <li><code>idx1</code>:<code>unsigned long</code> - The index of the object in the first process</li> <li><code>idx2</code>:<code>unsigned long</code> - The index of the object in the second process</li> </ul>"},{"location":"docs/events/builtin/syscalls/kcmp/#available-tags","title":"Available Tags","text":"<p>No tags applicable.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#hooks","title":"Hooks","text":"<p>No hooks applicable.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#example-use-case","title":"Example Use Case","text":"<p>This system call could be used to compare two processes in order to find any differences between them. This could be useful for debugging or for comparing resources between the two.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#related-events","title":"Related Events","text":"<ul> <li>ptrace - system call used to trace a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/","title":"kexec_file_load","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#intro","title":"Intro","text":"<p>kexec_file_load - Parse a kexec file and load it into memory.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#description","title":"Description","text":"<p>This system call enables the ability to load a kernel image from a file descriptor into the kernel for later execution. It can be used to make changes to the kernel faster, such as with version upgrades or hardware-related updates. This executes from kernel space, so the file descriptors are coming from kernel space.</p> <p>It also has a few drawbacks, such as: * It can be hard to verify that the kernel image is correct and free from malicious code.  * It may be slow to execute, depending on the hardware and how large the kernel image is.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#arguments","title":"Arguments","text":"<ul> <li><code>kernel_fd</code>:<code>int</code>[K] - File descriptor containing the kernel image.</li> <li><code>initrd_fd</code>:<code>int</code>[K] - File descriptor containing the kernel initrd.</li> <li><code>cmdline_len</code>:<code>unsigned long</code>[K] - Length of the kernel command line, in bytes.</li> <li><code>cmdline</code>:<code>const char*</code>[K] - Pointer to kernel command line, in kernel mode memory.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Optional flags to modify the behavior of the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#do_modify_ldt","title":"do_modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#purpose","title":"Purpose","text":"<p>To ensure that the system call does not modify user-space address tables. </p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#example-use-case","title":"Example Use Case","text":"<p>For example, kexec_file_load can be used to quickly switch from one kernel version to another in order to update the system or to reap the benefits of a newer kernel version.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#issues","title":"Issues","text":"<p>It can be susceptible to a Time-of-Check Time-of-Use (TOCTOU) vulnerability if not properly guarded against.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#related-events","title":"Related Events","text":"<ul> <li>kexec_load: Allows loading of a kernel image without parsing it first.</li> <li>kexec_file_unload: Unloads a previously loaded kexec file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/","title":"kexec_load","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#intro","title":"Intro","text":"<p>kexec_load - loads a new kernel for later execution.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#description","title":"Description","text":"<p>kexec_load allows loading or relocating the currently running kernel for later execution. It loads the new kernel from the values provided by its arguments. It allows to perform sanity and memory integrity checks on the new kernel before it is loaded. It also allows for kexec_file_load which does the same job, except it loads the new kernel from a binary on the filesystem.</p> <p>The main advantage of using 'kexec_load' is that it allows the user to safely hotpatch the kernel without rebooting the system. The drawbacks are the relatively low speed of kernel hotpatching and the complexity of relocating the kernel.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#arguments","title":"Arguments","text":"<ul> <li><code>entry</code>:<code>unsigned long</code>[K] - Contains the starting address of the new kernel.</li> <li><code>nr_segments</code>:<code>unsigned long</code>[K] - Contains the number of segments of the new kernel.</li> <li><code>segments</code>: <code>struct kexec_segment*</code>[K] - Contains an array of kexec_segment structures, representing the different address ranges of the new kernel.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Contains the flags used to load the new kernel. Possible flags are KEXEC_ARCH_MASK, KEXEC_FILE_UNLOAD, KEXEC_ON_CRASH, KEXEC_PRESERVE_CONTEXT, KEXEC_CLONE_KERNEL, KEXEC_ON_CRASH_UNLOAD, KEXEC_CLONE_INIT, KEXEC_PRESERVE_PCI and KEXEC_IGNORE_SEGV.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_load/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_load/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#do_sys_kexec","title":"do_sys_kexec","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#purpose","title":"Purpose","text":"<p>Identify kexec system calls, arguments, return values and execution times. </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#load_segments","title":"load_segments","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#type_1","title":"Type","text":"<p>kretprobe </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#purpose_1","title":"Purpose","text":"<p>Identify the segments used for the new kernel loading.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#example-use-case","title":"Example Use Case","text":"<p>An example of kexec_load being used is when the user wants to hotpatch the kernel without rebooting the system. The 'kexec_load' will load the new kernel from the values provided and perform sanity and memory checks to ensure the integrity. It can be used to identify kernel bugs and other system inconsistencies without having to reboot the system. </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#issues","title":"Issues","text":"<p>The main issue with kexec_load is that it is relatively slow compared to other hotpatching methods. It also requires a certain level of complexity as there is a need to relocate the kernel.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#related-events","title":"Related Events","text":"<ul> <li>kexec_file_load - Similar to kexec_load, but it loads the kernel from a file on the filesystem instead. </li> <li>kexec_unload - Unloads a previously loaded kernel.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/keyctl/","title":"keyctl","text":""},{"location":"docs/events/builtin/syscalls/keyctl/#intro","title":"Intro","text":"<p>keyctl - is a system call for manipulating the kernel\u2019s key management facility. </p>"},{"location":"docs/events/builtin/syscalls/keyctl/#description","title":"Description","text":"<p>keyctl is a function in the Linux kernel through which applications can request to manage the kernel's key management facility. It has several operations for creating, accessing, and destroying keys. Creating and accessing keys are usually done in process-local or session-wide aspects. The call can accept up to five arguments, with <code>operation</code> being the first one used to describe what the kernel should do.</p> <p>The use of this call can be advantageous, since it helps in facilitating secure communication between applications and services, in addition to better access control over system calls. This can also be used to ensure secure storage of sensitive data such as encryption keys.</p>"},{"location":"docs/events/builtin/syscalls/keyctl/#arguments","title":"Arguments","text":"<ul> <li><code>operation</code>: <code>int</code> - type of operation to be carried out. It is specified as one of the KEYCTL_ macros.</li> <li><code>arg2</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg3</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg4</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg5</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/keyctl/#available-tags","title":"Available Tags","text":"<ul> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> </ul>"},{"location":"docs/events/builtin/syscalls/keyctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/keyctl/#_1","title":"keyctl","text":"<p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kill/","title":"kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#intro","title":"Intro","text":"<p>kill - send a signal to a process</p>"},{"location":"docs/events/builtin/syscalls/kill/#description","title":"Description","text":"<p>The kill syscall allows a process to send a signal to another process. This can be used to \"kill\" or terminate the process, or send other signals to it, such as for pausing or restarting the process. The signal that is sent will depend on the value of the sig argument, which can take values from any of the signal constants defined in the signal.h header file. The privileged version of this syscall, kill(), can be used to send signals to any process running on the system, while the unprivileged version, tkill(), can only be used to send signals to processes owned by the calling process.</p> <p>One disadvantage of using kill() is that it is vulnerable to a TOCTOU race condition. If the process being killed has changed its state in the window between the time of check and the time of use, the kill() might be attempted on the wrong process.</p>"},{"location":"docs/events/builtin/syscalls/kill/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Identifier of the process the signal is being sent to.</li> <li><code>sig</code>:<code>int</code>[K] - Signal that is being sent. Can be one of the constants defined in the signal.h header file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/kill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kill/#do_kill","title":"do_kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/kill/#purpose","title":"Purpose","text":"<p>To trace when a process is killed by another process.</p>"},{"location":"docs/events/builtin/syscalls/kill/#sys_kill","title":"sys_kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/kill/#purpose_1","title":"Purpose","text":"<p>To trace when a process is killed by another process and retrieve the arguments passed. </p>"},{"location":"docs/events/builtin/syscalls/kill/#example-use-case","title":"Example Use Case","text":"<p>The kill syscall can be used in a monitoring system, where a signal can be sent to a particular process to pause it, then analyse the data and restart it. This can be used to understand how a particular processes behaves over time or over different input values.</p>"},{"location":"docs/events/builtin/syscalls/kill/#issues","title":"Issues","text":"<p>The kill() syscall is vulnerable to a TOCTOU race condition, meaning that the signal might be sent to the wrong process if the one being killed changes its state in the window between the time of check and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/kill/#related-events","title":"Related Events","text":"<p>The kill syscall is often used with the fork() syscall. The fork() syscall allows a process to create a new process, while the kill() syscall can be used to terminate the new process when it is no longer needed.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/","title":"<code>landlock_add_rule</code>","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#intro","title":"Intro","text":"<p><code>landlock_add_rule</code> - adds a security rule to the specified ruleset</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#description","title":"Description","text":"<p><code>landlock_add_rule</code> is a system call used to add a security rule to a particular ruleset. The ruleset is specified by an <code>ruleset_fd</code> of type int, which identifies a particular rule set. The security rule itself is identified by the <code>rule_type</code> of type <code>landlock_rule_type</code> which specifies the type of rule being added. The <code>rule_attr</code> is of type <code>void</code> and is a pointer to a buffer that holds the attributes of the rule. The <code>flags</code> argument is of type <code>u32</code> and it is used to control the behavior of the call.</p> <p>This system call can be used to add a security rule to a particular ruleset which is useful to control the behavior of applications and resources. However, it is important to note that this system call should be used with caution as incorrect rules may create a vulnerability that could be exploited.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#arguments","title":"Arguments","text":"<ul> <li><code>ruleset_fd</code>:<code>int</code>[K] - file descriptor of the ruleset.</li> <li><code>rule_type</code>:<code>landlock_rule_type</code>[K] - type of security rule being added.</li> <li><code>rule_attr</code>:<code>void*</code>[K] - pointer to a buffer containing the attributes of the rule.</li> <li><code>flags</code>:<code>u32</code>[K] - flags to control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#sys_landlock_add_rule","title":"<code>sys_landlock_add_rule</code>","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#purpose","title":"Purpose","text":"<p>Monitoring of the syscall being executed.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_add_rule</code> could be used to limit access to a file by a particular user or group. The ruleset could be configured to deny any access from particular users or groups. This could be used to implement a more granular access control policy.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#issues","title":"Issues","text":"<p>There are no known issues related to this system call.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#related-events","title":"Related Events","text":"<ul> <li><code>landlock_remove_rule</code> - removes a security rule from the specified ruleset.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/","title":"landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#intro","title":"Intro","text":"<p><code>landlock_create_ruleset</code> - create a security ruleset</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#description","title":"Description","text":"<p><code>landlock_create_ruleset</code> creates a Landlock security ruleset. This system call allows the caller to specify the attributes of the new ruleset \u2014 what memory objects can be affected by the ruleset, read/write permissions, and other properties of the ruleset \u2014 as well as the size of the ruleset, and any flags that should be applied. The returned ruleset is private to the calling process, and should not be shared with (or communicated to) other processes. </p> <p>There are a few edge-cases to be aware of when creating rulesets. If a ruleset is created with too low of a size, then it won't be able to hold all of the possible rules that the caller might request. Additionally, a ruleset created with higher size than needed would waste system resources. It's also possible for two or more processes to interfere with each other by attempting to create overlapping rulesets, which could result in policy-level violations.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#arguments","title":"Arguments","text":"<ul> <li><code>attr</code>:<code>struct landlock_ruleset_attr*</code>[U] - pointer to the Landlock attribute for the new ruleset. Contains options like the target object and access permissions.</li> <li><code>size</code>:<code>size_t</code>[U] - the size of the new ruleset, in bytes.</li> <li><code>flags</code>:<code>u32</code>[K] - flags determining optional features when creating the ruleset.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#__x64_sys_landlock_create_ruleset","title":"__x64_sys_landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#purpose","title":"Purpose","text":"<p>Hooks the landlock_create_ruleset function so that its arguments can be processed and the ruleset can be monitored.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#__do_landlock_create_ruleset","title":"__do_landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#purpose_1","title":"Purpose","text":"<p>Hooks the do_landlock_create_ruleset kernel entry point so that the arguments and their values can be inspected.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_create_ruleset</code> can be used as part of a security policy enforcement system. By creating a ruleset with the appropriate access permissions, an application can ensure that processes in its security domain can only access the memory objects that are necessary for their work and no additional objects.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#issues","title":"Issues","text":"<p>Due to the fact that Landlock rulesets are private to the calling process, it's possible for processes to interact in unexpected ways and interfere with each other by attempting to create overlapping rulesets. Care should be taken to ensure that Landlock rulesets are sufficiently large and are properly scoped so that they do not cause any policy-level violations. Additionally, since this system call relies on user-space pointers, it is vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#related-events","title":"Related Events","text":"<ul> <li>landlock_init - initialize landlock</li> <li>landlock_apply - apply ruleset to specified memory object</li> <li>landlock_remove - remove ruleset from specified memory object</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/","title":"landlock_restrict_self","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#intro","title":"Intro","text":"<p><code>landlock_restrict_self</code> - restrict the current process from creating new objects </p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#description","title":"Description","text":"<p>This system call creates the specified restrictions on the current process. Specifically, it prevents the process from creating any new objects or changing the labels or container of existing objects. This is useful when a process needs to be restricted from unintended activities, such as creating new executable files, opening a socket, or executing code. The restrictions are enforced on the entire process and cannot be circumvented by the process itself.</p> <p>The system call takes two parameters - a file descriptor, <code>ruleset_fd</code>, to a ruleset object that defines the restrictions and <code>flags</code> that control the behavior of the system call. The ruleset file descriptor can point to either a ruleset object or a filesystem object. </p> <p>The <code>flags</code> parameter can be used to control how the new restriction is applied. For example, setting the <code>PARSE_ARGUMENT</code> flag will cause the system call to parse the arguments before applying the new restriction. This can help prevent undesired system call behaviors. </p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#arguments","title":"Arguments","text":"<ul> <li><code>ruleset_fd</code>: <code>int</code>[U] - a file descriptor pointing to a ruleset object or a filesystem object.</li> <li><code>flags</code>: <code>u32</code>[U] - a bitmask of flags that control the behavior of the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#sys_landlock_restrict_self","title":"sys_landlock_restrict_self","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#purpose","title":"Purpose","text":"<p>This system call is hooked to restrict the current process from creating new objects or changing the labels or container of existing objects.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_restrict_self</code> can be used to limit the capabilities of an untrusted process, such as one downloaded from an unverified source on the internet. By setting the appropriate restrictions on the file descriptor supplied as an argument, it is possible to limit the actions taken by a potentially malicious process.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#issues","title":"Issues","text":"<p>The <code>flags</code> argument is optional, which can create issues where certain side effects of the system call are not taken into consideration.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#related-events","title":"Related Events","text":"<ul> <li>landlock_unrestrict_self: remove the previously set restrictions imposed by <code>landlock_restrict_self</code> </li> <li>landlock_get_restrictions: retrieve the restrictions previously set by <code>landlock_restrict_self</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lchown/","title":"lchown","text":""},{"location":"docs/events/builtin/syscalls/lchown/#intro","title":"Intro","text":"<p>lchown - change the owner and group of a symbolic link.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#description","title":"Description","text":"<p>The <code>lchown()</code> system call is used to change the owner and group of a specified symbolic link, without dereferencing it. The new owner and group are specified by the <code>owner</code> and <code>group</code> arguments respectively.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U,TOCTOU] - Path to the symbolic link whose owner and group are to be changed.</li> <li><code>owner</code>:<code>uid_t</code>[K] - User identifier of the new owner.</li> <li><code>group</code>:<code>gid_t</code>[K] - Group identifier of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lchown/#sys_lchown","title":"sys_lchown","text":""},{"location":"docs/events/builtin/syscalls/lchown/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/lchown/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>lchown()</code> system call is performed, collecting information about the symbolic link, and the new owner and group.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in symbolic link ownership in a system, especially in scenarios where the dereferencing of symbolic links needs to be avoided.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#issues","title":"Issues","text":"<p>The <code>lchown()</code> system call can be subjected to TOCTOU issues, where the symbolic link specified by <code>pathname</code> could be changed between the time of check and the time of use, leading to potential security risks.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#related-events","title":"Related Events","text":"<ul> <li>chown()</li> <li>fchown()</li> <li>fchownat()</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/","title":"lchown16","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#intro","title":"Intro","text":"<p>lchown16 - the lchown16() function changes the ownership and group of the file referenced by pathname to the numeric uid and gid.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#description","title":"Description","text":"<p>The lchown16() function is a system call used to change the user ID and group ID of the file referenced by pathname. This can only be done by the user who owns the file or by the superuser. It does not affect symbolic links. This system call does not dereference pathname, so the ownership of a symbolic link itself is modified rather than the file referenced.</p> <p>This system call applies to Linux systems with an old 32-bit user ID space and should not be used on current systems.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Path of the file to change the owner and group.</li> <li><code>owner</code>:<code>old_uid_t</code>[K] - Numeric ID of the owner.</li> <li><code>group</code>:<code>old_gid_t</code>[K] - Numeric ID of the group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#sys_lchown16","title":"sys_lchown16","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#type","title":"Type","text":"<p>Kprobes.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#purpose","title":"Purpose","text":"<p>Hook this function to monitor ownership changes of files on the system.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used by an application to make sure that a file or directory has the expected user and group ownership before it is created.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#issues","title":"Issues","text":"<p>The lchown16() system call should not be used on current systems with the new 64-bit user ID and group ID spaces.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#related-events","title":"Related Events","text":"<ul> <li>chown() - similar system call for files in the current ID space. </li> <li>stat() - used to get file and ownership information. </li> <li>geteuid() - used to get the effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/","title":"lgetxattr","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#intro","title":"Intro","text":"<p>lgetxattr - Get the value of an extended attribute for a given file.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#description","title":"Description","text":"<p>lgetxattr returns the value of an extended attribute associated with the given file to the variable pointed to by value. The size of the extended attribute should be no more than size, and will be stored in the variable pointed to by size. Extended attributes are associated with a file, directory, or other filesystem object, and are extensions to the normal attributes associated with every filesystem object, such as its size or permissions.</p> <p>Due to kernel implementation details and filesystem limitations, detailed information about extended attributes may not be available until lgetxattr returns. In such cases, the size returned in size may not properly reflect the size of the extended attribute, meaning that the value returned in value may not be the whole of what is expected. Additionally, extended attribute values may include special values and certain filesystem attributes that may require additional processing prior to use. If the actual size of the extended attribute exceeds the specified size, the value contained in value will be truncated and only the first size bytes will be returned in value. </p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - Path of the file whose attribute is to be retrieved.</li> <li><code>name</code>:<code>const char*</code>[K] - Name of the attribute being retrieved.</li> <li><code>value</code>:<code>void*</code>[K U] - Pointer to user-space address that will store the attribute value.</li> <li><code>size</code>:<code>size_t</code>[K U] - Size of the buffer pointed to by *value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use) </li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#lgetxattr_1","title":"lgetxattr","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#purpose","title":"Purpose","text":"<p>To retrieve the extended attribute value for a given file.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#example-use-case","title":"Example Use Case","text":"<p>lgetxattr could be used to retrieve xattrs (including security labels) from files, to enable security audits, tracing or other requirements such as mandatory access control.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#issues","title":"Issues","text":"<p>Due to its nature, lgetxattr can potentially be subject to TOCTOU (time of check, time of use) race condition attacks. Care should be taken to ensure that the requested attribute is consistent between syscall entry and exit.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#related-events","title":"Related Events","text":"<p>sys_getxattr, sys_listxattr, sys_fgetxattr, sys_setxattr, sys_fsetxattr</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/link/","title":"link","text":""},{"location":"docs/events/builtin/syscalls/link/#intro","title":"Intro","text":"<p>link - create hard links to a file </p>"},{"location":"docs/events/builtin/syscalls/link/#description","title":"Description","text":"<p>The link() system call is used to create a link or hard link between two files. It creates a new name for an existing file. A hard link is essentially a directory entry that associates a name with a file on a particular file system. If a file has multiple hard links, any of these names can be used to read, write, open, or delete from the file. </p> <p>There are some edge cases that might arise when using this system call. One of them is that the user does not have privileges to create a link in the specified directory. Another is that if the user tries to make a link to a file that is located in another file system, then it will be rejected. Also, there is no way to restrict the number of hard links to a file, which means that it can easily consume a lot of storage space.</p> <p>However, there are advantages in using the link() system call. Creating hard links is a fast process since it does not require any disk block transfer. Moreover, since files are linked together, operations done in one file are reflected in the other. This can be useful when then need to update multiple copies of the same file simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/link/#arguments","title":"Arguments","text":"<ul> <li><code>oldpath</code>: <code>const char*</code>[U] - Path to existing file.  </li> <li><code>newpath</code>:<code>const char*</code>[U] - Path to create the link at.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/link/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/link/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/link/#sys-link","title":"sys-link","text":""},{"location":"docs/events/builtin/syscalls/link/#type","title":"Type","text":"<p>Kprobes  </p>"},{"location":"docs/events/builtin/syscalls/link/#purpose","title":"Purpose","text":"<p>To detect and trace creating of directory links</p>"},{"location":"docs/events/builtin/syscalls/link/#example-use-case","title":"Example Use Case","text":"<p>The link() system call can be used to detect and trace malicious or suspicious file modification. For example, if a malicious user is trying to modify or delete files in a system, creating/deleting a hard link to the file is one way to do this. Tracking the link() system call will notify if any files are modified in this way.</p>"},{"location":"docs/events/builtin/syscalls/link/#issues","title":"Issues","text":"<p>The link() system call is vulnerable to TOCTOU (time of check, time of use) race conditions, in which different users can execute different instruction sequences between check and use of file links, with potential security implications.</p>"},{"location":"docs/events/builtin/syscalls/link/#related-events","title":"Related Events","text":"<ul> <li><code>unlink</code> - system call that deletes the given file name.  </li> <li><code>unlinkat</code> - system call that deletes the file at the specified directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/linkat/","title":"linkat","text":""},{"location":"docs/events/builtin/syscalls/linkat/#intro","title":"Intro","text":"<p>linkat - create a link to a file or directory</p>"},{"location":"docs/events/builtin/syscalls/linkat/#description","title":"Description","text":"<p>The <code>linkat</code> system call creates a new link to an existing file or directory, with the pathname specified by <code>oldpath</code> and <code>newpath</code>. This can be used to create hard links across different file systems, and is especially useful when multiple copies of a file are present in different directories. The <code>flags</code> argument can be used to control the behavior of <code>linkat</code> with regard to symlinks, directory structure, and other aspects of the call.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - file descriptor for the old directory. If <code>AT_EMPTY_PATH</code>, interpret <code>oldpath</code> relative to the current working directory.</li> <li><code>oldpath</code>:<code>const char*</code>[U] - path to the existing file or directory to link from. Must be a relative or absolute path.</li> <li><code>newdirfd</code>:<code>int</code>[K] - file descriptor for the new directory. If <code>AT_EMPTY_PATH</code>, interpret <code>newpath</code> relative to the current working directory.</li> <li><code>newpath</code>:<code>const char*</code>[U] - path to the existing file or directory to link to. Must be a relative or absolute path.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - control behavior of <code>linkat</code>. Flag values may include <code>AT_DONTFORK</code>, <code>AT_FOLLOW</code>, <code>AT_SYMLINK_FOLLOW</code>, and <code>AT_EMPTY_PATH</code>. If a negative flag value is passed, then the <code>flags</code> parameter is ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/linkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/linkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/linkat/#sys_linkat","title":"sys_linkat","text":""},{"location":"docs/events/builtin/syscalls/linkat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/linkat/#purpose","title":"Purpose","text":"<p>To trace the system call linkat</p>"},{"location":"docs/events/builtin/syscalls/linkat/#example-use-case","title":"Example Use Case","text":"<p>To monitor a system running multiple different file systems and identify links being created between them.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#issues","title":"Issues","text":"<p>If <code>AT_EMPTY_PATH</code> is used to pass the <code>oldpath</code> or <code>newpath</code> argument, the path name is resolved with the current working directory. If a process changes its working directory, the result may differ from the result from the previous call, so this could be a security issue.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#related-events","title":"Related Events","text":"<ul> <li>renameat </li> <li>symlinkat </li> <li>unlinkat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/listen/","title":"listen","text":""},{"location":"docs/events/builtin/syscalls/listen/#intro","title":"Intro","text":"<p>listen - listen for incoming connection requests from the network.</p>"},{"location":"docs/events/builtin/syscalls/listen/#description","title":"Description","text":"<p>The listen syscall determines the conditions for incoming connection requests from the network. Under normal circumstances, a socket created using the socket syscall is used for this purpose. The listen syscall informs the kernel that the socket is to be used as a listening socket, and it is used to accept incoming connection requests.</p> <p>The listen syscall is used to mark a socket as being ready to accept incoming connection requests. There are no edge-cases, drawbacks or advantages of using this syscall, as it is simply a necessary step in the process of setting up a server.</p>"},{"location":"docs/events/builtin/syscalls/listen/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - This is the file descriptor for the socket. It must refer to a socket that has been created with the socket syscall and not yet bound to a local address.</li> <li><code>backlog</code>:<code>int</code>[K] - This is the maximum size of the queue of pending connections. This is the number of connections that can be waiting while the process is handling a particular connection.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listen/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listen/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/listen/#sys_listen","title":"sys_listen","text":""},{"location":"docs/events/builtin/syscalls/listen/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/listen/#purpose","title":"Purpose","text":"<p>To measure the time it takes for the listen syscall to complete and gather information about the various syscall arguments.</p>"},{"location":"docs/events/builtin/syscalls/listen/#example-use-case","title":"Example Use Case","text":"<p>The listen syscall can be used to set up a server that will accept incoming connection requests from the network. A common use case would be a web server that listens for incoming requests from web browsers. </p>"},{"location":"docs/events/builtin/syscalls/listen/#issues","title":"Issues","text":"<p>There are no known issues with the listen syscall.</p>"},{"location":"docs/events/builtin/syscalls/listen/#related-events","title":"Related Events","text":"<p>The socket syscall is the syscall used to create a socket and is related to the listen syscall. The accept syscall is used to actually accept incoming connections after listen has been used.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/","title":"listxattr","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#intro","title":"Intro","text":"<p>listxattr - retrieves the list of extended attributes associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#description","title":"Description","text":"<p>listxattr retrieves the list of extended attributes associated with file referenced by path and stores it in list. The argument size specifies the size of the buffer pointed to by list and may be 0 for when only the size of the attribute list is needed.</p> <p>The returned attributes are in the form of a list of null-terminated attribute names. No attribute values are retrieved by this call. Attributes can have sizes up to 128 bytes (XATTR_SIZE_MAX).</p> <p>listxattr can be used to query the list of supported xattrs if the maximum size of an xattr is not known.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - A pathname of item for which to list extended attributes.</li> <li><code>list</code>:<code>char*</code> - A list of the extended attributes associated with the file.</li> <li><code>size</code>:<code>size_t</code> - Max buffer size of the buf argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#fcntl","title":"fcntl","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#purpose","title":"Purpose","text":"<p>To observe sys calls of applications and kernel activity.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#do_listxattr","title":"do_listxattr","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#purpose_1","title":"Purpose","text":"<p>To profile the listxattr syscall.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#example-use-case","title":"Example Use Case","text":"<p>listxattr can be used to list or inspect the extended attributes of a file or directory.  For example, on a filesystem with POSIX Access Control Lists enabled, listxattr can be used to determine if a user has the correct permissions for a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#issues","title":"Issues","text":"<p>listxattr does not traverse mounted filesystems, so it will not list an extended attribute located on a mounted filesystem.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#related-events","title":"Related Events","text":"<p>getxattr, removexattr, setxattr</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/","title":"llistxattr","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#intro","title":"Intro","text":"<p>llistxattr - get extended attribute names for a file</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#description","title":"Description","text":"<p>The <code>llistxattr</code> syscall is used to retrieve the list of names of extended attributes associated with the specified file path. The names are stored as a NULL-terminated array of strings in the buffer pointed to by <code>list</code>. The buffer should have a size of <code>size</code> bytes. The size can be found by calling <code>fgetxattr</code> on the file with a NULL buffer. If the list size exceeds <code>size</code>, then <code>ERANGE</code> is returned, and a higher size should be used.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - path to the file or directory</li> <li><code>list</code>:<code>char*</code>[K,U] - buffer used to transfer attribute names</li> <li><code>size</code>:<code>size_t</code>[K] - size of buffer for attribute list</li> </ul>"},{"location":"docs/events/builtin/syscalls/llistxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/llistxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#sys_listxattr","title":"sys_listxattr","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#type","title":"Type","text":"<p>Kprobes and Uprobe.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#purpose","title":"Purpose","text":"<p>Capturing attempts to retrieve a list of extended attributes associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#example-use-case","title":"Example Use Case","text":"<p>A monitoring app is monitoring and securing user data to determine if a user is engaging in a forbidden behavior. The app uses the <code>llistxattr</code> syscall to determine what extended attributes are associated with the user files.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#issues","title":"Issues","text":"<p>This syscall may be vulnerable to TOCTOU (time-of-check-time-of-use) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#related-events","title":"Related Events","text":"<ul> <li><code>fgetxattr</code> - get the value of a single extended attribute for a file</li> <li><code>lgetxattr</code> - get the value of an extended attribute for a file</li> <li><code>setxattr</code> - set an extended attribute for a file</li> <li><code>lsetxattr</code> - set an extended attribute for a file relative to a directory</li> <li><code>removexattr</code> - remove an extended attribute for a file or directory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/llseek/","title":"llseek","text":""},{"location":"docs/events/builtin/syscalls/llseek/#intro","title":"Intro","text":"<p>llseek - used to change the file position of a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/llseek/#description","title":"Description","text":"<p>llseek is a system call used for setting the file pointer of the open file descriptor to a specified offset. It is useful for accessing random locations of a file instead of sequentially. When using this syscall, the offset specified is a 64-bit unsigned long number which is divided into two parts, the 'offset high' and 'offset low' parts. The 'whence` parameter is used to determine the location in the file from which the offset is determined. The resulting file position is stored in the user-supplied 'result' argument which is an loff_t pointer. </p> <p>There are some important drawbacks when using llseek. Firstly, the whence argument is not atomic, so if the file position is changed by another process during the call, the call will become invalid. Secondly, the offsets specified with this call do not exceed the maximum offset available when using 32 bit systems. This can be a problem when trying to access the very end of a large file. Lastly, since the loff_t pointer is user-supplied, it is vulnerable to TOCTOU (time of check, time of use) and to being incorrectly passed as an argument. </p>"},{"location":"docs/events/builtin/syscalls/llseek/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - The file descriptor associated with the file which the user wants to change the position of. </li> <li><code>offset_high</code>:<code>unsigned long</code>[U] - The high part of the 64-bit offset which the user wishes to set the file position to.</li> <li><code>offset_low</code>:<code>unsigned long</code>[U] - The low part of the 64-bit offset which the user wishes to set the file position to.</li> <li><code>result</code>:<code>loff_t*</code>[K] - The pointer to the user-supplied variable which will hold the resulting file position after llseek is called.</li> <li><code>whence</code>:<code>unsigned int</code>[U] - Integer which determines the location from which the offset is determined, as specified in the linux manual page for llseek.</li> </ul>"},{"location":"docs/events/builtin/syscalls/llseek/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space. U - Originated from user space (for example, pointer to user space memory used to get it) TOCTOU - Vulnerable to TOCTOU (time of check, time of use) OPT - Optional argument - might not always be available (passed with null value)</p>"},{"location":"docs/events/builtin/syscalls/llseek/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/llseek/#sys_llseek","title":"sys_llseek","text":""},{"location":"docs/events/builtin/syscalls/llseek/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/llseek/#purpose","title":"Purpose","text":"<p>This function is hooked to allow tracing of the llseek syscall.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#example-use-case","title":"Example Use Case","text":"<p>The llseek syscall could be used in a program which needed to access portions of a file randomly without reading the entire file.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#issues","title":"Issues","text":"<p>Since the loff_t pointer is user-supplied and not checked to the kernel, the pointer is vulnerable to TOCTOU and incorrect arguments.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#related-syscalls","title":"Related Syscalls","text":"<ul> <li>lseek - used to set the file position of a file descriptor without needing to pass two arguments for the offset.</li> <li>pread - used to read from a specific offset in a file without needing to set the file pointer manually.</li> <li>pwrite - used to write from a specific offset in a file without needing to set the file pointer manually.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lock/","title":"lock","text":""},{"location":"docs/events/builtin/syscalls/lock/#intro","title":"Intro","text":"<p>lock -  locks a file or an entire filesystem.</p>"},{"location":"docs/events/builtin/syscalls/lock/#description","title":"Description","text":"<p>The lock syscall is used to set, reset or test for the presence of a lock on a file or an entire filesystem. It can be used to prevent concurrent access to a file by multiple processes. When a lock is set, other processes are prevented from accessing the file until the lock is released. The lock allows synchronizing the access to the file and this may improve performance if multiple processes need to use the same data. However, the lock syscall itself prevents the access to a file and should be used only when absolutely necessary, otherwise it can cause performance degradation and even deadlocks. </p>"},{"location":"docs/events/builtin/syscalls/lock/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - a file descriptor that must be open for reading or writing</li> <li><code>cmd</code>:<code>int</code>[K] - specifies the operation to be performed. This can be <code>F_SETLK</code>, <code>F_SETLKW</code> or <code>F_GETLK</code></li> <li><code>lock</code>:<code>struct flock</code>[K] - points to a <code>struct flock</code> which contains the members <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, <code>l_len</code> and <code>l_pid</code>. </li> </ul>"},{"location":"docs/events/builtin/syscalls/lock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lock/#do_fcntl","title":"do_fcntl","text":""},{"location":"docs/events/builtin/syscalls/lock/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/lock/#purpose","title":"Purpose","text":"<p>The kernel function do_fcntl is the entry point for the fcntl syscall, one of the primary system calls for file control. Specifically, it handles the lock operation, which is used for locking files and filesystems.</p>"},{"location":"docs/events/builtin/syscalls/lock/#example-use-case","title":"Example Use Case","text":"<p>The lock syscall can be used to ensure file access by multiple processes is mutually exclusive and can improve performance when working with the same data.</p>"},{"location":"docs/events/builtin/syscalls/lock/#issues","title":"Issues","text":"<p>If the lock is not properly released, due to a crash or program being terminated, it can cause a deadlock and all following processes will be blocked.</p>"},{"location":"docs/events/builtin/syscalls/lock/#related-events","title":"Related Events","text":"<ul> <li>fcntl - gathers generic information about the fcntl syscall.</li> <li>read - triggers when a number of bytes was read from a file descriptor.</li> <li>write - triggers when a number of bytes was written to a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/","title":"lookup_dcookie","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#intro","title":"Intro","text":"<p>lookup_dcookie - assigns a process identification number (pid) to the given cookie</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#description","title":"Description","text":"<p>The lookup_dcookie syscall relates a cookie value with a process identification (pid). The cookie is an unsigned long integer, usually obtained by get_pid_list() syscall. The syscall has a buffer of type char*, and its size is given by the argument len. The buffer contains the path of the executable related with the pid. The result is negative if the search fails.</p> <p>This syscall can be used to obtain a process related information such as its executable path.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#arguments","title":"Arguments","text":"<ul> <li><code>cookie</code>:<code>u64</code> - unsigned long integer containing the cookie value.</li> <li><code>buffer</code>:<code>char*</code>[KU] - user space pointer to a buffer of type char*, where the path of the executable will be written.</li> <li><code>len</code>:<code>size_t</code>[KU] - user space pointer to the size of the buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#sys_lookup_dcookie","title":"sys_lookup_dcookie","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#purpose","title":"Purpose","text":"<p>Hooked to gain visibility into the system calls that assign a process identification to the given cookie.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#example-use-case","title":"Example Use Case","text":"<p>The lookup_dcookie syscall can be used to identify the executable responsible for a particular process running on the system. It can also be used to monitor the system for processes initiating with a same cookie value.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#issues","title":"Issues","text":"<p>If the buffer is too small, the syscall may fail, leading to an incomplete path.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#related-events","title":"Related Events","text":"<ul> <li>get_pid_list</li> <li>read_exec</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/","title":"lremovexattr","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#intro","title":"Intro","text":"<p>lremovexattr - remove an extended attribute from a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#description","title":"Description","text":"<p>The lremovexattr() system call removes the extended attribute specified by <code>name</code> from the file specified by <code>path</code>. Extended attributes are metadata associated with a file or directory, which may include things such as access control lists, security labels, and file system capabilities. If the <code>path</code> argument refers to a symbolic link, the attributes of the symbolic link itself are modified, rather than the attributes of the file or directory referenced by the symbolic link.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code> : <code>const char*</code> [K] - Path to the file or directory.</li> <li><code>name</code> : <code>const char*</code> [K] - Name of the attribute to be removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#sys_removexattr","title":"sys_removexattr","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#purpose","title":"Purpose","text":"<p>To detect calls and returns of the lremovexattr() syscall.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#example-use-case","title":"Example Use Case","text":"<p>An application might use lremovexattr() to remove extended attributes such as an ACL from a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#issues","title":"Issues","text":"<p>The lremovexattr() system call is not supported on many systems.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#related-events","title":"Related Events","text":"<ul> <li>lgetxattr</li> <li>llistxattr</li> <li>lsetxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lseek/","title":"lseek","text":""},{"location":"docs/events/builtin/syscalls/lseek/#intro","title":"Intro","text":"<p>lseek - Moves read/write file offset</p>"},{"location":"docs/events/builtin/syscalls/lseek/#description","title":"Description","text":"<p>This event is used to move the file offset of a specified file descriptor. The <code>fd</code> argument specifies the file descriptor on which to move the offset and the <code>offset</code> argument specifies the offset relative to <code>whence</code>. The <code>whence</code> argument specifies the location for the offset relative to the beginning of the file, the current position, or the end of the file, respectively.</p> <p>There are some edge cases to be aware of when using lseek. If lseek is used with <code>whence</code> set to SEEK_END and offset set to 0, it logically sets the read/write pointer of the original file. This can make it difficult to track the offset of the original file. Additionally, lseek can be used to extend the file size, allowing users to write beyond the current file size without an explicit write system call. This is not secure and should be use carefully.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor value.</li> <li><code>offset</code>:<code>off_t</code>[K] - Offset to move the read/write pointer to.</li> <li><code>whence</code>:<code>unsigned int</code>[K] - Specifies the location for the offset relative the beginning of the file, the current position, or the end of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lseek/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lseek/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lseek/#sys_lseek","title":"sys_lseek","text":""},{"location":"docs/events/builtin/syscalls/lseek/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lseek/#purpose","title":"Purpose","text":"<p>Track the syscall invocation and returns.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#example-use-case","title":"Example Use Case","text":"<p>The lseek event can be used to monitor any attempts at shrinking or extending the size of an open file. A program can use the lseek event to detect an attempt to extend the file size and alert the user accordingly.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#issues","title":"Issues","text":"<p>In certain cases, lseek can be used to extend the length of a file without explicitly calling a write systemcall. This lack of control can lead to security vulnerabilities in programs which process files of a predefined length.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#related-events","title":"Related Events","text":"<ul> <li>fstat - Monitor calls to fstat to detect changes in the file size.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/","title":"lsetxattr","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#intro","title":"Intro","text":"<p>lsetxattr - sets the value of a extended attribute in the filesystem</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#description","title":"Description","text":"<p>The lsetxattr() system call sets the value of an extended attribute associated  with a file or directory referenced by path. The attributes are interpreted  according to the namespace indicated by the prefix argument. The value  parameter is a byte array of size size that will be associated with the  attribute identified by the pair of arguments (path, name).</p> <p>The flags argument is currently undefined on Linux systems, and should be  specified as 0.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - A pointer to a string indicating the path of the file or directory.</li> <li><code>name</code>:<code>const char*</code>[K] - A pointer to a string with the name of the extended attribute to set.</li> <li><code>value</code>:<code>const void*</code>[K] - A pointer to a buffer with the value for the extended attribute.</li> <li><code>size</code>:<code>size_t</code>[K] - The size of the buffer.</li> <li><code>flags</code>:<code>int</code>[K] - A value that is currently undefined on Linux and should be specified as 0.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#lsetxattr_1","title":"lsetxattr","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#purpose","title":"Purpose","text":"<p>To monitor the activity of lsetxattr syscalls.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#example-use-case","title":"Example Use Case","text":"<p>Real-time monitoring of lsetxattr syscalls being called to provide insights into  the access and modification of extended file attributes on a system.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#related-events","title":"Related Events","text":"<p>lgetxattr, fsetxattr, fgetxattr, listxattr, removexattr.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lstat/","title":"lstat","text":""},{"location":"docs/events/builtin/syscalls/lstat/#intro","title":"Intro","text":"<p>lstat() - Get file status</p>"},{"location":"docs/events/builtin/syscalls/lstat/#description","title":"Description","text":"<p>The lstat() system call is used to get information about the file at a certain location in the filesystem. The information is stored in the struct stat and can be used for various purposes including permissions checking, file size, time stamps, etc. The lstat() does not follow symbolic links, so it should be called for each link in order to get its status. </p>"},{"location":"docs/events/builtin/syscalls/lstat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char *</code>[U] - A pointer to a character string with the pathname of the file which status is wanted.</li> <li><code>statbuf</code>:<code>struct stat *</code>[K] - A pointer to a stat structure where the status information will be stored. </li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lstat/#sys_lstat","title":"sys_lstat","text":""},{"location":"docs/events/builtin/syscalls/lstat/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/lstat/#purpose","title":"Purpose","text":"<p>To capture system events related to the lstat() system call.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#example-use-case","title":"Example Use Case","text":"<p>Using lstat() in order to check the permissions of a certain file before actually accessing it.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#issues","title":"Issues","text":"<p>The lstat() system call might not work properly in some systems.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#related-events","title":"Related Events","text":"<p>open(), read(), write(), close(), fstat()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/","title":"lstat64","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#intro","title":"Intro","text":"<p>lstat64 - Retrieve information about a file</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#description","title":"Description","text":"<p>The lstat64() system call is used to retrieve information about a file or symbolic link stored in the file system. The information returned by lstat64() is similar to that returned by stat64(), but lstat64() does not follow symbolic links. The lstat64() system call is useful if the application needs to check the file type of a symbolic link, or if the target of the link might be a directory.</p> <p>The lstat64() system call is also useful for finding out whether the file is a regular file, a symbolic link, a directory, a char special device, a block special device, a named pipe, a socket, or an executable image.</p> <p>The lstat64() system call is part of the Base Specifications Issue 6 (SUSv6) and conforms to IEEE Std 1003.1-2008 (POSIX.1).</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>: <code>const char*</code>[K] - File or directory path.</li> <li><code>statbuf</code>: <code>struct stat64*</code>[U] - Pointer to the given structure, containing information about the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#fmode_create","title":"fmode_create","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#purpose","title":"Purpose","text":"<p>To detect when the lstat64 system call is invoked.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#example-use-case","title":"Example Use Case","text":"<p>A file integrity monitoring system or a logging system that needs to keep track of information about the files present in the system can use the lstat64 system call to retrieve information about a given file.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#issues","title":"Issues","text":"<p>The lstat64 system call is vulnerable to TOCTOU (Time of check, time of use) race condition, where the state of the file can change between the moment it was checked and the moment the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#related-events","title":"Related Events","text":"<ul> <li>stat64</li> <li>fstatat64</li> <li>fstat64</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/madvise/","title":"madvise","text":""},{"location":"docs/events/builtin/syscalls/madvise/#intro","title":"Intro","text":"<p>madvise - Allows potentially optimization advice about the memory in the specified address range.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#description","title":"Description","text":"<p>The madvise() system call provides advice about the use of memory addresses in the specified range. This range is defined by the starting address pointer addr and length. The advice is specified by the advice argument in the form of a value defined in <code>&lt;sys/mman.h&gt;</code>. Valid values of advice are MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED, MADV_DONTNEED, MADV_REMOVE, or MADV_HUGEPAGE.</p> <p>This call will not generate any errors if the advice is not honored, but it can be used as a hint for performance optimization. For example, MADV_WILLNEED can be used to inform the kernel that an application intends to access the memory addresses in the range and that the kernel should not only immediately load the page from swap into memory but it should keep it in memory even if memory pressure increases in order to avoid having to re-fetch the page from swap.</p> <p>It is also important to note that the kernel is not obligated to honor the advice, as the kernel can choose to ignore the advice if it needs to free up memory or if the system loading is too high.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Pointer to the starting address of the range.</li> <li><code>length</code>:<code>size_t</code>[U] - Length of the range in bytes.</li> <li><code>advice</code>:<code>int</code>[U] - Integer representing an advice on how to handle the memory in the specified address range, defined in <code>&lt;sys/mman.h&gt;</code> as MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED, MADV_DONTNEED, MADV_REMOVE, or MADV_HUGEPAGE.</li> </ul>"},{"location":"docs/events/builtin/syscalls/madvise/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/madvise/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/madvise/#sys_madvise","title":"sys_madvise","text":""},{"location":"docs/events/builtin/syscalls/madvise/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/madvise/#purpose","title":"Purpose","text":"<p>To monitor the execution of madvise syscall, analyze arguments and detect usage.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#example-use-case","title":"Example Use Case","text":"<p>A complex application uses madvise to tell the kernel that it will be accessing a certain address range with hot data, which helps the kernel know that it should not be swapped out until the application no longer needs it.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#issues","title":"Issues","text":"<p>madvise is prone to TOCTOU vulnerability, in which the behavior of the call may differ from the expecting behavior since the memory state can change between the time it is checked and the time it is used.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#related-events","title":"Related Events","text":"<ul> <li>mincore - Determine whether pages are resident in memory</li> <li>mremap - Remap an existing memory range</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mbind/","title":"mbind","text":""},{"location":"docs/events/builtin/syscalls/mbind/#intro","title":"Intro","text":"<p>mbind - binds an area of process memory to a set of CPUs in the system</p>"},{"location":"docs/events/builtin/syscalls/mbind/#description","title":"Description","text":"<p>The <code>mbind()</code> system call sets the process memory policy of a given address range to a preferred list of nodes. This call is used to control the distribution of physical memory pages to nodes on a NUMA system. The main goal is to optimize the process execution speed. The policy might be applied to a specified range of virtual address space, but the underlying physical pages might be scattered across the nodes according to the underlying memory distribution of the physical system.</p> <p>The efficacy of an mbind() call depends on various factors, like the underlying memory distribution of the physical system, the access pattern of the calling process, the hardware topology and the kernel scheduling algorithms. It is important to note that the mbind() call is advisory, meaning that the kernel might ignore the preferred placement of memory pages as long as it provides reasonable performance for the given workload.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The main disadvantage of using the mbind() call is that it might not provide the best possible results. To ensure optimal results, the kernel might need to be tuned for the particular task. Additionally, calls to mbind() that involve moving large amounts of memory might be expensive, as they involve page table updates, page potentially being read out of memory and distributed across nodes, and possibly need to be avoided in production scenarios.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - the starting address of the memory range that should be affected by the policy.</li> <li><code>len</code>:<code>unsigned long</code>[K] - the length in bytes of the memory range that should be affected.</li> <li><code>mode</code>:<code>int</code>[K] - the memory policy that should be applied, as specified by the given constants.</li> <li><code>nodemask</code>:<code>const unsigned long*</code>[K] - a list of preferred nodes for the process memory pages.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - the highest node number in the system that the nodemask applies to.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that might modify the default behavior of mbind(), such as MPOL_MF_STRICT, MPOL_MF_MOVE, MPOL_MF_MOVE_ALL or MPOL_MF_INTERNAL.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mbind/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mbind/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mbind/#mbind_1","title":"mbind","text":""},{"location":"docs/events/builtin/syscalls/mbind/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mbind/#purpose","title":"Purpose","text":"<p>To collect information about process memory policy.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#example-use-case","title":"Example Use Case","text":"<p>When a developer needs to profile an application across nodes to determine which nodes provide the best performance. </p>"},{"location":"docs/events/builtin/syscalls/mbind/#issues","title":"Issues","text":"<p>The mbind() system call is advisory, meaning the kernel might ignore the preferred placement of memory pages as long as it provides reasonable performance for the given workload.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#related-events","title":"Related Events","text":"<p>get_mempolicy, set_mempolicy, move_pages.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/","title":"membarrier","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#intro","title":"Intro","text":"<p>membarrier - executes a memory barrier on a set of threads.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#description","title":"Description","text":"<p>The membarrier() system call is used to execute a memory barrier inside live application threads. Memory barriers ensure that the read and write operations issued before a barrier operation are visible to all other threads before any of the operations issued after the barrier finish their execution. This enables synchronization between threads in an application without the need for explicit locks.</p> <p>Administrators can use this system call to control the order of writes to shared memory areas between different threads, as well as to make sure that all writes memory operations performed before the syscall will take effect before any further operations are executed.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - specifies the type of barrier to execute. Possible values are: MEMBARRIER_CMD_SHARED (wait for the completion of all memory operations started before the call) and MEMBARRIER_CMD_PRIVATE (wait for the completion of all memory operations started by the calling thread).</li> <li><code>flags</code>:<code>int</code>[K] - a bitmask of flags to customize the behavior of the membarrier() function.</li> </ul>"},{"location":"docs/events/builtin/syscalls/membarrier/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/membarrier/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#membarrier_1","title":"membarrier","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#purpose","title":"Purpose","text":"<p>To intercept the system call before it is executed.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#example-use-case","title":"Example Use Case","text":"<p>A useful example of membarrier() would be to make sure that two threads accessing the same variable in a shared memory area coordinate their access without the need to explicitly use locks.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#issues","title":"Issues","text":"<p>It is important to note that membarrier() only guarantees an ordering between memory operations issued within the same thread, or between threads. Any operations that occur within the same thread before or after the membarrier() call are not necessarily ordered.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#related-events","title":"Related Events","text":"<p>sync_file_range(), msync(), fdatasync()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/","title":"memfd_create","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#intro","title":"Intro","text":"<p>memfd_create - create an anonymous file.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#description","title":"Description","text":"<p>The <code>memfd_create()</code> system call creates an anonymous file and returns a file descriptor that refers to it. The file behaves like a regular file and can be modified, mapped, and can also grow as required. This is typically used for in-memory storage without the need for a backing file on the filesystem, thus providing a mechanism for efficient inter-process communication and temporary storage.</p> <p>Files created using <code>memfd_create()</code> are automatically removed once the last reference to them is closed, ensuring they don't persist beyond their required lifespan.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char *</code>[U] - An optional name for the file, mainly used for debugging purposes.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags to modify the behavior. Notable flags include:<ul> <li><code>MFD_CLOEXEC</code>: Set the close-on-exec flag for the new file descriptor.</li> <li><code>MFD_ALLOW_SEALING</code>: Allow the file to be sealed, preventing further modifications.</li> </ul> </li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#sys_memfd_create","title":"sys_memfd_create","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#purpose","title":"Purpose","text":"<p>To monitor and trace when the <code>memfd_create()</code> system call is invoked, capturing details about the file's creation, its name, and any flags set.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#example-use-case","title":"Example Use Case","text":"<p>Implementing a high-performance caching mechanism where data is stored in memory but accessed through a file descriptor. This can be used in scenarios where data needs to be shared between processes or stored temporarily without the overhead of disk I/O.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#issues","title":"Issues","text":"<p>Since <code>memfd_create()</code> provides an in-memory file storage mechanism, overuse without proper monitoring could lead to excessive memory consumption. Moreover, if not appropriately managed, this could be exploited by malicious actors to create a denial-of-service condition.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#related-events","title":"Related Events","text":"<ul> <li><code>ftruncate()</code> - To resize the in-memory file.</li> <li><code>mmap()</code> - To map the file into the process's address space.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/","title":"memfd_secret","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#intro","title":"Intro","text":"<p>memfd_secret - creates an anonymous file backed by memory, with the ability to lock a portion of the file.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#description","title":"Description","text":"<p>The memfd_secret() system call creates a file descriptor that refers to an anonymous, in-memory file. It differs from memfd_create() in that it has a secret option, which allows a portion of the file to be locked in memory, preventing it from being swapped to disk. This can be useful for sensitive data, such as cryptographic key material, which should not be written to persistent storage.</p> <p>The <code>flags</code> argument determines how the file is created, and is a bitmask of permission bits. It can be used to control whether read and write operations are allowed on the file.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>: <code>unsigned int</code>[K] - bitmask of permission bits to control whether read and write operations are allowed on the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#memfd_secret_1","title":"memfd_secret","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#purpose","title":"Purpose","text":"<p>To monitor and log when the system call is called.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to create a file that is stored in memory, with the ability to lock a portion of the file. This could be used to store sensitive data, such as cryptographic keys, preventing it from being written to persistent storage.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#related-events","title":"Related Events","text":"<ul> <li>memfd_create() - creates an anonymous file backed by memory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/","title":"Migrate_pages","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#intro","title":"Intro","text":"<p>migrate_pages - Moves pages from one node set to another</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#description","title":"Description","text":"<p>Migrate_pages is a syscall that moves pages from one node set to another. It does so by taking the pages from the old_nodes nodes, moving them to the new_nodes nodes, and counting the number of pages moved successfully. The process used is specified by the pid argument.  </p> <p>Migrate_pages can be beneficial when used properly. It can move pages around a node set quickly and with minimal effort. However, this syscall can be vulnerable to TOCTOU (time-of-check to time-of-use) attacks. Furthermore, if the nodes are not setup properly, pages may not move.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[K] - The pid of the process to migrate pages from.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - The maximum number of nodes to migrate between.</li> <li><code>old_nodes</code>:<code>const unsigned long*</code>[K] - Pointer to an array of unsigned long representing the nodes that the pages to be moved away from.</li> <li><code>new_nodes</code>:<code>const unsigned long*</code>[K] - Pointer to an array of unsigned long representing the nodes that the pages to be migrated to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#sys_migrate_pages","title":"sys_migrate_pages","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#purpose","title":"Purpose","text":"<p>Tracking page movements across nodes.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#example-use-case","title":"Example Use Case","text":"<p>migrate_pages can be used when migrations need to happen quickly and resources are limited. For example, when a system needs to be partitioned in order to reserve resources for a certain process.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#issues","title":"Issues","text":"<p>migrate_pages is vulnerable to TOCTOU attacks and should be used with caution. Furthermore, as the maximum number of nodes to be migrated can be specified, migration may fail depending on how the nodes are setup.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#related-events","title":"Related Events","text":"<ul> <li>move_pages</li> <li>get_mempolicy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mincore/","title":"mincore","text":""},{"location":"docs/events/builtin/syscalls/mincore/#intro","title":"Intro","text":"<p>mincore - Read the memory mapping of a given address.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#description","title":"Description","text":"<p>mincore is a Linux system call that retrieves the page-level memory usage of a specified range of virtual addresses. The system call takes 3 arguments; the virtual address at which to start, the length of the mapping to query, and an array of bytes to write the retrieved data to. The system returns a vector of bytes whose bits indicate the usage of pages in the specified address range. </p> <p>There are some noteworthy edge cases and drawbacks that may come into effect for this system call. It is not designed for large ranges of virtual address, and thus can quickly become slow if affected. Also, the information retrieved may not be up to date when polled, meaning that it may not accurately reflect the usage of the specified virtual address range.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void*</code>[U] - A pointer to the starting virtual address of the memory region to query.</li> <li><code>length</code>: <code>size_t</code>[U] - The length of the memory region to query.</li> <li><code>vec</code>: <code>unsigned char*</code>[U] - A pointer to an array of bytes that mincore will write the results to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mincore/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mincore/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mincore/#sys_mincore","title":"sys_mincore","text":""},{"location":"docs/events/builtin/syscalls/mincore/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mincore/#purpose","title":"Purpose","text":"<p>To trace and monitor memory usage.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#example-use-case","title":"Example Use Case","text":"<p>mincore could be used to detect page faults in areas of memory the program is subscribed to. This can be used to help determin specific areas of memory which are actively in-use.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#issues","title":"Issues","text":"<p>mincore is not designed to determine memory access patterns, as this system call is not able to capture the accessed pages once they have been accessed.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#related-events","title":"Related Events","text":"<p>The mincore system call can be used effectively in conjunction with the mprotect and mlock system calls. Mprotect modifies the protection access of a memory region, while mlock locks a memory region in RAM, while mincore can help determine usage of the regions.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/","title":"mkdir","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#intro","title":"Intro","text":"<p>mkdir - Creates a directory named pathname.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#description","title":"Description","text":"<p>The mkdir() system call creates a directory named pathname.  It is eight  bits of the Mode that contain the Unix permission bits for the newly created directory. The permissions of new directories are as follows:</p> <p>Usr/Grp/Oth: rwxr-xr-x</p> <p>The newly created directory inherits its group identity from the parent directory. This system call follows symbolic links and fails if the  directory  already  exists  or  if  a  directory  component  in pathname does  not  exist or is a dangling  symbolic link. On success, zero is returned.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K,U] - Pointer to a string containing the name of the directory to be created.</li> <li><code>mode</code>:<code>mode_t</code>[K,U] - A bit pattern that serves as the file permission bits for the new directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#sys_mkdir","title":"sys_mkdir","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#purpose","title":"Purpose","text":"<p>Monitor and observe when mkdir system calls are invoked with specific argument values, or to monitor and observe mkdir system calls in general.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#example-use-case","title":"Example Use Case","text":"<p>The mkdir system call could be used to monitor new directory creation. This can be useful to detect malicious activities such as directory traversal or privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#issues","title":"Issues","text":"<p>No known issues</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#related-events","title":"Related Events","text":"<ul> <li>open </li> <li>access</li> <li>stat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/","title":"mkdirat","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#intro","title":"Intro","text":"<p>mkdirat - create a directory with a given path relative to the directory referenced by the file descriptor</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#description","title":"Description","text":"<p>The mkdirat() system call creates a new directory with the given name relative to the directory referenced by the file descriptor. The argument mode specifies the permissions to use. The newly created directory will be an empty directory and will be owned by the effective user ID of the process.</p> <p>The call is useful when you want to restrict the creation of new directories to a certain directory, due to security matters. When dirfd is AT_FDCWD, the current working directory is used as the starting point. Edge-cases to consider are when the pathname argument is not absolute, when the pathname is longer than PATH_MAX, when the dirfd argument is invalid, or when the mode argument is invalid.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - open directory file descriptor used as the relative path for the new directory.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname of the created directory.</li> <li><code>mode</code>:<code>mode_t</code>[K] - File permission bits for the created directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdirat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdirat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#do_mkdirat","title":"do_mkdirat","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#purpose","title":"Purpose","text":"<p>To track when the directory is created </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#example-use-case","title":"Example Use Case","text":"<p>mkdirat() can be useful when tracking the creation of directories, for security reasons. For example, it can be used to detect malicious activity where a process is creating multiple malicious directories in quick succession.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#issues","title":"Issues","text":"<p>mkdirat() may fail due to missing or insufficient permissions, or due to a long pathname argument. </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>access()</li> <li>chmod()</li> <li>rmdir()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mknod/","title":"mknod","text":""},{"location":"docs/events/builtin/syscalls/mknod/#intro","title":"Intro","text":"<p>mknod - creates a filesystem node (file, device special file or named pipe)</p>"},{"location":"docs/events/builtin/syscalls/mknod/#description","title":"Description","text":"<p>The <code>mknod</code> system call is used to create a filesystem node (file, device special file or named pipe) named by the pathname referred to by <code>pathname</code>. It has associated permissions determined by <code>mode</code> (modified by the process\u2019s umask) and is given the user ID and group ID specified by <code>dev</code>. On success (returning 0), the inode creation time is set to the current time and the last data modification and last file status change times are set to the current time.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname refers the name of the new file or directory.</li> <li><code>mode</code>:<code>mode_t</code>[KU] - expresses the mode of the new file in both symbolic and absolute ways. The symbolic mode can use the alphabetical characters \u201cr\u201d, \u201cw\u201d, and \u201cx\u201d.</li> <li><code>dev</code>:<code>dev_t</code>[KU] - is an unsigned integer specifying the file or directory user ID and group ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mknod/#do_mknod","title":"do_mknod","text":""},{"location":"docs/events/builtin/syscalls/mknod/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/mknod/#purpose","title":"Purpose","text":"<p>To track an event when a program calls mknod.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#example-use-case","title":"Example Use Case","text":"<p>An example use-case when mknod can be used is in an application making use of named pipes. The mknod system call can be used to create a named pipe whose pathname is provided by <code>pathname</code> and whose permissions are given by <code>mode</code>.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#issues","title":"Issues","text":"<p>If the application creating the node points to an existing one, it will fail to be created and will return an EEXIST error.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#related-events","title":"Related Events","text":"<p><code>stat</code>, <code>fstat</code>, <code>lstat</code> - to obtain information about a file or directory specified by pathname. <code>unlink</code> - to remove the specific node.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/","title":"mknodat","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#intro","title":"Intro","text":"<p>mknodat - create a special or ordinary file relative to open directory</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#description","title":"Description","text":"<p>The mknodat() system call operates in exactly the same way as mknod(), except for the differences described in this manual page.</p> <p>The mknodat() system call creats a special or ordinary file (named by pathname) with permission defined by mode. It is identical to the mknod() system call. The only difference is that the pathname relative to a directory file descriptor, rather than to the working directory.</p> <p>The user ID and group ID of the created file are set to the effective user ID and group ID of the process, respectively.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - Directory file descriptor.</li> <li><code>pathname</code>:<code>const char*</code>[K] - Pathname of the created file.</li> <li><code>mode</code>:<code>mode_t</code>[K] - File type and access mode of the created file.</li> <li><code>dev</code>:<code>dev_t</code>[K, TOCTOU] - Pointer to a dev_t structure that is used to store the major or minor device numbers (only for character or block special files).</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknodat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknodat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#sys_mknodat","title":"sys_mknodat","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#type","title":"Type","text":"<p>kprobes + tracepoints</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#purpose","title":"Purpose","text":"<p>To record when mknodat() is called, what parameters were passed and which return value was returned.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#example-use-case","title":"Example Use Case","text":"<p>The mknodat() system call can be used by a privileged process to create a directory and file located inside a user-defined directory. This can be used to deploy basic IPC (inter-process communication) infrastructure between processes that run under the same user ID.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>fstatat()</li> <li>fchownat()</li> <li>mkdirat()</li> <li>readdirat()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlock/","title":"mlock","text":""},{"location":"docs/events/builtin/syscalls/mlock/#intro","title":"Intro","text":"<p>mlock - lock the given range of memory so it won't be swapped to disk.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#description","title":"Description","text":"<p>The <code>mlock</code> syscall locks the given range of memory into RAM so it won't be swapped to disk. This is useful in scenarios where you need to access or modify data stored in memory, but don't want it to get overwritten or written to disk by the kernel's virtual memory system. While this syscall ensures that the data will stay in RAM, it can still be accessed by other processes in the system, so caution should be used when using this syscall. One common misuse is allocating too much memory that cannot possibly fit in RAM, resulting in the system becoming unresponsive.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[K] - starting address of the range of pages to lock.</li> <li><code>len</code>:<code>size_t</code>[K] - length of the range of pages to lock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlock/#sys_mlock","title":"sys_mlock","text":""},{"location":"docs/events/builtin/syscalls/mlock/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mlock/#purpose","title":"Purpose","text":"<p>Monitoring the parameters of the mlock syscall and its return value.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event could be monitoring suspicous memory locking activity. This could facilitate the detection of malware that attempts to protect its data from scrutiny by using mlock.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#issues","title":"Issues","text":"<p>This syscall requires root level privileges, so it can potentially be used by malicious actors to lock critical system memory that may cause the system to become unresponsive.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#related-events","title":"Related Events","text":"<ul> <li>mlockall - lock all the process's virtual pages into RAM.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/","title":"mlock2","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#intro","title":"Intro","text":"<p>mlock2 - Lock part of the calling process's memory into RAM.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#description","title":"Description","text":"<p>The mlock2 system call is used to lock a region of memory in a calling process' virtual  address space into RAM. This prevents the kernel from using the memory for other system purposes. The memory region's address and size are specified, as well as optional flags  that modify the behavior of the call. mlock2 allows for a more fine-grained control of  the memory lockout than mlock, including the ability to specify individual page frames. This system call is used to guarantee that a region is not swapped out, preventing  latencies in execution due to paging. It is often used for sensitive operations like  encryption and hashing, however due to the resource intensive nature of the system call  it should be used sparingly.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[KU] - address of the starting memory region that should be locked.</li> <li><code>len</code>:<code>size_t</code>[K] - length of the memory region to be locked, in bytes. Must be a multiple of PAGE_SIZE.</li> <li><code>flags</code>:<code>int</code>[K] - optional flags that modify the behavior of the call, either MLOCK_ or MLOCK2_ flags can be specified.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#do_mlock2","title":"do_mlock2","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#type","title":"Type","text":"<p>Kprobes + Uprobes.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#purpose","title":"Purpose","text":"<p>Used to monitor when a process is trying to lock a region of memory.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#example-use-case","title":"Example Use case","text":"<p>mlock2 can be used in applications that need to prevent data from being swapped  out of memory. This can be used when working with encryption algorithms such as AES  that need to keep the key in a secure region of memory.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#issues","title":"Issues","text":"<p>mlock2 can pose an issue in resource intensive applications, as it requires memory to  be locked in RAM, reducing the amount of memory available for other tasks.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#related-events","title":"Related Events","text":"<ul> <li>mmap2</li> <li>munmap</li> <li>mlockall</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlockall/","title":"mlockall","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#intro","title":"Intro","text":"<p>mlockall - lock all mapped pages into physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#description","title":"Description","text":"<p>mlockall allows the calling process to lock all its pages into physical memory. This means that the pages can not be swapped out, will not cause page faults, and will never be moved by any operation. The effect of this can, in some cases, offer better performance. </p> <p>There are two flags which can be used with mlockall: </p> <ul> <li>MCL_CURRENT: Lock only currently mapped pages.</li> <li>MCL_FUTURE: Lock all pages which are mapped in the future.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - flags for mlockall operation. An ORed combination of values from mlockall(2) can be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#mlockall_1","title":"mlockall","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mlockall/#purpose","title":"Purpose","text":"<p>To monitor processes which make use of mlockall and their interaction with the physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#example-use-case","title":"Example Use Case","text":"<p>On a real-time embedded system, processes may have a large total number of pages mapped. Under heavy workload, the pages may be swapped out during times of heavy system load. By using mlockall, the real-time processes may be preserved in physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#issues","title":"Issues","text":"<p>The main drawbacks of mlockall is its high resource usage. When used, the amount of RAM available to the system will be limited. As a result, memory pressure can be an issue when mlockall is used on a system with multiple processes.</p>"},{"location":"docs/events/builtin/syscalls/mlockall/#related-events","title":"Related Events","text":"<ul> <li>mlock(2)</li> <li>munlockall(2)</li> <li>mlock2(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mmap/","title":"mmap","text":""},{"location":"docs/events/builtin/syscalls/mmap/#intro","title":"Intro","text":"<p>mmap - map a region of memory in a process address space</p>"},{"location":"docs/events/builtin/syscalls/mmap/#description","title":"Description","text":"<p>The mmap() system call maps a region of memory in a process address space. It can be used to share a region of memory between processes, or to map a region of a file or device into a process's address space. The <code>flags</code> parameter is a bitwise combination of various options that control the mapping of a region of memory. The <code>prot</code> parameter is the protection level of the region. The <code>fd</code> parameter, if set, specifies the file descriptor of a regular file or device that is mapped into the calling process address space. The <code>off</code> parameter specifies the offset from the start of the file, if file-associated memory is being mapped.</p> <p>The <code>mmap()</code> system call is useful for allocating a fixed-size region of memory for use in a larger system. It can be used for applications such as kernel code, device drivers, shared libraries, or for any other region of memory that needs to be allocated.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - a pointer to the memory location where the mapping will begin. If this value is NULL, page-aligned memory will be allocated and used.</li> <li><code>length</code>:<code>size_t</code>[K] - the size of the mapping in bytes.</li> <li><code>prot</code>:<code>int</code>[K] - the protection flags for the mapping; a combination of <code>PROT_READ</code>, <code>PROT_WRITE</code> and <code>PROT_EXEC</code>.</li> <li><code>flags</code>:<code>int</code>[K] - the flags for the mapping; a combination of <code>MAP_SHARED</code> or <code>MAP_PRIVATE</code>, and other flags to define the access.</li> <li><code>fd</code>:<code>int</code>[K] - the file descriptor of a regular file or device that is mapped into the calling process address space. If this parameter is -1, no file is mapped. </li> <li><code>off</code>:<code>off_t</code>[K] - the offset from the start of the file, if file-associated memory is being mapped.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mmap/#do_mmap_pgoff","title":"do_mmap_pgoff","text":""},{"location":"docs/events/builtin/syscalls/mmap/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap/#purpose","title":"Purpose","text":"<p>To monitor mmap system calls from user space.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#sys_mmap","title":"sys_mmap","text":""},{"location":"docs/events/builtin/syscalls/mmap/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap/#purpose_1","title":"Purpose","text":"<p>To monitor the return value of mmap system calls from the kernel.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#example-use-case","title":"Example Use Case","text":"<p>A typical use of the <code>mmap()</code> system call is to map a file into memory and then access it directly. This allows applications to read and write the file, without having to use the slow I/O operations, as the data is in memory. This is especially useful for applications that need to read a large file quickly, but don't need to write it.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#issues","title":"Issues","text":"<p>To use <code>mmap()</code>, the process must have sufficient memory available to map the file. If not, the <code>mmap()</code> call will return a memory allocation error and the file will not be mapped.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#related-events","title":"Related Events","text":"<ul> <li><code>munmap()</code> - to unmap previously mapped memory regions.</li> <li><code>mremap()</code> - to remap memory regions.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/","title":"mmap2","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#intro","title":"Intro","text":"<p>mmap2 - establish a mapping to a memory region in the virtual address space of a process</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#description","title":"Description","text":"<p>The mmap2() system call creates a new mapping in the virtual address space of the calling process. The region is populated using the file descriptor passed in via the fd argument. These mappings may or may not be backed by physical memory or it could be mapped to the device I/O (found mostly in the kernel Space). This system call is mainly used to map a certain piece of memory to an I/O device or device buffers.</p> <p>The addr argument allows the caller to specify a preferred starting address for the mapping, although this is not honoured in all cases. The length argument specifies the length of the mapping. The prot argument determines the protection of the mapping. It may contain any bitwise combination of the following flags:</p> <ul> <li>PROT_NONE: no access to the mapped region</li> <li>PROT_READ: reads from the mapped region allowed</li> <li>PROT_WRITE: writes to the mapped region allowed</li> <li>PROT_EXEC: execution from the mapped region allowed</li> </ul> <p>The flags argument allows the caller to specify the type of mapping. It may contain any bitwise combination of:</p> <ul> <li>MAP_SHARED: The mapping is shared, thus changes in its contents reflect to all processes that have access to it.</li> <li>MAP_PRIVATE: The mapping is private to the calling process.</li> <li>MAP_HUGETLB: Allocate memory in units of huge pages.</li> </ul> <p>The fd argument is used to specify the file descriptor to be used for the mapping. If it is set to -1, a anonymous mapping is created.</p> <p>If the flags argument contains MAP_FIXED, the mapping will be placed at the address specified in the addr argument. Otherwise it is unspecified, although the kernel attempts to locate the mapping near the address given.</p> <p>The pgoffset argument is used to specify a file-offset when mapping from a file.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>unsigned long</code>[U] - the address of the mapped memory.</li> <li><code>length</code>:<code>unsigned long</code>[U] - the length of the mapped memory. </li> <li><code>prot</code>:<code>unsigned long</code>[U] - the protection of the memory. </li> <li><code>flags</code>:<code>unsigned long</code>[U] - flags that determine how the mapping is established. </li> <li><code>fd</code>:<code>unsigned long</code>[K] - file descriptor used to map the memory from. </li> <li><code>pgoffset</code>:<code>unsigned long</code>[K] - the file-offset used when mapping from a file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#do_mmap2","title":"do_mmap2","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#purpose","title":"Purpose","text":"<p>To monitor memory mapping requests from user space.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#example-use-case","title":"Example Use Case","text":"<p>The mmap2 system call provides a way to map a certain piece of memory to an I/O device or device buffers. This could be useful when engineers need to access a device's memory without having to access memory directly in the kernel address space.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#issues","title":"Issues","text":"<p>mmap2 can fail with errors -EINVAL, -ENOMEM, and -EACCES if the given parameters do not meet the kernel requirements.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#related-events","title":"Related Events","text":"<p>mmap, unmmap, msync</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/","title":"modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#intro","title":"Intro","text":"<p>modify_ldt - Changes the definition of local descriptor table entries.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#description","title":"Description","text":"<p>The modify_ldt() system call provides a way to read and modify the local descriptor table (LDT) entries as well as to determine the current size of the table. Upon success, it returns the amount of memory actually read or written. Upon failure, it returns -1 and sets errno to indicate the error. </p> <p>The flags argument is a bit mask composed of the OR'ed value of constants defined in . This provides a way to tell the kernel which operation should be performed and what data should be included. <p>Using this system call allows the programmer to inspect and modify the LDT entries from user space. This can be useful for debugging, sandboxing, creating segmentation modules with user-space applications, or for any other reason.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#arguments","title":"Arguments","text":"<ul> <li><code>func</code>:<code>int</code>[K] - Specifies the operation to be performed. See   for available constants. <li><code>ptr</code>:<code>void*</code>[K] - Pointer to an ldt_entry struct, which specifies what the LDT entry should be set to.</li> <li><code>bytecount</code>:<code>unsigned long</code>[K] - Amount of memory to read/write from/to the LDT entry.</li>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#sys_modify_ldt","title":"sys_modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#purpose","title":"Purpose","text":"<p>Hooked to inspect and modify the LDT entries from user space.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#example-use-case","title":"Example Use Case","text":"<p>Create a segmentation module with user-space applications.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#related-events","title":"Related Events","text":"<ul> <li>modify_ldt_entry </li> <li>modify_ldt64</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mount/","title":"mount","text":""},{"location":"docs/events/builtin/syscalls/mount/#intro","title":"Intro","text":"<p>mount - Call the mount() system call to mount a filesystem </p>"},{"location":"docs/events/builtin/syscalls/mount/#description","title":"Description","text":"<p>The mount() system call serves to attach the filesystem specified by source (which is often a device name, but can also be a directory name or other), to the directory specified by the argument target. The filesystemtype argument specifies the filesystem type. Mount flags that control the behavior of the mount command are specified by mountflags, and data about the mount is determined by data.</p> <p>The mount() system call is used by system administrators and users to control the mounting of filesystems. It allows users to modify the filesystem tree without needing root privileges, for example, to mount a CDROM. It can be used to mount filesystems from one machine to another (e.g., remote NFS shares), in addition to filesystems on the local system.</p> <p>When mounting a filesystem, all the data contained within is accessible. It is important, therefore, to use the appropriate mount flags to ensure that the right levels of security and access are applied to a filesystem.</p>"},{"location":"docs/events/builtin/syscalls/mount/#arguments","title":"Arguments","text":"<ul> <li><code>source</code>:<code>const char*</code>[K] - The pathname or device-name of the filesystem that is to be mounted.</li> <li><code>target</code>:<code>const char*</code>[K] - The directory where the filesystem is to be mounted.</li> <li><code>filesystemtype</code>:<code>const char*</code>[K] - The name of the filesystem type, such as \"ext4\", \"btrfs\" etc. </li> <li><code>mountflags</code>:<code>unsigned long</code>[K] - The mount flags to control the behavior of the mount command. </li> <li><code>data</code>:<code>const void*</code>[K] - Data about the mount, such as the desired mount options and device type.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mount/#do_mount","title":"do_mount()","text":""},{"location":"docs/events/builtin/syscalls/mount/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mount/#purpose","title":"Purpose","text":"<p>Hooking into the do_mount() function gives us deeper insight into the mount() system call, allowing us to track and inspect the lower-level kernel-space operations that take place during mount.</p>"},{"location":"docs/events/builtin/syscalls/mount/#do_add_mount","title":"do_add_mount()","text":""},{"location":"docs/events/builtin/syscalls/mount/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mount/#purpose_1","title":"Purpose","text":"<p>Hooking into the do_add_mount() function allows us to monitor the data added to the VFS mount table as a result of the mount() system call.</p>"},{"location":"docs/events/builtin/syscalls/mount/#example-use-case","title":"Example Use Case","text":"<p>Mounting a disk partition or remote file system on a running system requires the mount() system call. It can also be used to mount a disk partition or a remote file system while the system is booting. This can be setup in the fstab or manually in the init scripts that run at boot.</p>"},{"location":"docs/events/builtin/syscalls/mount/#issues","title":"Issues","text":"<p>The mount() system call is vulnerable to a time-of-check-time-of-use race condition, which can lead to security vulnerabilities. </p>"},{"location":"docs/events/builtin/syscalls/mount/#related-events","title":"Related Events","text":"<ul> <li>umount() - syscall to unmount a filesystem</li> <li>fsconfig() - syscall for querying and configuring a filesystem</li> <li>chroot() - syscall for changing the root directory of the current process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/","title":"mount_setattr","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#intro","title":"Intro","text":"<p>mount_setattr - set per-mount attributes on a mount</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#description","title":"Description","text":"<p>The system call mount_setattr() allows an application to set mount-level attributes on the specified mount. Currently, only two flags are defined: <code>MOUNT_ATTR_NOEXEC</code>, which will prevent mount from executing any code, and <code>MOUNT_ATTR_NOSUID</code>, which will prevent mount from allowing setuid and setgid execution for any files.</p> <p>The <code>dfd</code> and <code>path</code> parameters specify a mount to modify using a file descriptor or file path respectively. The <code>flags</code> parameter is an unsigned int describing the flags to set (or reset) on the mount. Lastly, the <code>uattr</code> parameter is either NULL or points to a struct mount_attr which holds the mount-level attributes to set.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>int</code>[K] - The mount's file descriptor. </li> <li><code>path</code>:<code>char*</code>[K] - The mount\u2019s path.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - An unsigned int describing the flags to set (or reset) on the mount.</li> <li><code>uattr</code>:<code>struct mount_attr*</code>[U, TOCTOU, OPT] - If this argument is not NULL, and it is pointing to a valid struct mount_attr, then it will set the mount-level attributes, otherwise it will reset the mount-level attributes.  </li> <li><code>usize</code>:<code>size_t</code>[K, OPT] - The size of the <code>uattr</code> buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#sys_mount","title":"sys_mount","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#purpose","title":"Purpose","text":"<p>To monitor mount_setattr syscall activity.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#example-use-case","title":"Example Use Case","text":"<p>The mount_setattr system call can be used to set mount-level attributes, such as <code>MOUNT_ATTR_NOEXEC</code> to prevent execution of code, or <code>MOUNT_ATTR_NOSUID</code> to prevent setuid and setgid execution of any files located on the mount.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#issues","title":"Issues","text":"<p>The <code>uattr</code> parameter is vulnerable to time of check/time of use (TOCTOU) race conditions since the credentials of the calling process are checked when the call is made, but not when the mount_setattr system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#related-events","title":"Related Events","text":"<p>The mount_isattr() system call can be used to fetch the mount-level attributes of a mount.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/","title":"move_mount","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#intro","title":"Intro","text":"<p>move_mount - reposition an existing mount in the file hierarchy.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#description","title":"Description","text":"<p>The <code>move_mount()</code> system call is designed to allow the repositioning of an existing mount point to a new location within the file system hierarchy.</p> <p>This system call is a part of the revamped mount API introduced in Linux 5.2 and provides a more flexible and secure way to move mounts, particularly beneficial within user namespaces.</p> <p>Unlike the traditional <code>mount()</code> system call with the <code>MS_MOVE</code> flag, <code>move_mount()</code> offers a more granular approach to mount operations.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#arguments","title":"Arguments","text":"<ul> <li><code>from_dfd</code>:<code>int</code>[K] - File descriptor referring to the directory containing the mount point to be moved.</li> <li><code>from_pathname</code>:<code>const char *</code>[U] - Pathname relative to <code>from_dfd</code> indicating the mount to move.</li> <li><code>to_dfd</code>:<code>int</code>[K] - File descriptor referring to the directory where the mount point should be moved to.</li> <li><code>to_pathname</code>:<code>const char *</code>[U] - Pathname relative to <code>to_dfd</code> indicating the target location for the mount.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags to modify the behavior. As of now, the flag value is typically set to 0.</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_mount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_mount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#sys_move_mount","title":"sys_move_mount","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>move_mount()</code> system call is invoked, capturing details about the source and target mount locations.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#example-use-case","title":"Example Use Case","text":"<p>Enhancing containerization tools or sandboxing solutions by reorganizing the mount namespace for better isolation or to achieve specific filesystem layouts without resorting to the older, less granular <code>mount()</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#issues","title":"Issues","text":"<p>Misuse of the <code>move_mount()</code> system call can lead to unintended changes in the file hierarchy, potentially affecting system stability or introducing security vulnerabilities. Proper validation and checks are essential when utilizing this syscall.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#related-events","title":"Related Events","text":"<ul> <li><code>open_tree()</code> - Open a reference to a mountpoint for use with the new mount API operations.</li> <li><code>mount_setattr()</code> - Adjust attributes of a mount.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/","title":"move_pages","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#intro","title":"Intro","text":"<p>move_pages - Migrate process pages between node</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#description","title":"Description","text":"<p>The move_pages() system call moves pages from one NUMA node to another on behalf  of the children of a process. It supports a subset of normal memory mappings,  possibly shared between multiple processes - specifically just private anonymous  mappings and shared mappings created with the mmap(2) MAP_SHARED and MAP_SHARED_VALIDATE flags.</p> <p>Although the system call may be used on any process, the special semantics of  the system call are only applicable to processes whose page tables are managed  by a PowerPC hardware page table walker, such as POWER7 and later chips.</p> <p>This system call allows processes and kernels to organize their working set  into specific NUMA nodes, by placing pages and nodes. This can be used to speed  up memory accesses and also to allow the user or administrator to move process  pages into near-memory storage (such as the embedded DRAM available on some  PowerPC machines) in order to save energy.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[K] - The PID of the process whose pages should be moved.</li> <li><code>count</code>:<code>unsigned long</code>[U+K] - The number of pages to move. </li> <li><code>pages</code>:<code>const void**</code>[U] - The addresses of the pages to be moved.</li> <li><code>nodes</code>:<code>const int*</code>[K] - The array of nodes to which the pages should be moved.</li> <li><code>status</code>:<code>int*</code>[U] - The array that will contain the result for each page (0 for success, -EFAULT for failure).</li> <li><code>flags</code>:<code>int</code>[K] - Flags to specify behaviour (0 for regular mode, MPOL_MF_MOVE_ALL to exchange pages if the source or destination node is already full).</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#sys_move_pages","title":"sys_move_pages","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#type","title":"Type","text":"<p>Kprobe + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#purpose","title":"Purpose","text":"<p>To monitor the execution of the move_pages system call and its return value.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#example-use-case","title":"Example Use Case","text":"<p>If an application running on a multi-socketed system depends heavily on the  transparency of the NUMA architecture in order to get good performance, then this system call can be used to move pages around in order to optimize its memory accesses. </p>"},{"location":"docs/events/builtin/syscalls/move_pages/#issues","title":"Issues","text":"<p>This system call is limited to pages that are anonymous private mappings or shared mappings that were created with the mmap(2) MAP_SHARED and MAP_SHARED_VALIDATE flags, making it incompatible with many memory sharing strategies.</p> <p>Also, it is not supported on Power7 and later chips, which could lead to unexpected results when running on such systems.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#related-events","title":"Related Events","text":"<ul> <li>munmap(2) - System call used to unmap pages from memory</li> <li>mmap(2) - System call used to map files or devices into memory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mprotect/","title":"mprotect","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#intro","title":"Intro","text":"<p>mprotect - Change protection on a region of memory</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#description","title":"Description","text":"<p>The mprotect() system call is used to change the protection of a region of memory. This system call is useful for preventing malicious code from writing to a region of memory. It can also be used to manually allocate and/or deallocate memory for an application.</p> <p>The mprotect() system call modifies the page protection bits of any valid mapped pages in the address range starting at addr and continuing for len bytes. If a page is not valid or not mapped, or if it is locked, then it will not be modified by mprotect(). If a page is in read-only mode, then it cannot be set writable by mprotect(), as long as the page is still mapped.</p> <p>The prot argument must include either PROT_READ or PROT_WRITE or both, as well as any of the other flags (they are all cumulative).</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] -  Start address</li> <li><code>len</code>:<code>size_t</code>[K] - Length in bytes</li> <li><code>prot</code>:<code>int</code>[K] - Protection flags (PROT_READ, PROT_WRITE, PROT_EXEC, PROT_SEM and PROT_NONE are provided)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mprotect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#sys_mprotect","title":"sys_mprotect","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#purpose","title":"Purpose","text":"<p>Monitor access to memory and enforce memory protections</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#example-use-case","title":"Example Use Case","text":"<p>The mprotect() syscall can be used to enforce memory protections on a region of memory. This can be useful for detecting and preventing malicious code from writing to a region of memory. It can also be used to manually allocate and/or deallocate memory for an application.</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#issues","title":"Issues","text":"<p>Currently, mprotect() does not check permissions when PROT_READ or PROT_EXEC is specified. This can lead to security vulnerabilities if an attacker is able to control a pointer that is passed to mprotect().</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#related-events","title":"Related Events","text":"<ul> <li>mmap - Map pages of memory</li> <li>munmap - Unmap pages of memory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mpx/","title":"mpx","text":""},{"location":"docs/events/builtin/syscalls/mpx/#intro","title":"Intro","text":"<p>mpx - manage memory protection keys</p>"},{"location":"docs/events/builtin/syscalls/mpx/#description","title":"Description","text":"<p>The mpx system call is used to create, enable, disable, or get the status of a memory protection key (MPX) on a system. The MPX system call requires a key set register and a bound register, both of which are only available on x86-64 CPUs with the MPX feature enabled. Using the key set register, a process can set and change the memory area to be protected using the MPX key. The bound register specifies boundaries to the portion of memory applicable to the key.</p> <p>MPX is useful for distinguishing between memory areas that must be kept secure and those that do not need to be protected from malicious or erroneous accesses. For example, a process may want to mark a memory region as \"private\" so that it can't be accessed by any other process. This can be done using the MPX system call, enabling the process to protect itself from malicious or erroneous accesses within that region.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void *</code>[U,TOCTOU] - pointer to an address space area.</li> <li><code>len</code>:<code>int</code>[U,TOCTOU] - length of the address space area.</li> <li><code>key</code>:<code>unsigned int</code>[U] - MPX key used to protect the given area.</li> <li><code>op</code>:<code>int</code>[U] - Operation to perform (e.g. set or get).</li> </ul>"},{"location":"docs/events/builtin/syscalls/mpx/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mpx/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mpx/#sys_mpx","title":"sys_mpx","text":""},{"location":"docs/events/builtin/syscalls/mpx/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mpx/#purpose","title":"Purpose","text":"<p>Monitor the process accesses to keys and its associated protections.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#example-use-case","title":"Example Use Case","text":"<p>A security-based application that monitors memory access requests, and uses MPX to protect a specific memory region. The application can use the hooks to be notified when a process modifies keys or attempts to access its corresponding protection regions. The application can then take the necessary actions to protect the system.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#issues","title":"Issues","text":"<p>The main issue with mpx is that it only works with x86-64 Architecture segments, which limits its ability to provide protection against malicious or erroneous accesses on older systems.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#related-events","title":"Related Events","text":"<ul> <li>msr: Used to access and modify model-specific registers.</li> <li>set_thread_area: Used to set up and modify thread local storage areas.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/","title":"mq_getsetattr","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#intro","title":"Intro","text":"<p>mq_getsetattr - sets and gets message queue attributes.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#description","title":"Description","text":"<p>mq_getsetattr is responsible for setting and getting the attributes associated with a message queue.</p> <p>When setting attributes, the process must own, or have superuser permissions, the message queue referenced by the mqdes argument.</p> <p>When getting attributes, the process must have read, write, or execute permissions for the message queue referenced by the mqdes argument.</p> <p>This event provides an efficient way to get the current attributes of an existing message queue or to change certain attribute values.</p> <p>The possible attribute values that can be changed are those inside struct mq_attr (defined in /usr/include/bits/mqueue.h).</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K,U] - holds a file descriptor that refers to an open message queue.</li> <li><code>newattr</code>:<code>const struct mq_attr*</code>[K,U] - points to a struct mq_attr that sets the attributes of the message queue.</li> <li><code>oldattr</code>:<code>struct mq_attr*</code>[K,U] - points to the buffer that retrieves the current attributes of the message queue.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#sys_mq_getsetattr","title":"sys_mq_getsetattr","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#purpose","title":"Purpose","text":"<p>Hook this event so the attributes of the message queue can be monitored.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#example-use-case","title":"Example Use Case","text":"<p>The mq_getsetattr event may be useful in situations where it is important to track the current value of attributes associated with a particular message queue. For example, if an application is submitting messages to a queue and expecting responses, mq_getsetattr can be used to track the current time-out value of the queue or to see if the queue is still in a valid state.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#issues","title":"Issues","text":"<p>When hooking sys_mq_getsetattr and collecting the return value, due to the possibility of userspace-triggered events, kernel-space values may contain invalid user address data.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#related-events","title":"Related Events","text":"<ul> <li>mq_open</li> <li>mq_unlink </li> <li>mq_timedsend </li> <li>mq_timedreceive</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/","title":"mq_notify","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#intro","title":"Intro","text":"<p>mq_notify - register notification request on a message queue</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#description","title":"Description","text":"<p>The mq_notify() system call establishes or modifies a notification request on the message queue specified by the mqdes argument. If the sevp argument is not a null pointer, then the notification will be as specified in the referenced structure.</p> <p>The receiving process will be sent a SIGEV_SIGNAL signal with si_value equal to the sival_ptr member of the sigevent structure when (1) a message arrives on the empty queue specified by mqdes and (2) a message is removed from the queue and the number of messages on the queue subsequently becomes lower than the current value of the queue's notification threshold, mq_notify(). This signal will be sent to the process that registered the notification, provided that the notification request is still active by the time the message arrives or is removed from the queue.</p> <p>A process can register at most one notification request for each message queue.</p> <p>If the sevp argument is a null pointer, any previously registered notification request for the message queue specified by the mqdes argument will be canceled.</p> <p>Some of the advantages of using mq_notify() include the ability to register for notification of any incoming message, being able to specify a custom signal handler function that is called when the signal is received, and the ability to register multiple notification requests on different queues.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code> - a message queue descriptor.</li> <li><code>sevp</code>:<code>const struct sigevent*</code> - pointer to a structure that specifies the type of notification to set. If the value of this argument is NULL, the notification for the specified message queue is canceled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_notify/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_notify/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#mq_notify_entry","title":"mq_notify_entry","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#purpose","title":"Purpose","text":"<p>To trace the system call entry point.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#mq_notify_exit","title":"mq_notify_exit","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#purpose_1","title":"Purpose","text":"<p>To trace the system call exit point.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#example-use-case","title":"Example Use Case","text":"<p>mq_notify() can be used to be notified when a message is sent to a queue, or when a message is taken off a queue that was previously emptied. This is useful for applications that need to react to messages in a timely manner or are interested in knowing what messages are being sent and taken from a queue.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#issues","title":"Issues","text":"<p>Because the notification is triggered by either a message coming in or a message being taken out, this function is vulnerable to Time of Check Time of Use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#related-events","title":"Related Events","text":"<p>mq_open, mq_send, mq_receive</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/","title":"mq_open","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#intro","title":"Intro","text":"<p>mq_open - open a message queue</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#description","title":"Description","text":"<p>The <code>mq_open</code> function opens a POSIX message queue, attempting to create it if <code>O_CREAT</code> is specified in the <code>oflag</code> argument. If successful, it returns a message queue descriptor for use in later <code>mq_*</code> calls.</p> <p>The <code>name</code> argument gives the name of the message queue and <code>mode</code> is the working mode, which is related to the protection of the created message queue. The <code>oflag</code> argument is a flag argument that may be made up of one or more of the following specified in <code>&lt;fcntl.h&gt;</code>:</p> <ul> <li><code>O_RDONLY</code> - Open the message queue for reading only.</li> <li><code>O_WRONLY</code> - Open the message queue for writing only.</li> <li><code>O_RDWR</code> - Open the message queue for both reading and writing.</li> <li><code>O_CREAT</code> - Create the message queue if it does not already exist.</li> <li><code>O_EXCL</code> - When used with <code>O_CREAT</code>, if the queue already exists, the call fails.</li> </ul> <p>If the <code>O_CREAT</code> is specified in <code>oflag</code> the <code>mode</code> argument specifies the initial permissions of the newly created queue, as in <code>open(2)</code>. It is modified by the process's <code>umask</code> in the usual way. The <code>attr</code> argument pointer can be used to set the initial attributes of the queue.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[KU] - Name of the message queue to be opened. Must begin with a '/' character.</li> <li><code>oflag</code>:<code>int</code>[KU] - Flag argument used to determine how the queue should be opened.</li> <li><code>mode</code>:<code>mode_t</code>[KU] - Permission bits used when setting the queue's initial permissions.</li> <li><code>attr</code>:<code>struct mq_attr*</code>[KU] - Pointer to a structure containing the queue's initial attributes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#do_mq_open","title":"do_mq_open","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#purpose","title":"Purpose","text":"<p>To capture information about when and where the <code>mq_open</code> syscall is invoked.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#example-use-case","title":"Example Use Case","text":"<p>Using the <code>mq_open</code> event can be used to monitor the creation and access of message queues, logging any relevant information pertaining to the queue and the process that invoked it.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#issues","title":"Issues","text":"<p>The <code>mq_open</code> event occurs when the message queue is opened and does not indicate that it was successfully opened.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#related-events","title":"Related Events","text":"<ul> <li>mq_timedsend</li> <li>mq_receive</li> <li>mq_timedreceive</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/","title":"mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#intro","title":"Intro","text":"<p>mq_timedreceive - receive messages on a message queue with absolute timeout</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#description","title":"Description","text":"<p>The mq_timedreceive() system call receives the oldest of the highest priority messages on the message queue, <code>mqdes</code>. It does this with using an absolute timeout, <code>abs_timeout</code>. If the operation is successful, the read message is copied in value-result argument <code>msg_ptr</code> and if <code>msg_prio</code> is not <code>NULL</code>, the priority of the message is stored at <code>msg_prio</code>. <code>msg_len</code> should be set to the maximum size of the buffer in <code>msg_ptr</code>. The timeout is given in an <code>struct timespec</code> pointed by <code>abs_timeout</code>, which consists of an absolute time measured in seconds and nanoseconds since the Epoch (00:00:00 UTC, January 1, 1970).</p> <p>This syscall is useful if the order of message reception is important and if the thread needs to wait with a predefined timeout. The negative side of the syscall is that it requires knowledge of the time epoch and the calling application needs to handle timespecs correctly.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - A message queue descriptor.</li> <li><code>msg_ptr</code>:<code>char*</code>[U] - Pointer to a buffer that will hold the retrieved message.</li> <li><code>msg_len</code>:<code>size_t</code> - Length in bytes of the buffer <code>msg_ptr</code>, which should not be less than the attribute <code>mq_msgsize</code> for the message queue.</li> <li><code>msg_prio</code>:<code>unsigned int*</code>[U] - If not <code>NULL</code>, the priority of the retrieved message will be stored in the integer pointed to by <code>msg_prio</code>.</li> <li><code>abs_timeout</code>:<code>const struct timespec*</code>[U] - Pointer to an absolute timeout in a structure of type <code>struct timespec</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#sys_mq_timedreceive","title":"sys_mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#purpose","title":"Purpose","text":"<p>Hooking sys_mq_timedreceive allows us to measure the elapsed time for the syscall and add log information, like process and thread information as well as argument values.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#mq_timedreceive_1","title":"mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#purpose_1","title":"Purpose","text":"<p>Hooking mq_timedreceive allows us to measure latency, return values, and other performance metrics of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#example-use-case","title":"Example Use Case","text":"<p>One example use case for mq_timedreceive is for when applications need to get messages from a queue within a defined timeout to ensure responsiveness and reliable throughput.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#issues","title":"Issues","text":"<p>If the message queue is empty, mq_timedreceive will timeout and return <code>-ETIMEDOUT</code> which needs to be handled by the calling application.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#related-events","title":"Related Events","text":"<ul> <li>mq_timedsend</li> <li>mq_receive</li> <li>mq_send</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/","title":"mq_timedreceive_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#intro","title":"Intro","text":"<p><code>mq_timedreceive_time32()</code> - receives the oldest of the highest priority messages stored in the message queue specified by mqdes.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#description","title":"Description","text":"<p>The <code>mq_timedreceive_time32()</code> system call atomically removes the oldest of the highest priority messages from the message queue specified by the <code>mqdes</code> argument, places it in the memory pointed to by <code>u_msg_ptr</code>, and returns its priority in the integer pointed to by <code>msg_prio</code>. The <code>msg_len</code> argument specifies the size in bytes of the storage pointed to by <code>u_msg_ptr</code>; this space must be greater than or equal to the mq_msgsize attribute of the message queue. The <code>u_abs_timeout</code> argument points to a structure that specifies the absolute timeout of the call. </p> <p>It can provide synchronization and communication between processes, like avoiding busy waiting and non-sharing of resources between different threads. While there are many advantage to using this system call, one downside of it is that it does not ensure real-time delivery of the message. Also, it is vulnerable to the time of check, time of use (TOCTOU) vulnerability. </p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>: <code>mqd_t</code>[K] - Descriptor of the message queue.</li> <li><code>u_msg_ptr</code>: <code>char*</code>[K] - Points to the buffer where the oldest/highest priority message will be stored.</li> <li><code>msg_len</code>: <code>unsigned int</code>[K] - Length in bytes of the buffer. </li> <li><code>u_msg_prio</code>: <code>unsigned int*</code>[K] - Pointer to an integer that stores the priority of the received message.</li> <li><code>u_abs_timeout</code>: <code>struct old_timespec32*</code>[K] - Specifies the absolute timeout of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#mq_timedreceive_time32_1","title":"mq_timedreceive_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#purpose","title":"Purpose","text":"<p>Hook the <code>mq_timedreceive_time32()</code> system call to measure performance metrics (e.g. latency) and receive messages as expected. </p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#example-use-case","title":"Example Use Case","text":"<p><code>mq_timedreceive_time32()</code> can be used to provide synchronization between different processes and threads. For example, it can be used in a web browser application to receive data from a server that has the same message queue descriptor as the process.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#issues","title":"Issues","text":"<ul> <li>It does not ensure real-time delivery of the messages. </li> <li>It is vulnerable to the time of check, time of use (TOCTOU) vulnerability. </li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#related-events","title":"Related Events","text":"<ul> <li><code>mq_timedsend_time32()</code> - sends a message with absolute timeout to a message queue. </li> <li><code>mq_open()</code> - used to open or create a message queue.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/","title":"mq_timedsend","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#intro","title":"Intro","text":"<p>mq_timedsend - Send a message to a message queue, with a timeout.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#description","title":"Description","text":"<p>mq_timedsend is a function used to send a message to a message queue, with a timeout specified.  It has the following arguments: a message queue descriptor, a message pointer, the message length, the priority of the message, and a pointer to a timespec struct containing the timeout.  Upon a successful call the message is added to the queue, in the order of priority. </p> <p>The mq_timedsend call is more efficient than mq_send when the timeout is specified as the latter has to check the queue everytime to see if its gotten full, while the former only has to check the timout. However, if no timeout is specified mq_send should be used instead as it's more efficient.</p> <p>Additionally, if the message queue descriptor is invalid, mq_timedsend will return an error.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - File descriptor of the message queue.</li> <li><code>msg_ptr</code>:<code>const char*</code>[K] - Pointer to the message to be sent.</li> <li><code>msg_len</code>:<code>size_t</code>[K] - Length of the message.</li> <li><code>msg_prio</code>:<code>unsigned int</code>[K] - Priority of the message.</li> <li><code>abs_timeout</code>:<code>const struct timespec*</code>[K] - Pointer to a timespec struct containing the timeout information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#mq_timedsend_start","title":"mq_timedsend_start","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#purpose","title":"Purpose","text":"<p>Hook the start of mq_timedsend to measure time and latency of this syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#mq_timedsend_return","title":"mq_timedsend_return","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#purpose_1","title":"Purpose","text":"<p>Hook the return of mq_timedsend to measure time and latency of this syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#example-use-case","title":"Example Use Case","text":"<p>An example use case of this syscall would be when there is an application that needs to send a message with a certain priority, and there is a time limit on when the message needs to be sent.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#issues","title":"Issues","text":"<p>mq_timedsend is only available for Linux 2.6.7 or later.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#related-events","title":"Related Events","text":"<ul> <li>mq_send </li> <li>mq_timedreceive</li> <li>mq_unlink</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/","title":"mq_timedsend_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#intro","title":"Intro","text":"<p>mq_timedsend_time32 - sends message on a message queue with a timeout value</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#description","title":"Description","text":"<p>The mq_timedsend_time32() system call sends the message pointed to by u_msg_ptr, with message length msg_len, and a message priority of msg_prio, to the queue indicated by the message queue descriptor mqdes.</p> <p>The u_abs_timeout parameter points to a structure of type \"old_timespec32\", specifying the absolute timeout (time of day) at which the system call should expire - in other words, the time to wait for a successful return before aborting the operation. If the value of u_abs_timeout-&gt;tv_nsec is greater than or equal to 1 billion, the system call fails and returns an error.</p> <p>When a process sends a message to a queue, the process that is blocked on a message queue due to either mq_timedsend_time32() or mq_timedreceive_time32() will wake up, and either receive the message if the process is blocked on mq_timedreceive_time32(), or find that the send operation succeeded if the process is blocked on mq_timedsend_time32().</p> <p>The tm_timedsend_time32() system call provides an interface for sending a message to an existing message queue with an absolute timeout, preventing an indefinite wait, as it can happen if the message queue is full and the receiver side is absent.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - message queue descriptor.</li> <li><code>u_msg_ptr</code>:<code>char*</code>[KU] - pointer to the message to be sent.</li> <li><code>msg_len</code>:<code>unsigned int</code>[K] - length of the message.</li> <li><code>msg_prio</code>:<code>unsigned int</code>[K] - message priority.</li> <li><code>u_abs_timeout</code>:<code>struct old_timespec32*</code>[K] - pointer to the absolute timeout value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#do_mq_timedsend_time32","title":"do_mq_timedsend_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#purpose","title":"Purpose","text":"<p>To trace mq_timedsend_time32 system call.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#example-use-case","title":"Example Use Case","text":"<p>mq_timedsend_time32 could be used to monitor and trace an application sending messages to a message queue with a timeout value.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#issues","title":"Issues","text":"<p>The use of absolute timestamps might lead to incorrect time values.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#related-events","title":"Related Events","text":"<p>mq_timedreceive_time32</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/","title":"mq_unlink","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#intro","title":"Intro","text":"<p>mq_unlink - remove a message queue from the system</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#description","title":"Description","text":"<p>The mq_unlink() system call removes a message queue named name from the system. This is a permanent operation, and any associated resources are immediately  freed for other use. </p> <p>If the message queue does not exist, the call fails and the system call returns with the errno set to ENOENT.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[K] - the name of the message queue to be unlinked.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#sys_mq_unlink","title":"sys_mq_unlink","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#purpose","title":"Purpose","text":"<p>To be able to track when a message queue is unlinked from the system.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to be aware of what message queues are  unlinked from the system in order to debug an application or analyze where resources are being freed in the system.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#related-events","title":"Related Events","text":"<ul> <li>mq_open</li> <li>mq_send</li> <li>mq_close</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mremap/","title":"mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#intro","title":"Intro","text":"<p>mremap - move a mapping and resize.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#description","title":"Description","text":"<p>The mremap() system call changes the mapping between virtual addresses and physical pages existing in a process address space. It expands or shrinks the area of existing mapping without moving the page frames. The old address range may have multiple non-contiguous mappings, and new address range can be in a non-contiguous mapping as well.</p> <p>mremap() can also be used to map a non-contiguous area of physical memory as a contiguous mapping. The <code>MREMAP_FIXED</code> flag should be used to request that the new mapping is made at a fixed address, which is specified in the last argument.</p> <p>Aside from enlarging or shrinking a mapping the old range and the new range may overlap or not be adjacent. In those cases, mremap() can also be used to move the mapping from one address space to another.</p> <p>The flags argument enables several options for the mremap() operation. It determines whether the new range of memory should be accessible, what must happen if the desired new address range already contains a mapping, whether the mapping is private or shared, and whether the old address range should be unshareable (prevented from being transparently cloned/shared). </p> <p>mremap() is not required to check access permissions on the old address range before performing the remapping, so care should be taken to ensure that the old address range is correctly protected.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#arguments","title":"Arguments","text":"<ul> <li><code>old_address</code>:<code>void*</code>[KU] - The virtual address of the existing mapping.</li> <li><code>old_size</code>:<code>size_t</code>[K] - The size of the existing mapping.</li> <li><code>new_size</code>:<code>size_t</code>[K] - The size of the new mapping.</li> <li><code>flags</code>:<code>int</code>[K] - The flags controlling the behavior of the mremap() system call.</li> <li><code>new_address</code>:<code>void*</code>[KUOPT] - The virtual address of the new mapping. When the <code>MREMAP_FIXED</code> flag is used, this argument specifies the new address to which the existing mapping is moved, otherwise it is ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mremap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mremap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mremap/#sys_mremap","title":"sys_mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#type","title":"Type","text":"<p>Kprobes + kretprobes</p>"},{"location":"docs/events/builtin/syscalls/mremap/#purpose","title":"Purpose","text":"<p>This function was hooked to monitor memory allocation and deallocation.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#do_mremap","title":"do_mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mremap/#purpose_1","title":"Purpose","text":"<p>This function was hooked to monitor inputs and outputs to the sys_mremap syscall.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#example-use-case","title":"Example Use Case","text":"<p>mremap() can be used to apply a new mapping to an area of physical memory. This might be useful, for example, in an embedded system to remap a shared memory space, allowing different tasks to access the same physical memory in different address spaces.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#issues","title":"Issues","text":"<p>mremap() is vulnerable to TOCTOU (Time Of Check Time Of Use) attacks. If an attacker can create or modify a mapping between the moment a mapping is checked and the moment it is used, it can increase the attack surface area of the application.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#related-events","title":"Related Events","text":"<ul> <li>mmap</li> <li>munmap</li> <li>memcpy</li> <li>memmove</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/","title":"msgctl","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#intro","title":"Intro","text":"<p>msgctl - manipulate message queue control operations on System V message queues</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#description","title":"Description","text":"<p>The <code>msgctl</code> system call is used to manipulate message queue control operations on System V message queues. Depending on the command, it can be used to set or get the attributes associated with a message queue, change ownership of the queue, or remove the queue entirely.</p> <p>The command argument specifies the requested control action:  * <code>IPC_STAT</code> to fetch the <code>msqid_ds</code> structure, which contains various status and control information about the queue itself;  * <code>IPC_SET</code> to set some of the members of the <code>msqid_ds</code> structure;  * <code>IPC_RMID</code> to remove the data structure associated with the message queue and destroy the queue.</p> <p>The <code>msgctl</code> system call can suffer from certain time-of-check-to-time-of-use (TOCTOU) vulnerabilitites.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - the identifier of the message queue to be operated on.</li> <li><code>cmd</code>:<code>int</code>[K] - the operation to be performed on the message queue.  Supported commands are <code>IPC_RMID</code>, <code>IPC_STAT</code>, and <code>IPC_SET</code>, as defined in . <li><code>buf</code>:<code>struct msqid_ds*</code>[KU TOCTOU] - the address of a <code>msqid_ds</code> structure, which is used depending on the command.</li>"},{"location":"docs/events/builtin/syscalls/msgctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#do_msgctl","title":"do_msgctl","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#purpose","title":"Purpose","text":"<p>To monitor the arguments and the return value of the <code>msgctl</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>msgctl</code> system call can be used to monitor message queues, as well as to detect suspicious activity. For example, it could be used to detect if a queue is constantly being modified or if a malicious process is trying to modify a queue without authorization.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#issues","title":"Issues","text":"<p>The <code>msgctl</code> system call is vulnerable to TOCTOU vulnerabilities, as the system call may validate one argument when entering the kernel and a different argument when actually executing the command.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#related-events","title":"Related Events","text":"<ul> <li>msgget</li> <li>msgsnd</li> <li>msgrcv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgget/","title":"msgget","text":""},{"location":"docs/events/builtin/syscalls/msgget/#intro","title":"Intro","text":"<p>msgget - Get a System V message queue identifier  </p>"},{"location":"docs/events/builtin/syscalls/msgget/#description","title":"Description","text":"<p>The msgget() system call returns the message queue identifier associated with the value of the key argument. If key is equal to IPC_PRIVATE, the message queue identifier is created and associated with an internal key value and both are returned. If the System V message queue identifier and key exists and the user does not have the required permissions to access the queue, the system call fails and the return value is -1. If multiple processes attempt to create a message queue with the same key value, each process will get the same message queue identifier and the same internal key value. If a message queue identifier exists for a given key value and msgflg specifies IPC_CREAT and IPC_EXCL, the call will fail.</p> <p>There are a few drawbacks related to msgget() that should be mentioned. Firstly, the IPC_PRIVATE key should not be used as it is shared across all connections. Secondly, the message queue identifier associated with the key not being available when held by the server can result in unintended consequences. Lastly, the System V message queue identifier identifier is limited in size, meaning that only a relatively small number of queues can be created on a particular system.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code> - Identifier for the System V message queue.</li> <li><code>msgflg</code>:<code>int</code> - A flag that can include any of the following flags: IPC_CREAT, IPC_EXCL, or IPC_NOWAIT.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgget/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgget/#sys_msgget","title":"sys_msgget","text":""},{"location":"docs/events/builtin/syscalls/msgget/#type","title":"Type","text":"<p>kprobes </p>"},{"location":"docs/events/builtin/syscalls/msgget/#purpose","title":"Purpose","text":"<p>To identify calls to the sys_msgget function</p>"},{"location":"docs/events/builtin/syscalls/msgget/#example-use-case","title":"Example Use Case","text":"<p>The msgget system call can be used to create a System V message queue identifier which can be used to help in the interprocess communication among different processes running in the system.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#issues","title":"Issues","text":"<p>One issue with the msgget system call is that it has limited numbers of message queues that can be created in a system depending on the size of the System V message queue identifier.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#related-events","title":"Related Events","text":"<ul> <li>msgsnd</li> <li>msgrcv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/","title":"msgrcv","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#intro","title":"Intro","text":"<p>msgrcv - Linux system call that reads a message located in a queue</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#description","title":"Description","text":"<p>msgrcv() is a Linux system call that reads a message located in a  message queue identified by the ID parameter <code>msqid</code>. The parameter  <code>msgp</code> points to the memory containing the read message. The <code>msgp</code>  is overwritten with the actual message in the message queue, which  contains the data in the structure <code>struct msgbuf</code>, and its length is defined by the <code>msgsz</code> parameter. The <code>msgtyp</code> parameter defines the  message type that should be read from the message queue, where zero means the first message of the queue, and negative numbers define the  absolute values of the message types that should be looked for. The  <code>msgflg</code> parameter can be an OR'd combination of flags that specify  the behavior of the system call, and can be set to zero to ignore  them. Note that there may be security issues involved in the use of  this system call, as it ignores the current user id and may allow  attempts to read messages from another user's queue, depending on  the settings of the system.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - System-wide unique message queue identifier.</li> <li><code>msgp</code>:<code>struct msgbuf*</code>[KU] - Pointer to the memory that should contain the read message, in a structure that contains the data in the structure <code>struct msgbuf</code>.</li> <li><code>msgsz</code>:<code>size_t</code>[K] - Length of the message pointed by parameter <code>msgp</code>.</li> <li><code>msgtyp</code>:<code>long</code>[K] - Message type that should be read from the message queue, where zero means the first message of the queue, and negative numbers define the absolute values of the message types that should be looked for.</li> <li><code>msgflg</code>:<code>int</code>[K] - OR'd parameter that defines the behavior of the system call, and can be set to zero to ignore them.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgrcv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgrcv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#msgrcv_1","title":"msgrcv","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#type","title":"Type","text":"<p>KProbes </p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#purpose","title":"Purpose","text":"<p>Hook into the kernel function of msgrcv to monitor any calls made to the system call.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#example-use-case","title":"Example Use Case","text":"<p>Using msgrcv allows programs to read and fetch messages from message queues. For example, an application monitoring system can use it to read messages from the message queues of programs it is monitoring.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#issues","title":"Issues","text":"<p>The potential security issues of reading messages from message queues of other users might be of concern. It is possible to set the environment of the system to the \"no_root_squash\" value for the NFS, to allow for users to use this system call safely.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#related-events","title":"Related Events","text":"<ul> <li>msgsnd - System call that sends a message to a queue.</li> <li>msgget - System call that retrieves a message queue identifier.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/","title":"msgsnd","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#intro","title":"Intro","text":"<p>msgsnd - submit a message to a message queue</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#description","title":"Description","text":"<p>The msgsnd() system call appends a message to a message queue. It is a blocking version of msgsnd() and will block until the message can be enqueued. The msqid argument is the identifier of the message queue, and the msgp points to the message structure to be sent. The msgsz argument is the size of the passed message structure in bytes. The msgflag argument is the bitwise OR of flags to indicate the type of message transfer.</p> <p>The msgp argument is a pointer to a structure of the following format:</p> <pre><code>struct msgbuf {\n    long mtype;    /* message type, must be &gt; 0 */\n    char mtext[1]; /* message data */\n};\n</code></pre> <p>The mtype field specifies the type of message being sent, and must be nonzero. On return, the mtext field in the source msgp structure contains no meaningful data.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#advantages","title":"Advantages","text":"<p>Using msgsnd() allows for rapid, reliable communication between processes without involving multiple context switches.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#drawbacks","title":"Drawbacks","text":"<p>Using msgsnd() requires that the message queue already exists, and that the queues are tested to be valid before attempting to send a message.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - Identifier of the message queue.</li> <li><code>msgp</code>:<code>struct msgbuf*</code>[U] - Pointer to the message structure to be sent.</li> <li><code>msgsz</code>:<code>size_t</code> - The size of the passed message structure in bytes.</li> <li><code>msgflg</code>:<code>int</code>[K] - Bitwise OR of flags to indicate the type of message transfer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgsnd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgsnd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#do_msgsnd","title":"do_msgsnd","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#purpose","title":"Purpose","text":"<p>To monitor the execution of the msgsnd syscall.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#example-use-case","title":"Example Use Case","text":"<p>The msgsnd() system call can be used to send a message from one process to another, allowing for interprocess communication.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#related-events","title":"Related Events","text":"<ul> <li>msgrcv() - Receive a message from a message queue.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msync/","title":"msync","text":""},{"location":"docs/events/builtin/syscalls/msync/#intro","title":"Intro","text":"<p>msync - synchronize a file with a memory map</p>"},{"location":"docs/events/builtin/syscalls/msync/#description","title":"Description","text":"<p>The msync() system call causes all changes made to the in-core copy of a file  mapped by a mapping handled by the \"msync\" call to be written to the storage device  on which the file resides or, depending on the flags, to be discarded. </p> <p>Advantages of using msync are that is allows to synchronize a region of a file to  with a copy in a memory mapped region. This can help to avoid data corruption issues when a program exits abruptly.</p> <p>Drawbacks of msync can be related to the performance of synchronizing the data.  Synchronous updates could hurt performance in scenarios where high throughput is  desired.</p>"},{"location":"docs/events/builtin/syscalls/msync/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - Pointer to the start of the memory region. Must be aligned to the  system page size.</li> <li><code>length</code>:<code>size_t</code>[K] - Size of the memory region in bytes.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for how to look for changes. </li> </ul>"},{"location":"docs/events/builtin/syscalls/msync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msync/#sys_msync","title":"sys_msync","text":""},{"location":"docs/events/builtin/syscalls/msync/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/msync/#purpose","title":"Purpose","text":"<p>Track when and with what parameters the sys_msync syscall is called.</p>"},{"location":"docs/events/builtin/syscalls/msync/#example-use-case","title":"Example Use Case","text":"<p>A client-server application where the server keeps track of state using a file and the clients operate on that file by reading and writing to it without calling msync. A msync event could be used to check when the clients write to the file and whether they do it correctly or not.</p>"},{"location":"docs/events/builtin/syscalls/msync/#issues","title":"Issues","text":"<p>msync only works with files that have been directly mapped in to physical memory.  This means it can't be used with files that are mapped in to virtual memory.</p>"},{"location":"docs/events/builtin/syscalls/msync/#related-events","title":"Related Events","text":"<ul> <li>sys_munmap</li> <li>sys_mprotect</li> <li>sys_mlock</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munlock/","title":"<code>munlock</code>","text":""},{"location":"docs/events/builtin/syscalls/munlock/#intro","title":"Intro","text":"<p><code>munlock</code> - unlock memory from being in the locked state</p>"},{"location":"docs/events/builtin/syscalls/munlock/#description","title":"Description","text":"<p>The <code>munlock</code> syscall unlocks an area of memory previously locked using the <code>mlock</code> syscall. The range of memory that is unlocked must follow the same rules as for <code>mlock</code>, i.e., it must contain the entire range from <code>addr</code> to <code>addr + len</code> inclusively. Note that this syscall does not cause the kernel to allocate the pages that it unlocks, any previously allocated pages in the range are the ones that are unlocked.</p> <p><code>munlock</code> releases or removes the record lock memory range held by the process, allowing it to be swapped out.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[K] - start address of the memory range to unlock.</li> <li><code>len</code>:<code>size_t</code>[K] - Length of the memory range to unlock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munlock/#set_memory_x","title":"Set_memory_x","text":""},{"location":"docs/events/builtin/syscalls/munlock/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#purpose","title":"Purpose","text":"<p>To log when memory is unlocked.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#example-use-case","title":"Example Use Case","text":"<p>The <code>munlock</code> syscall can be used to unlock areas of memory held in a locked state so that it can be swapped out and reclaimed. This could be used to ensure that the system is not continually locking and unlocking pages, thus avoiding unnecessary fragmentation of memory.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#related-events","title":"Related Events","text":"<p><code>mlock</code> - lock memory in memory so that it is not paged out.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/","title":"munlockall","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#intro","title":"Intro","text":"<p>munlockall - Unlocks all currently locked-in-memory pages </p>"},{"location":"docs/events/builtin/syscalls/munlockall/#description","title":"Description","text":"<p>The munlockall () system call unlocks all pages in the address space of the current process that were previously locked via mlockall (). After the call, pages are unlocked regardless of the current reference counts. It has no effect on any pages that were not previously locked via mlockall ().</p> <p>The munlockall () system call does not unlock the amount of memory locked for the process.  The amount of locked memory for the process remains the same after a call to munlockall (). However, the call does reset the list of mlocked regions. Any subsequent mlock() and mlock2() system calls are limited by the amount of memory that is currently locked for the process.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void *</code>[U] - Pointer to a memory region. </li> </ul>"},{"location":"docs/events/builtin/syscalls/munlockall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlockall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#munlockall_1","title":"munlockall","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#purpose","title":"Purpose","text":"<p>To monitor a process's memory utilization, and detect excessive page locking.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#example-use-case","title":"Example Use Case","text":"<p>An application may need to allocate a large chunk of memory and lock it down for its exclusive use. With munlockall () an application can quickly establish multiple regions of locked memory that it does not need to allocate and initialize each time.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#issues","title":"Issues","text":"<p>munlockall() may cause performance issues on some systems due to the additional IO operations performed.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#related-events","title":"Related Events","text":"<ul> <li>mlockall() </li> <li>mlock()</li> <li>munlock()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munmap/","title":"munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#intro","title":"Intro","text":"<p>munmap - used to unmap/delete a previously mapped region of memory </p>"},{"location":"docs/events/builtin/syscalls/munmap/#description","title":"Description","text":"<p>munmap is a syscall provided by the Linux kernel that is used to unmap/delete a previously mapped region of memory. This can be used to free up memory that was previously allocated for some purpose and is no longer needed. This syscall provides an efficient way for processes to manage their memory usage, as it can free up specific regions of memory that have been mapped, rather than having to free up all the memory and then reallocate the required portions. One of the drawbacks of using this system call is that it can lead to memory fragmentation, as areas of memory are freed individually. This can make it difficult for processes to allocate memory in larger chunks, as there may be a number of small, scattered areas of free memory.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void*</code>[K] - Address of a previously mapped memory region in the calling process.</li> <li><code>length</code>: <code>size_t</code>[K] - Length of the memory region to be unmapped, in bytes. Must match the length of the region that was provided to mmap() during its creation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/munmap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munmap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munmap/#do_munmap","title":"do_munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munmap/#purpose","title":"Purpose","text":"<p>To monitor the unmapping of addressed regions of memory in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#vm_munmap","title":"vm_munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munmap/#purpose_1","title":"Purpose","text":"<p>To monitor the unmapping of addressed regions of memory in user space processes.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#example-use-case","title":"Example Use Case","text":"<p>A web server written in C needs to keep track of the addresses of all allocated memory regions as part of its regular clean-up and memory management process. The web server can use the munmap syscall to free-up memory upon the completion of an operation and make the associated address space available for future uses.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#issues","title":"Issues","text":"<p>No issues have been reported with the munmap syscall.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code> - The sys call used to map a region of memory.</li> <li><code>mremap</code> - The sys call used to resize a mapped memory region.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/","title":"name_to_handle_at","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#intro","title":"Intro","text":"<p>name_to_handle_at - Gets a handle for a path</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#description","title":"Description","text":"<p>The name_to_handle_at system call takes an open file descriptor <code>dirfd</code> of a directory and a path <code>pathname</code> relative to it, and acts in a similar fashion to name_to_handle_at. It returns a handle that can be used in the future to refer to the object specified by the path.</p> <p>The use of this system call allows applications to keep track of objects even if the path to them changes due to mount/unmount operations or directory moves. It is similar to the openat system call, but the returned file handle is valid even if the process moves to another mount namespace.</p> <p>The <code>handle</code> argument is the output that will be filled by the system call. The purpose of passing <code>mount_id</code> is to specify an exported or shared filesystem handle to be used instead of the name. <code>flags</code> is used to add additional information about the name resolution for the file handle.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor of a directory used by name_to_handle_at.</li> <li><code>pathname</code>:<code>const char*</code>[K] - Path relative to the directory specified by the <code>dirfd</code> file descriptor.</li> <li><code>handle</code>:<code>struct file_handle*</code>[K] - Memory address used to hold the output result (file handle).</li> <li><code>mount_id</code>:<code>int*</code>[K] - Pointer to an additional information of the exported filesystem.</li> <li><code>flags</code>:<code>int</code>[K] - Flags used to add additional information on the name resolution of the file handle.</li> </ul>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#sys_name_to_handle_at","title":"sys_name_to_handle_at","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#type","title":"Type","text":"<p>Kprobe + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#purpose","title":"Purpose","text":"<p>To trace each time a process calls a <code>name_to_handle_at</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#example-use-case","title":"Example Use Case","text":"<p>When writing a file system monitoring application, it might be interesting to keep track of changes regarding objects in the file system associated with a certain process. The <code>name_to_handle_at</code> system call allows for that, by providing an efficient way to retrieve handles for the objects.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#issues","title":"Issues","text":"<p>If mountIDs are used, the returned file handle may be unreliable if the filesystem is moved or unmounted in the meanwhile.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#related-events","title":"Related Events","text":"<p>openat</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/","title":"nanosleep","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#intro","title":"Intro","text":"<p>nanosleep - Suspend execution of the calling thread for whatever is specified by req.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#description","title":"Description","text":"<p>nanosleep is used to suspend execution of the calling thread until either the time interval specified in the structure pointed to by req has passed or the delivery of a signal which triggers the invocation of a signal-catching function. This structure value remains in effect until nanosleep finishes, it will not currently adjust the timer in case of interrupted by a signal handler. There are some edge cases and inadequacies related to the timing of nanosleep and how it is affected by clock changes, system load and other processes.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#arguments","title":"Arguments","text":"<ul> <li><code>req</code>:<code>const struct timespec*</code>[K] - Pointer to a structure that specifies an interval of time, of type struct timespec, to pause execution of the calling thread.</li> <li><code>rem</code>:<code>struct timespec*</code>[KU] - Pointer to a structure that shall receive the time still remaining of the interval specified in req, of type struct timespec.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nanosleep/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/nanosleep/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#do_sys_nanosleep","title":"do_sys_nanosleep","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#purpose","title":"Purpose","text":"<p>To find the overhead of nanosleep invocations.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#example-use-case","title":"Example Use Case","text":"<p>nanosleep can be used to sleep for a specified length of time to produce a slowdown for the process that is being profiled. It can also be used to yield the CPU running time to other threads and processes.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#issues","title":"Issues","text":"<p>Since nanosleep is based on the system\u2019s kernel jiffies counter, its accuracy can be affected by system load, other processes and clock changes. This may cause nanosleep to return earlier or later than requested.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#related-events","title":"Related Events","text":"<p>syscall_entry (for nanosleep) - Event that is triggered when a syscall is entered. syscall_exit (for nanosleep) - Event that is triggered when a syscall is exited.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/","title":"newfstatat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#intro","title":"Intro","text":"<p>newfstatat - obtains information about a file relative to a directory file descriptor</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#description","title":"Description","text":"<p>The newfstatat() system call is used to obtain information about a file relative to a directory file descriptor. It is similar the <code>fstat()</code> call, but the file descriptor is related to a directory in which the pathname is relative to. The <code>dirfd</code> parameter of this call is an open file descriptor for a directory, and the <code>pathname</code> parameter is a pathname within that directory; the system call then does the same sort of thing with this file as <code>fstat()</code> does for a given file descriptor. The <code>flags</code> parameter of this call can have different values indicating the behaviour of this call. Returned information about the file will be stored in the <code>statbuf</code> buffer.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The advantage of using newfstatat() is that it is able to obtain information about a file within a directory without requiring a full pathname, just a filename relative to the directory. The main drawback of using newfstatat() is its lack of support for certain flags that <code>fstat()</code> or <code>stat()</code> might provide.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - an open file descriptor for the directory.</li> <li><code>pathname</code>: <code>const char*</code>[U] - the pathname of the file relative to the directory.</li> <li><code>statbuf</code>: <code>struct stat*</code>[K] - address where information about the file is returned.</li> <li><code>flags</code>: <code>int</code>[K] - flags describing the behaviour of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/newfstatat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/newfstatat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#sys_newfstatat","title":"sys_newfstatat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#purpose","title":"Purpose","text":"<p>Capturing the file descriptor, flags and pathname arguments and returning the updated file stats.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#path_lookupat","title":"path_lookupat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#purpose_1","title":"Purpose","text":"<p>To lookup the pathname passed as an argument and ensure it is valid.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor file access attempts within a directory, such as attempts to access a configuration file or secret file, by logging the pathname of the file and the status of the operation. </p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#issues","title":"Issues","text":"<p>newfstatat() is not able to provide information based on certain flags that would be used with fstat() and stat().</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#related-events","title":"Related Events","text":"<ul> <li>fstat()</li> <li>stat()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/","title":"nfsservctl","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#intro","title":"Intro","text":"<p>nfsservctl - Used to query and/or update kernel parameters in the NFS server.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#description","title":"Description","text":"<p>The nfsservctl() system call is used to query or update kernel parameters in the NFS server. When used to query parameters, it returns the current parameters, including potential upgrade messages. When used to modify parameters, flags can be set which will cause the NFS server to automatically restart itself after the parameters take effect.</p> <p>The nfsservctl() system call can also be used to start and stop the NFS server. This ability is useful for system administrators who wish to restart the server for maintenance or configuration changes without requiring a system reboot.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - specifies the type of operation to perform. This is one of the NFSCTL_* constants.</li> <li><code>arg</code>:<code>void *</code>[K] - a pointer to a buffer to be used to store information related to the nfsservctl() command such as parameters that need to be changed or information about the current status of the NFS server.</li> <li><code>len</code>:<code>sizet</code>[K] - used to specify the length of the buffer in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#sys_nfsservctl","title":"sys_nfsservctl","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#purpose","title":"Purpose","text":"<p>To monitor NFS server activity - It should be able to identify whether the system is issuing NFS server control commands.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#example-use-case","title":"Example Use Case","text":"<p>In certain scenarios, an administrator may need to make frequent changes to NFS server settings in order to optimize performance. In such cases, the nfsservctl() system call allows them to make such changes without requiring a system reboot or manual intervention.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#issues","title":"Issues","text":"<p>null</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#related-events","title":"Related Events","text":"<ul> <li>nfsservctl_set_constate</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nice/","title":"nice","text":""},{"location":"docs/events/builtin/syscalls/nice/#intro","title":"Intro","text":"<p>nice - Change the nice value of the current process, influence scheduling priority</p>"},{"location":"docs/events/builtin/syscalls/nice/#description","title":"Description","text":"<p>The nice() system call can be used to change the nice value of the current process, which influences its scheduling priority. A lower nice value causes more favorable scheduling, and a process with a \"high\" nice value will be scheduled less often than other processes. A process must be privileged to raise its nice value (i.e., to decrease its priority).</p> <p>There are some edge-cases with nice(): if a privileged process calls nice() with a non-zero value, then it might cause the scheduling priority to drop too far or become too favorable; this could put system instability. Additionally, even a process with the correct privileges cannot raise its nice value above its current value.</p>"},{"location":"docs/events/builtin/syscalls/nice/#arguments","title":"Arguments","text":"<ul> <li><code>inc</code>:<code>int</code> - The 'inc' argument specifies an increment to be added to the nice value of the current process. A positive value adds to the nice value and a negative value subtracts from it. For the superuser, the range of valid nice values is from -20 (most favorable) to +19 (least favorable). For a normal process, the range is from 0 to PRIO_MAX (usually 20).</li> </ul>"},{"location":"docs/events/builtin/syscalls/nice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nice/#sys_nice","title":"sys_nice","text":""},{"location":"docs/events/builtin/syscalls/nice/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/nice/#purpose","title":"Purpose","text":"<p>To monitor and log when the <code>nice</code> syscall is used.</p>"},{"location":"docs/events/builtin/syscalls/nice/#example-use-case","title":"Example Use Case","text":"<p>Nice() can be used to measure the relative performance of two applications running against each other on a system. By setting one application to a slightly higher nice value, you can prioritize the other application, thus obtaining an accurate performance measurement.</p>"},{"location":"docs/events/builtin/syscalls/nice/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/nice/#related-events","title":"Related Events","text":"<p>The sched_setscheduler function can be used to change the scheduling policy and priority of a process. This event is typically a better option than the nice() system call if you want to tailor the scheduling priority of a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/","title":"old_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#intro","title":"Intro","text":"<p>old_getrlimit - get resource limits knwon to the kernel</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#description","title":"Description","text":"<p>The old_getrlimit syscall is used to retrieve the resource limit values for a particular resource, such as the maximum size of a file that may be written, the maximum number of processes that may be started, etc. It returns the values in the struct rlimit pointed to by the rlim parameter. </p> <p>This syscall is available in Linux kernel versions 2.2 and earlier, although it is no longer supported in newer kernels. As such, it is important to note that, while it may return the correct results, those results may be outdated and the kernel may be changing it's behavior without the process being aware.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code> - resource identifier.</li> <li><code>rlim</code>:<code>struct rlimit*</code> - pointer to struct rlimit that will store the limit values.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#availiable-tags","title":"Availiable Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#old_getrlimit_1","title":"old_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#purpose","title":"Purpose","text":"<p>To monitor resource limit values in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#example-use-case","title":"Example Use Case","text":"<p>If a process needs to monitor its resource limit values, it can use old_getrlimit syscall. </p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#issues","title":"Issues","text":"<p>The old_getrlimit syscall is no longer supported in newer kernels and as such the results returned may be outdated and the kernel may be changing it's behavior without the process being aware.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#related-events","title":"Related Events","text":"<ul> <li>setrlimit - set resource limit values.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/old_select/","title":"old_select","text":""},{"location":"docs/events/builtin/syscalls/old_select/#intro","title":"Intro","text":"<p>old_select - Used to monitor multiple file descriptors for a synchronous event.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#description","title":"Description","text":"<p>old_select is used to monitor multiple file descriptors for a synchronous event. This can be useful for waiting for data on a network connection or for handling multiple file descriptors at the same time. old_select will block until one of the file descriptors is ready or a timeout is reached. It has the same function as the newer select() system call, but with a slightly different interface.</p> <p>One of the main drawbacks of the old_select system call is that it is vulnerable to the time-of-check-time-of-use (TOCTOU) race condition. This is because old_select doesn't have the ability to atomically check the file descriptors and set the timeout. This can lead to a process missing out on data if the data has already been read before the timeout is set.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:<code>int</code> - The number of file descriptors to be monitored.</li> <li><code>readfds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for readability.</li> <li><code>writefds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for writability.</li> <li><code>exceptfds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for out of band data.</li> <li><code>timeout</code>:<code>struct timeval*</code>[K] - Timeout value, as a <code>struct timeval</code>. If <code>nullptr</code> is passed, the call is blocking.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_select/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_select/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/old_select/#old_select_1","title":"old_select","text":""},{"location":"docs/events/builtin/syscalls/old_select/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#purpose","title":"Purpose","text":"<p>To monitor the different conditions of the fd sets that are passed in the selector call.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#example-use-case","title":"Example Use Case","text":"<p>old_select is useful for monitoring multiple file descriptors in a synchronous setting. For example, an application might use it to monitor a network connection for incoming data and multiple local file descriptors for requests from other processes.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#issues","title":"Issues","text":"<p>The main issue with the old_select system call is that it is vulnerable to time-of-check-time-of-use (TOCTOU) race conditions. This means that it is possible for requests to be missed as the condition might already have changed before the timeout is set.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#related-events","title":"Related Events","text":"<ul> <li>new_select - The newer version of the select system call, which is not vulnerable to TOCTOU race conditions. </li> <li>poll - Function to monitor set of file descriptors for activity. </li> <li>epoll - Similar to the poll system call, but with better integration with the I/O event loop.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/","title":"oldfstat","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#intro","title":"Intro","text":"<p>oldfstat - use this function to get information about an open file</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#description","title":"Description","text":"<p>The oldfstat function is used to get information about an open file. This function is similar to fstat() which is used to get information about a file that is referred to by a file descriptor. oldfstat() is available on all UNIX-like systems for backwards compatibility and features a similar set of information about the open file. The main difference is that the user does not need to provide the file descriptor, instead of this it takes a file handle. If a process has permission to the file then the information will be used.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#arguments","title":"Arguments","text":"<ul> <li><code>fildes</code>:<code>int</code>[K-U] - an open file descriptor of the object to be stat'ed.</li> <li><code>buf</code>:<code>stat*</code>[K] - a pointer to a stat structure in which information is stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldfstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> <li>U - Originated from user space (for example, pointer to user space memory used to get it). </li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldfstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#sys_oldfstat","title":"<code>sys_oldfstat</code>","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#purpose","title":"Purpose","text":"<p>To track function calls and extract data from arguments to understand the behavior of a program.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor and collect information over time about the files used by a process. It can also be used to audit system programs' behaviors when we are suspicious about their access to the file.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#issues","title":"Issues","text":"<p>The oldfstat() does not support file descriptors greater than (USHRT_MAX + 1) and therefore, cannot be reliable for such system calls.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#related-events","title":"Related Events","text":"<ul> <li><code>fstat</code> - Similarly used to get information about a file, but takes a file descriptor as an argument. </li> <li><code>lstat</code> - Used to get information about a file from a symbolic link path.</li> <li><code>fstatat</code> - Used to get information about a file and takes a directory file descriptor as an argument.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/","title":"oldlstat","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#intro","title":"Intro","text":"<p>oldlstat - stat the file pointed to by pathname</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#description","title":"Description","text":"<p>oldlstat is used to return the status information about the file pointed to by the <code>pathname</code> argument. It return similar information as <code>lstat</code>, except if <code>pathname</code> is a symbolic link, it will return information about the link itself. Additionally, it will update the return value in <code>statbuf</code>, which is a pointer to <code>struct stat</code>.</p> <p>This event is useful to be used in programs that need to retrieve information about a file, but it is vulnerable to Time Of Check, Time of Use (TOCTOU) race condition.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K, U] - pointer to the pathname of the file for which status information will be returned.</li> <li><code>statbuf</code>:<code>struct stat*</code>[K] - pointer to a structure of type <code>struct stat</code> into which information should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldlstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldlstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#sys_oldlstat","title":"sys_oldlstat","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#purpose","title":"Purpose","text":"<p>The event is hooked with kprobes in order to observe and trace the syscall arguments and return value.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#example-use-case","title":"Example Use Case","text":"<p>This event can be used, for example, in an application to monitor file changes in the system.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#issues","title":"Issues","text":"<p>Due to the fact that this syscall is vulnerable to TOCTOU race condition, a malicious user could try to bypass the monitoring being done with this event, by changing the file parameters in between the time that it was checked and used.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#related-events","title":"Related Events","text":"<ul> <li><code>lstat</code> - similar event used to get information about files. Does not have the TOCTOU vulnerability.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/","title":"oldolduname","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#intro","title":"Intro","text":"<p>oldolduname - gets the legacy version of the system name</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#description","title":"Description","text":"<p>The oldolduname syscall obtains the system's legacy version of the name of the operating system running on the system. This name is a string that can contain a maximum of 8 characters and is displayed like <code>GECOS</code> (where the <code>OS/32</code> operating system got its name). This syscall, which is deprecated, should not be used in any production code and its use is discouraged. </p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>struct oldold_utsname*</code>[U] - pointer to a buffer of type <code>struct oldold_utsname</code> which will be populated with the system name. </li> </ul>"},{"location":"docs/events/builtin/syscalls/oldolduname/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldolduname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#_1","title":"","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#purpose","title":"Purpose","text":"<p>Hooking this syscall allows users to trace system information, such as getting the specific operating system name, when a process calls it.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#example-use-case","title":"Example Use Case","text":"<p>The oldolduname syscall can be used to figure out what legacy operating system the system is running on. It is particularly useful for debuggers and software that needs to identify what system they are running on. </p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#issues","title":"Issues","text":"<p>This syscall is deprecated, so its use is discouraged.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#related-events","title":"Related Events","text":"<p>uname - gets the system name and version information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/","title":"oldstat","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#intro","title":"Intro","text":"<p>oldstat - get file status (struct __old_kernel_stat) for the given filename</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#description","title":"Description","text":"<p>The oldstat system call retrieves the file status (the content of the struct __old_kernel_stat) for the given filename. It fills the given structure with information about the file, like permissions, ownership, size, etc. It is typically used to gather data about a file, before attempting to use it in any way. It is important to note that its results might be subject to change due to the condition of the system (e.g. the user running the oldstat call does not have read access to the requested file).</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>char*</code>[U] - Pointer to a buffer containing the name of the file whose status is to be retrieved.</li> <li><code>statbuf</code>:<code>struct __old_kernel_stat*</code>[K] - Pointer to the previously allocated oldstat buffer structure into which the status information should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#old_stat","title":"old_stat","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#purpose","title":"Purpose","text":"<p>To gather information on what files were requested and their stat information before they were found.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#example-use-case","title":"Example Use Case","text":"<p>For example, an admin logging tool may want to log the oldstat calls of a process to get information about which files were accessed by it.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#issues","title":"Issues","text":"<p>The information obtained from this event is only valid at the time of retrieval, meaning that subsequent changes to the file might have been made and yield unexpected results. Furthermore, the user running the oldstat system call must have read access to the requested file.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#related-events","title":"Related Events","text":"<p>The stat system call is a newer version of the oldstat system call and offers a more robust way of retrieving status about files. The syslog system call also provides information about files being accessed.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/olduname/","title":"olduname","text":""},{"location":"docs/events/builtin/syscalls/olduname/#intro","title":"Intro","text":"<p><code>olduname</code> - Returns sysname, nodename, release, version and machine information of the running system.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#description","title":"Description","text":"<p>The <code>olduname</code> syscall is used to get basic system information about the running Linux system, such as its kernel version and the architecture version of a running machine. This is the original version of the uname system call and its information might be less accurate than the more modern version of the system call. It is commonly used to retrieve a string describing the name and version of the system, which is returned in the kernel parameter <code>buf</code>.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct utsname*</code>[K,U] - Pointer to a <code>struct utsname</code> passed by the user to be used to store the system information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/olduname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/olduname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/olduname/#sys_olduname","title":"sys_olduname","text":""},{"location":"docs/events/builtin/syscalls/olduname/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/olduname/#purpose","title":"Purpose","text":"<p>Hooked to capture the system information for further investigation.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#example-use-case","title":"Example Use Case","text":"<p>One example use of the <code>olduname</code> system call is to retrieve the Linux kernel version running when a process is spawned. This can be used as an additional source of information to detect malicious activities.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#issues","title":"Issues","text":"<p>Most current Linux distributions use the newer version of the system call, so the information gathered from <code>olduname</code> might be limited.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#related-events","title":"Related Events","text":"<p><code>uname</code> - newer version of the system call used to look for system information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open/","title":"open","text":""},{"location":"docs/events/builtin/syscalls/open/#intro","title":"Intro","text":"<p>open - is a system call used to open the file specified by its filename</p>"},{"location":"docs/events/builtin/syscalls/open/#description","title":"Description","text":"<p>The purpose of open is to provide a system call to logicaly open a file in the file system. It might be important to keep in mind that the open call does not actually access the file in the system. Using the flags parameter, one could get different types of access rights to the file. One of the drawbacks of using open is that it is vulnerable to TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/open/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - The path to the file we want to open.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for the access. Used to set the access/permissions for the call.</li> <li><code>mode</code>:<code>mode_t</code>[K] - Control access to the opened file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open/#sys_open","title":"sys_open","text":""},{"location":"docs/events/builtin/syscalls/open/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/open/#purpose","title":"Purpose","text":"<p>To record every open system call, including its associated arguments.</p>"},{"location":"docs/events/builtin/syscalls/open/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor reads and writes to a specific file.</p>"},{"location":"docs/events/builtin/syscalls/open/#issues","title":"Issues","text":"<p>open could be very vulnerable to race-condition issues, as it is vulnerable to TOCTOU (Time Of Check, Time Of Use).</p>"},{"location":"docs/events/builtin/syscalls/open/#related-events","title":"Related Events","text":"<p>The related events for the open syscall are close(), read(), and write().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/","title":"open_by_handle_at","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#intro","title":"Intro","text":"<p>open_by_handle_at - open a file by a handle, based on a users data</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#description","title":"Description","text":"<p>The <code>open_by_handle_at()</code> system call is used to open a file given a file handle and mount point. The <code>open_by_handle_at()</code> call is similar to <code>openat()</code>, except that the former takes a file handle obtained from <code>name_to_handle_at()</code> instead of a pathname string.</p> <p>The <code>open_by_handle_at()</code> provides a flexible and fast way of creating new file descriptors for an existing file without the overhead of a file system lookup. It is, however, more fragile than <code>openat()</code> since the target file system may not be available in the same state when it is used for the later operation.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#arguments","title":"Arguments","text":"<ul> <li><code>mount_fd</code>:<code>int</code>[K] - file descriptor of the directory at which to open the handle. </li> <li><code>handle</code>: <code>struct file_handle*</code>[U] - pointer to the file handle that was acquired by the <code>name_to_handle_at</code> system call.</li> <li><code>flags</code>: <code>int</code>[K] - file status flags to use when opening the handle. This can be used to control the permissions of the file being opened. </li> </ul>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#purpose","title":"Purpose","text":"<p>Hooks are used to detect when the <code>open_by_handle_at()</code> syscall is called by userspace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#get_empty_filp","title":"get_empty_filp","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#type_1","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#purpose_1","title":"Purpose","text":"<p>Hooks are used to detect when the <code>open_by_handle_at()</code> syscall is setting up the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#example-use-case","title":"Example Use Case","text":"<p>The <code>open_by_handle_at()</code> system call can be used to open files from a remote network system without needing to obtain the path of the file.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#issues","title":"Issues","text":"<p>This system call is vulnerable to TOCTOU (time of check, time of use) attacks as the file handle may have been acquired from a different file system that may not be in the same state when the file is opened.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#related-events","title":"Related Events","text":"<ul> <li><code>openat()</code> - Open a file relative to a directory file descriptor</li> <li><code>name_to_handle_at()</code> - Convert a file name to handle</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/","title":"open_tree","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#intro","title":"Intro","text":"<p>open_tree - open a file relative to a directory file descriptor </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#description","title":"Description","text":"<p>open_tree is an Linux system call available since kernel 3.3. It can be used to open a file relative to an open directory file descriptor. It is similar to open but allows the opening of a file relative to an open directory file descriptor which can make the creation of an absolute path easier. </p> <p>Advantages of using this syscall include reducing the number of calls needed to build an absolute path.</p> <p>Drawbacks include lack of compatibility until kernel 3.3.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>int</code> - File descriptor of the directory used as base for the relative path of the file to open. </li> <li><code>filename</code>:<code>const char*</code> - The pathname relative to the directory referenced by the file descriptor.</li> <li><code>flags</code>:<code>unsigned int</code> [K] - Flags to be used when opening the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_tree/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_tree/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#type","title":"Type","text":"<p>kprobe </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#purpose","title":"Purpose","text":"<p>To get details about when, and with which arguments, open_tree is called. </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#example-use-case","title":"Example Use Case","text":"<p>open_tree is useful when particularially when the path of the file to open needs to be known before it is open, such as when opening a configuration file.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#issues","title":"Issues","text":"<p>Since open_tree is a relatively new system call, kernel versions before 3.3 do not support it.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#related-events","title":"Related Events","text":"<p>open: similar Linux system call for opening files, but does not support relative paths.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/openat/","title":"openat","text":""},{"location":"docs/events/builtin/syscalls/openat/#intro","title":"Intro","text":"<p>openat - The <code>openat(2)</code> system call is used to open a file relative to a directory file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/openat/#description","title":"Description","text":"<p><code>openat(2)</code> performs the same task as <code>open(2)</code>: it opens the file <code>pathname</code> (relative to the directory referred to by the file descriptor <code>dirfd</code>), but it can optionally provide the additional functionality of AT_SYMLINK_NOFOLLOW.</p> <p>The arguments are similar to <code>open(2)</code>: the <code>pathname</code> of the file to be opened, a flags <code>flags</code> and a mode <code>mode</code> to set it if it is created. The only difference is that the <code>dirfd</code> argument is a file descriptor of the directory that will serve as a prefix of the pathname. This allows <code>openat(2)</code> to be used in a thread-safe sequence of operations that all operate relative to the same directory.</p>"},{"location":"docs/events/builtin/syscalls/openat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - A file descriptor referring to the directory relative to which <code>pathname</code> is to be accessed. If <code>dirfd</code> is the special value <code>AT_FDCWD</code>, then <code>pathname</code> is relative to the current working directory.</li> <li><code>pathname</code>: <code>const char*</code>[K,U] - A pathname of the file to be opened.</li> <li><code>flags</code>: <code>int</code>[K] -File access mode and file status flags. This argument is a bit-mask created by ORing together the <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_APPEND</code>, <code>O_CREAT</code>, <code>O_EXCL</code>, <code>O_NOCTTY</code>, <code>O_TRUNC</code>, <code>O_DSYNC</code>, <code>O_DIRECTORY</code>, <code>O_NOFOLLOW</code>, <code>O_SYMLINK</code>, <code>O_CLOEXEC</code> and <code>O_NONBLOCK</code> flags.</li> <li><code>mode</code>: <code>mode_t</code>[K] -Mode of the created file. This argument must be supplied when <code>O_CREAT</code> is specified in flags. </li> </ul>"},{"location":"docs/events/builtin/syscalls/openat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/openat/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/openat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/openat/#purpose","title":"Purpose","text":"<p>Hooked to analyze the system call parameters.</p>"},{"location":"docs/events/builtin/syscalls/openat/#example-use-case","title":"Example Use Case","text":"<p><code>openat()</code> can be used to open a file in a secure manner, given that two file descriptors are available. The intention of <code>openat()</code> is that it can be used in a thread-safe sequence of operations that all operate relative to the same directory. A simple example of this is ensuring that a file is opened in the same directory as its parent, and not in another directory, even if the working directory has been changed in the meantime.</p>"},{"location":"docs/events/builtin/syscalls/openat/#issues","title":"Issues","text":"<p>Due to the fact that <code>openat()</code> uses an internal buffer to store the pathname, there is a potential vulnerability to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/openat/#related-events","title":"Related Events","text":"<p><code>creat(2)</code>, <code>open(2)</code>, <code>stat(2)</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/openat2/","title":"openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#intro","title":"Intro","text":"<p>openat2 - create a file with special options</p>"},{"location":"docs/events/builtin/syscalls/openat2/#description","title":"Description","text":"<p>The openat2() system call function creates a file and returns a file descriptor for it. It is similar to openat(), but allows more detailed control over the file's creation. The possible combination of how-&gt;flags and how-&gt;writes can be used to customize the properties of the file, like its permissions, ownership, and timestamps. The openat2() syscall also allows us to specify a size when creating the file, which is useful for creating files with non-zero size or preallocation.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - a file descriptor for a directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - a pointer to the pathname of the file to be opened, within the directory referred to by the dirfd argument.</li> <li><code>how</code>:<code>struct open_how*</code>[K] - a pointer to the structure describing how the file should be opened.</li> <li><code>size</code>:<code>size_t</code>[K] - the requested size of the opened file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/openat2/#openat2_1","title":"openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#type","title":"Type","text":"<p>TRAP</p>"},{"location":"docs/events/builtin/syscalls/openat2/#purpose","title":"Purpose","text":"<p>The openat2 system call is used to create a file. It is hooked to instrument the creation of files.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#sys_openat2","title":"sys_openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#type_1","title":"Type","text":"<p>KRETPROBE </p>"},{"location":"docs/events/builtin/syscalls/openat2/#purpose_1","title":"Purpose","text":"<p>The sys_openat2 system call is the kernel entrypoint for the openat2 system call. It is hooked to intercept and validate the arguments of the call before execution.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#example-use-case","title":"Example Use Case","text":"<p>openat2 can be used to create a hardlink to a file. By providing a pointer to a struct open_how as the \"how\" argument, we can create a link to a file, with specified ownership and permissions.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#issues","title":"Issues","text":"<p>Due to the nature of this system call, there is the risk of TOCTOU vulnerabilities. Care must be taken to make sure that the parameters are valid when they are checked and still valid when they are used.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#related-events","title":"Related Events","text":"<p>openat(), creat(), link(), unlink()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pause/","title":"Pause","text":""},{"location":"docs/events/builtin/syscalls/pause/#intro","title":"Intro","text":"<p>Pause - pauses the calling process until a signal is received.</p>"},{"location":"docs/events/builtin/syscalls/pause/#description","title":"Description","text":"<p>The pause() system call suspends the calling process until one of its child process terminates or a signal is received. If any of the currently pending signals have SIGCONT set as its action, pause() returns immediately. Any function that do not have SIGCONT as its action will suspend the process until a signal occurs.</p> <p>The pause() system call is used to synchronize a process with its child processes, so that when a child terminates, the parent can be notified. It is also used to temporarily suspend a process while signals are handled.</p>"},{"location":"docs/events/builtin/syscalls/pause/#arguments","title":"Arguments","text":"<ul> <li>None.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pause/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pause/#do_sys_pause","title":"do_sys_pause","text":""},{"location":"docs/events/builtin/syscalls/pause/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pause/#purpose","title":"Purpose","text":"<p>The do_sys_pause() function is the kernel entry point for the pause system call. Kprobes is used to hook this function to record system call parameters.</p>"},{"location":"docs/events/builtin/syscalls/pause/#example-use-case","title":"Example Use Case","text":"<p>The pause() system call could be used for throttling the current process before it runs a task.</p>"},{"location":"docs/events/builtin/syscalls/pause/#issues","title":"Issues","text":"<p>The pause() system call fails if any of the pending signals have SIGCONT as its action.</p>"},{"location":"docs/events/builtin/syscalls/pause/#related-events","title":"Related Events","text":"<ul> <li>signal()  -  send a signal to a process or process group</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/","title":"perf_event_open","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#intro","title":"Intro","text":"<p>perf_event_open - Used to start/stop a specific performance monitoring event on a specific CPU</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#description","title":"Description","text":"<p>The <code>perf_event_open system call</code> gives userspace the ability to request very specific performance monitoring events for a specific CPU. This syscall can be used to start and stop monitoring events, depending on the flags set when the syscall is called. It can also be used to group multiple performance monitoring events into a single group and therefore provide a combined report. This syscall has a few drawbacks, such as being susceptible to TOCTOU (time of check, time of use) attacks, as the application may not always be able to guarantee the same data as when the check was performed.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#arguments","title":"Arguments","text":"<ul> <li><code>attr</code>:<code>struct perf_event_attr*</code>[U] - User space memory buffer containing the definition of the performance event. The kernel will use this information to start/stop the performance event.</li> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the process where the event needs to be started or stopped. If set to \u2018-1\u2019, the event will be started or stopped on all processes (but not threads).</li> <li><code>cpu</code>:<code>int</code>[K] - CPU number on which the event needs to be started or stopped. If set to \u2018-1\u2019, the event will be started or stopped on all CPUs.</li> <li><code>group_fd</code>:<code>int</code>[U,K] - File descriptor associated with an event group (used to group multiple events into a single report). It is set to \u2018-1\u2019 if not part of an event group.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Flags that indicate whether to start or stop the event.</li> </ul>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#perf_event_open_1","title":"perf_event_open","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#purpose","title":"Purpose","text":"<p>To collect performance events for a specific process, CPU or event group.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#example-use-case","title":"Example Use Case","text":"<p>A user space application that needs to get detailed performance stats for one or multiple processes running on a CPU. This application can use the <code>perf_event_open</code> system call, with the appropriate attributes and flags, to get detailed performance stats for each process (or all processes, or a group of processes).</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#issues","title":"Issues","text":"<p>The application may be vulnerable to TOCTOU (time of check, time of use) attacks, as the data may change after the check is performed.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#related-events","title":"Related Events","text":"<ul> <li><code>perf_event_open</code></li> <li><code>perf_event_read</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/personality/","title":"personality","text":""},{"location":"docs/events/builtin/syscalls/personality/#intro","title":"Intro","text":"<p>personality - change the personality of the calling process</p>"},{"location":"docs/events/builtin/syscalls/personality/#description","title":"Description","text":"<p>The <code>personality</code> syscall is used to change the personality of the calling process. It can be used to provide the process with different versions of the Linux kernel API, allowing the process to run on different versions of Linux. The personality can also be used to change the behaviour of certain APIs, such as how signals are dispatched or whether threads are schedulable. It also determines which emulation mode the process uses. The personality specified by the argument is a bitmask, consisting of flags from <code>personality.h</code>.</p> <p>There are some drawbacks to changing the personality of a process. It can result in the process being unable to run on certain versions of the kernel, and some features of the kernel may be unavailable in certain personality modes.</p>"},{"location":"docs/events/builtin/syscalls/personality/#arguments","title":"Arguments","text":"<ul> <li><code>persona</code>: <code>unsigned long</code> - specifies the new personality for the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/personality/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/personality/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/personality/#sys_personality","title":"sys_personality","text":""},{"location":"docs/events/builtin/syscalls/personality/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/personality/#purpose","title":"Purpose","text":"<p>To track when processes change their personality.</p>"},{"location":"docs/events/builtin/syscalls/personality/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to ensure that processes do not run in an incompatible kernel version by maintaining a list of kernel versions permissible for the process, and setting the process's personality accordingly.</p>"},{"location":"docs/events/builtin/syscalls/personality/#issues","title":"Issues","text":"<p>If the specified personality has not been compiled into the running kernel, the syscall will fail with the <code>ENOSYS</code> error code.</p>"},{"location":"docs/events/builtin/syscalls/personality/#related-events","title":"Related Events","text":"<ul> <li><code>ptrace</code> - used for debugging and modifying processes</li> <li><code>clone</code> - used for creating processes with different personality settings</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/","title":"pidfd_getfd","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#intro","title":"Intro","text":"<p>pidfd_getfd - opens a file descriptor of the opened process by using pidfd</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#description","title":"Description","text":"<p>The pidfd_getfd syscall will take a pidfd input as well as a target file descriptor  number, targetfd. It will then open a file descriptor in the opened process  associated with targetfd. If the flags argument is set to be zero, it will open  the original file descriptor without any extra options. If set to O_CLOEXEC,  it will open the target file descriptor with the FD_CLOEXEC flag set.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code>[K] - File descriptor created by the pidfd_open syscall which references a process that is already opened.</li> <li><code>targetfd</code>:<code>int</code>[K] - File descriptor number to be opened in the already opened process.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags with which the file descriptor should be opened.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#__x64_sys_pidfd_getfd","title":"__x64_sys_pidfd_getfd","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#type","title":"Type","text":"<p>KProbes + KRetProbes</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#purpose","title":"Purpose","text":"<p>To capture and monitor processes via the pidfd_getfd syscall.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#example-use-case","title":"Example Use Case","text":"<p>One useful application of pidfd_getfd is to monitor the progress of a process.  By using it in conjunction with the pidfd_open syscall, it is possible to open  a file descriptor that references a process and then use the pidfd_getfd syscall  to open a file descriptor to the original file descriptor of the process.  This can then be used in an auditd system to check the stats of the process and  identify any potentially malicious activities.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#related-events","title":"Related Events","text":"<ul> <li>pidfd_open - Used to open a file descriptor to a process</li> <li>pidfd_send_signal - Used to send a signal to a process opened via pidfd_open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/","title":"pidfd_open","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#intro","title":"Intro","text":"<p>pidfd_open - open a PID file descriptor for the given process</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#description","title":"Description","text":"<p>The pidfd_open syscall allows users to obtain a file descriptor referring to the PID of the specified process. This syscall is useful in situations where one process needs access to the PID of another process in order to send signals, retrieve information about the process, or similar operations. It can also be used to monitor the lifetime of the process, since the file descriptor is closed when the process terminates. </p> <p>One of the use cases for pidfd_open is in containers that wish to move the management of their associated process to the kernel level. By using pidfd_open and then passing the resulting file descriptor to the kernel through pidfd_getfd, the application can ensure that it has proper control over the process and ensure that operations like signals and process management take effect atomically. </p> <p>There are some drawbacks to using pidfd_open. Since the file descriptor is closed when the process terminates, this can lead to race conditions if the process dies quickly. Additionally, pidfd_open can only be used with processes that the caller has permission to access, and if the caller does not have the necessary permissions, a permission denied error will be returned. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the process ID of the target process.</li> <li><code>flags</code>:<code>unsigned int</code> - a bitmask of flags that modify the functionality of the system call. </li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#pidfd_open_1","title":"pidfd_open","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#purpose","title":"Purpose","text":"<p>To monitor the opening of PID file descriptors and track the information associated with them.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#example-use-case","title":"Example Use Case","text":"<p>This syscall could be used in a multi-process application that needs to track the lifetimes of several processes or send signals to them. By obtaining a file descriptor for each process, the application can monitor their lifetimes and send signals in a safe and atomic manner. </p> <p>In addition, this syscall can also be used in a container context. By opening a PID file descriptor and passing it to the kernel through the pidfd_getfd syscall, the container can ensure that process management and signal delivery are handled in an atomic manner. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#issues","title":"Issues","text":"<p>This syscall is vulnerable to a time-of-check/time-of-use race condition. If the target process terminates quickly, it is possible that the file descriptor will be closed before the calling process can act on it. </p> <p>Additionally, since the caller must have permission to access the target process, this syscall may fail if the proper permissions are not set. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#related-events","title":"Related Events","text":"<ul> <li><code>pidfd_getfd</code> - gets the file descriptor of a process using a PID file descriptor</li> <li><code>pidfd_send_signal</code> - sends a signal to a process using a PID file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/","title":"pidfd_send_signal","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#intro","title":"Intro","text":"<p>The event <code>pidfd_send_signal</code> allows to send a signal to a specific process specified by a PID file descriptor, rather than its 'traditional' process ID. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#description","title":"Description","text":"<p>The <code>pidfd_send_signal()</code> syscall invokes <code>SIGSYS</code> on the process specified by the <code>pidfd</code> argument, and optionally with additional information from the <code>info</code>. Unlike the <code>kill()</code> syscall, this syscall can express the relative process hierarchy by passing the PID file descriptor instead of the real PID.</p> <p>The extra flags currently supported are <code>PIDFD_SEND_SIGCONT</code> and <code>PIDFD_SEND_SIGNAL_OWNER</code>, as specified in the <code>flags</code> argument. The former is used to inform the process waiting on a pidfd to continue its execution, while the latter is intended to allow a parent process to prevent other users on the same machine to interfere with the process group of the PID file descriptor.</p> <p>This syscall may be useful when there is a need to perform complex operations on a process or process group from a parent process. It also prevents race conditions which could occur between a child process being created and the parent process being notified of it, since the parent process can simply keep the PID trigger in a file descriptor and perform the action when signalled.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code> - the file descriptor of a file with a process ID indicating the specific process the signal will be sent to.</li> <li><code>sig</code>:<code>int</code> - the signal that will be sent to the process.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - Optional additional data, such as the pid of the process that sent the signal and the real uid, which is used to verify the sender's privileges.</li> <li><code>flags</code>:<code>unsigned int</code> - Set of flags which might change the behaviour of the syscall.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#send_signal","title":"send_signal","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#purpose","title":"Purpose","text":"<p>To handle the sending of signals.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#example-use-case","title":"Example Use Case","text":"<p>The <code>pidfd_send_signal</code> syscall can be used for process synchronization techniques, where a parent process can wait on a PID file descriptor to be signalled before being notified of the completion of a child process.</p> <p>This idea was inspired in part by <code>ptrace(2)</code>, which can be used to place a trace on a process group in order to observe its execution. However, <code>ptrace</code> also provides a means of signalling and process suspension features which are not necessary or desirable in certain types of applications.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#issues","title":"Issues","text":"<p>The implementation of this syscall currently has a bug which can cause some signals to be lost when sent to processes whose parent process is waiting for them.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#related-events","title":"Related Events","text":"<ul> <li><code>kill()</code> - sends the signal specified by <code>sig</code> to the process specified by <code>pid</code></li> <li><code>getpid()</code> - returns the process ID of the calling process.</li> <li><code>waitpid()</code> - suspends execution of the calling process until a child specified by <code>pid</code> terminates. </li> <li><code>ptrace()</code> - trace processes. It can be used to intercept, observe and manipulate the execution of process and its children.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pipe/","title":"pipe","text":""},{"location":"docs/events/builtin/syscalls/pipe/#intro","title":"Intro","text":"<p>pipe - creates a pipe, a unidirectional data channel that can be used for interprocess communication</p>"},{"location":"docs/events/builtin/syscalls/pipe/#description","title":"Description","text":"<p>Pipe is a system call that creates a unidirectional data channel for communication between two file descriptors.pipefd is an array of two integers, used to return two file descriptors referring to the ends of the pipe. The first file descriptor is for reading; the second file descriptor is for writing.</p> <p>Pipes are used for communication between two related processes, allowing them to exchange data between them. Pipes have the advantage of allowing data to be passed between the processes without having to be stored in memory. The limitation is that the data sent through a pipe can only be read once.</p> <p>As pipe() is a system call, it is vulnerable to TOCTOU attacks. This is because the file descriptor can be obtained on a pipe call and can be used until the pipe is closed.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#arguments","title":"Arguments","text":"<ul> <li><code>pipefd</code>:<code>int[2]</code>[K] - Used to return two file descriptors referring to the ends of the pipe. The first file descriptor is for reading; the second file descriptor is for writing.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pipe/#sys_pipe","title":"sys_pipe","text":""},{"location":"docs/events/builtin/syscalls/pipe/#type","title":"Type","text":"<p>Static analysis / kprobe</p>"},{"location":"docs/events/builtin/syscalls/pipe/#purpose","title":"Purpose","text":"<p>Hooked to monitor communication between processes, detect suspicious activity and detect TOCTOU vulnerability. </p>"},{"location":"docs/events/builtin/syscalls/pipe/#example-use-case","title":"Example Use Case","text":"<p>Pipe is used when two separate processes need to communicate. However, it can also be used as a debugging tool, by monitoring the data that is being passed through a pipe.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#issues","title":"Issues","text":"<p>The main issue with pipe is that the data can only be read once. This can cause issues when the reading process fails to read all of the data and it is discarded.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#related-events","title":"Related Events","text":"<ul> <li>read</li> <li>write</li> <li>select</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pipe2/","title":"pipe2","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#intro","title":"Intro","text":"<p>pipe2 - create a pipe and set its flags atomically</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#description","title":"Description","text":"<p>The pipe2() system call works similarly to pipe(), but it adds an extra argument flags, which contains the flags for opening the handle to the newly-created pipe. The flags argument is an OR-ed combination of the following ints: <code>O_CLOEXEC</code>, <code>O_NONBLOCK</code>, <code>O_DIRECT</code>. It is useful when the application is in a situation, where it might need to atomically create  a pipe, while setting some of its flags. </p>"},{"location":"docs/events/builtin/syscalls/pipe2/#arguments","title":"Arguments","text":"<ul> <li><code>pipefd</code>:<code>int[2]</code>[K] - Descriptor vector for the created pipe. The first element in the vector will refer to the read end of the pipe, while the second will refer to the write end. </li> <li><code>flags</code>:<code>int</code>[K] - flags to be used when opening the pipe. An OR-ed combination of <code>O_CLOEXEC</code>, <code>O_NONBLOCK</code>, <code>O_DIRECT</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#pipe2_1","title":"pipe2","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#purpose","title":"Purpose","text":"<p>To trace the system call pipe2 and its arguments</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#example-use-case","title":"Example Use Case","text":"<p>pipe2 can be used in a situation in which a process needs to create a pipe atomically, and set some of its flags. For example, named pipes (FIFOs) which are used for Inter Process Communication (IPC), need to be opened with the <code>O_NONBLOCK</code> flag in order to prevent blocking when there is no process connected to the other side. </p>"},{"location":"docs/events/builtin/syscalls/pipe2/#issues","title":"Issues","text":"<p>Zombie processes can appear if the write end of the pipe is not closed by any process.</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#related-events","title":"Related Events","text":"<ul> <li>open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/","title":"pivot_root","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#intro","title":"Intro","text":"<p>pivot_root - change the root file system of the current process</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#description","title":"Description","text":"<p>The pivot_root() system call makes the directory put_old the new root file system.  It moves the current root file system to the directory new_root.  This comparison is done by making the parent of the old PWD as the new PWD. </p> <p>pivot_root() is typically used in the final stages of a shift of a system into a chroot  environment. The old root directory is placed in put_old and can be used later to switch  back or unmount the old root directory (pivot/unpivot).</p> <p>The both directories must be on the same file system. This can also be used to change to  a different root file system if necessary.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#arguments","title":"Arguments","text":"<ul> <li><code>new_root</code>:<code>const char*</code>[K] - a pointer to a pathname of the new  directory  which  will  become  the  root  directory  (the  starting  point  for absolute paths).</li> <li><code>put_old</code>:<code>const char*</code>[K] - a pointer to a pathname of the directory which will be the new parent of the old root directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pivot_root/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pivot_root/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#sys_pivot_root","title":"sys_pivot_root","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#purpose","title":"Purpose","text":"<p>To audit attempts to pivot_root.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#example-use-case","title":"Example Use Case","text":"<p>When a process wants to enter a chroot jail for more security, it can use pivot_root() to change its root file system to the one inside the jail. </p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#issues","title":"Issues","text":"<p>pivot_root() cannot be used across file systems.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#related-events","title":"Related Events","text":"<p>chdir, chroot</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/","title":"pkey_alloc","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#intro","title":"Intro","text":"<p>pkey_alloc - allocate an protection key</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#description","title":"Description","text":"<p>The pkey_alloc system call is used to allocate a protection key; these are used to give a process access to privileges and other capabilities. The flags argument takes an ORed bitmask of options to control access to the key, such as whether or not it can be used with certain instructions like load_exclusive. The access_rights argument specifies the access rights allowed by the key, such as RWX (read-write-execute).</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned int</code> - the set of flags controlling access of the key.</li> <li><code>access_rights</code>:<code>unsigned long</code> - the set of access rights allowed by the key.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#pkey_alloc_1","title":"pkey_alloc","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#purpose","title":"Purpose","text":"<p>To monitor any syscall invocation of the function.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#example-use-case","title":"Example Use Case","text":"<p>Using pkey_alloc can be used to control which users have access to privileged instructions.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#related-events","title":"Related Events","text":"<p>The related system call for this event is pkey_free which is used to deallocate a protection key.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/","title":"pkey_free","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#intro","title":"Intro","text":"<p>pkey_free - frees an arch-specific key assigned to a memory address</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#description","title":"Description","text":"<p>pkey_free is a syscall which removes the architecture-specific protection key assigned to a memory address. The memory address associated with the protection key is then available to be accessed without any restrictions, and the protection key is freed from the table managed by the kernel.</p> <p>This syscall is necessary when dealing with memory regions where access needs to be restricted for particular users or tasks. This can be done by assigning an array of protection keys to a memory address. Access to this memory will then be restricted to those users and tasks that have been assigned the protection key.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#arguments","title":"Arguments","text":"<ul> <li><code>pkey</code>:<code>int</code>[K] - key to be freed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_free/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_free/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#pkey_free_1","title":"pkey_free","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#purpose","title":"Purpose","text":"<p>To monitor the freeing of protection keys by users or processes, as well as to detect any potential misuse.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#example-use-case","title":"Example Use Case","text":"<p>pkey_free can be used to enforce memory protection policies. For example, it can be used to restrict access to certain sensitive memory regions to a select group of users or tasks.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#related-events","title":"Related Events","text":"<ul> <li>pkey_alloc</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/","title":"pkey_mprotect","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#intro","title":"Intro","text":"<p>pkey_mprotect - change memory protections on a memory region protected by a protection key</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#description","title":"Description","text":"<p>pkey_mprotect is a Linux system call used to change the memory protection of a memory region so that it is bound to a protection key (pkey). As such, it works similarly to mprotect with the added protection that only if the application has the correct protection key it can access the memory region. This added security can be leveraged to protect copy-on-write functions and static data, allowing only authorized applications to access specific areas of process memory.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Pointer to the start of the memory region.</li> <li><code>len</code>:<code>size_t</code>[U] - Size of the memory region to be changed.</li> <li><code>prot</code>:<code>int</code>[U] - A combination of protection flags as described by the mprotect function.</li> <li><code>pkey</code>:<code>int</code>[U] - The protection key associated with the memory region.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#sys_pkey_mprotect","title":"sys_pkey_mprotect","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#purpose","title":"Purpose","text":"<p>Track calls to the <code>pkey_mprotect</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#example-use-case","title":"Example Use Case","text":"<p>The most common use for the <code>pkey_mprotect</code> syscall is to protect copy-on-write functions from unauthorized use. A process can set a memory region protected by a specific protection key, thus only calls from processes with the correct key can access that region.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#issues","title":"Issues","text":"<p>No documented issues. </p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#related-events","title":"Related Events","text":"<p>The <code>pkey_alloc</code> syscall is used to allocate protection keys. The <code>pkey_free</code> syscall is used to programmatically free protection keys which are no longer in use.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/poll/","title":"poll","text":""},{"location":"docs/events/builtin/syscalls/poll/#intro","title":"Intro","text":"<p>poll() - waits for one of a set of file descriptors to become ready to perform I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/poll/#description","title":"Description","text":"<p>The poll() system call is a method of multiplexing a process across several input-output operations. It allows a process to wait for events or data to become available on one or more files or file-descriptors before continuing execution. </p> <p>Certain edge-cases can cause blocking and other issues. Since the process is attempting to read multiple file descriptors, if one of them is blocked, the entire system call may become blocked as a result. Also since the poll() syscall relies on the kernel to inform of changes in the files, there is potential for TOCTOU (Time Of Check, Time Of Use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/poll/#arguments","title":"Arguments","text":"<ul> <li><code>fds</code>:<code>struct pollfd*</code>[U] - Array of pollfd  data structures.</li> <li><code>nfds</code>:<code>unsigned int</code>[U] - Number of file descriptors contained in fds.</li> <li><code>timeout</code>:<code>int</code>[OPT] - The timeout, in milliseconds. A timeout value of 0 causes poll to return immediately, while a value of -1 means an infinite timeout.</li> </ul>"},{"location":"docs/events/builtin/syscalls/poll/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/poll/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/poll/#syscall_entry_poll","title":"syscall_entry_poll","text":""},{"location":"docs/events/builtin/syscalls/poll/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/poll/#purpose","title":"Purpose","text":"<p>Monitor the entry to the poll syscall in order to capture the arguments passed in.</p>"},{"location":"docs/events/builtin/syscalls/poll/#example-use-case","title":"Example Use Case","text":"<p>In a system which needs to monitor multiple file descriptors for events, poll() can be used instead of continually checking each file descriptor to be ready for I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/poll/#issues","title":"Issues","text":"<p>The biggest issue is that of TOCTOU attacks, since the kernel can itself be exploited to modify the information on the file descriptor before the poll syscall ends.</p>"},{"location":"docs/events/builtin/syscalls/poll/#related-events","title":"Related Events","text":"<p>select(), epoll(), muxed poll()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/","title":"ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#intro","title":"Intro","text":"<p>ppoll - poll file descriptors with a timeout given with nanosecond precision</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#description","title":"Description","text":"<p>ppoll is a Linux syscall that polls a list of file descriptors provided in a struct pollfd array with the expectation of a response within a given timespec timeout. It also serves to allow certain interrupts or signals to be temporarily ignored while ppoll is running. It is very similar to the poll syscall but with the timespec capability for nanosecond level timeouts.</p> <p>The advantages of using ppoll over poll are that it can provide a much finer grained control when setting a timeout, and can block signals from interrupting it while it runs. The main potential drawback is that since it is a newer syscall, it may not be supported by all distributions.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#arguments","title":"Arguments","text":"<ul> <li><code>fds</code>:<code>struct pollfd*</code>[K] - Pointer to the array of pollfd structures.</li> <li><code>nfds</code>:<code>unsigned int</code>[K] - Number of pollfd structures in the array.</li> <li><code>tmo_p</code>:<code>struct timespec*</code>[K] - Pointer to an object of type timespec that specifies the maximum amount of time (in nanoseconds) that the call will block waiting for a response.</li> <li><code>sigmask</code>:<code>const sigset_t*</code>[K] - Optional pointer to a signal set that is carefully managed while ppoll is running, to prevent system interrupts (such as signals) from interfering with the response time of the call.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - Optional value for size of the sigmask. If a sigmask is passed in, then sigsetsize must provide the size of the sigmask including any padding.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#do_sys_ppoll","title":"do_sys_ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#type","title":"Type","text":"<p>TRACE_IRQS_OFF</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#purpose","title":"Purpose","text":"<p>Hooks the functions that handles the <code>ppoll</code> syscall, to allow for monitoring its execution.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#example-use-case","title":"Example Use Case","text":"<p>A process needs to read multiple files concurrently but not take too long to return a result. ppoll could be used with short timeout values to make sure that the call doesn't wait too long on any single file, while still allowing it to monitor multiple files.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#issues","title":"Issues","text":"<p>Since ppoll is a relatively new syscall, there may be compatibility issues when running on older versions of Linux that don't support it. Additionally, the fine-grained timeout values may not work on certain systems, especially when those systems use slower hard drives.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#related-events","title":"Related Events","text":"<p>poll - simpler syscall performing similar action without nanosecond-level timeouts</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/","title":"ppoll_time32","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#intro","title":"Intro","text":"<p>The <code>ppoll_time32</code> system call is used to poll the given file descriptor sets with the given timeout value in a Linux-based system.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#description","title":"Description","text":"<p>The <code>ppoll_time32</code> system call is used to poll for activity on a set of file descriptors specified by an array of <code>struct pollfd</code> structures. The call will wait for a specified timeout period, given in an old Linux <code>struct old_timespec32</code> structure, for activity on any of the descriptors to occur and then return. If the <code>sigmask</code> pointer is non-null, the call will block all signals in the given sigset while polling.</p> <p>The call will return the number of file descriptors selected or zero if the timeout expired. It will return <code>-1</code> and set <code>errno</code> in case of errors.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#arguments","title":"Arguments","text":"<ul> <li><code>ufds</code>:<code>struct pollfd*</code>[KU] - Pointer to an array of <code>struct pollfd</code> structures containing the file descriptors, a list of events and a list of returned events.</li> <li><code>nfds</code>:<code>unsigned int</code>[K] - The number of items in the array of <code>struct pollfd</code> structures.</li> <li><code>tsp</code>:<code>struct old_timespec32*</code>[K] - Pointer to a <code>struct old_timespec32</code> containing the timeout period.</li> <li><code>sigmask</code>:<code>sigset_t*</code>[K] - Pointer to a <code>sigset_t</code> containing the list of signals to block while polling.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - Size of the given sigset.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user-space (for example, pointer to user space memory used to get it).</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#do_ppoll","title":"do_ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#type","title":"Type","text":"<p>kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#purpose","title":"Purpose","text":"<p>Hooks the <code>do_ppoll</code> function to trace the <code>ppoll_time32</code> system call. </p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#example-use-case","title":"Example Use Case","text":"<p>The <code>ppoll_time32</code> system call can be used in a multi-threaded application to safely query the status of a large number of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#issues","title":"Issues","text":"<p>The <code>ppoll_time32</code> system call is vulnerable to TOCTOU (time of check, time of use) attacks. This means that an attacker may be able to manipulate the content of the <code>struct pollfd</code> structures between the time they are checked by the <code>ppoll_time32</code> system call and the time they are actually used.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#related-events","title":"Related Events","text":"<ul> <li><code>poll_time32</code> - Similar system call used for polling file descriptors.</li> <li><code>ppoll</code> - Similar modern system call used for polling file descriptors.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/prctl/","title":"prctl","text":""},{"location":"docs/events/builtin/syscalls/prctl/#intro","title":"Intro","text":"<p>prctl - function that allows to set certain process and resource limits.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#description","title":"Description","text":"<p>The prctl() call is a function provided by the Linux kernel that allows a process to set various limits and control flags on itself, as well as retrieve various information about the process or its current resource limits. Additionally it can be used to remove the capability to send signals to the process.</p> <p>The main purpose of the prctl() call is to give the process more control over its environment. This can be especially useful for process tracing tools, as it allows for more reliable tracking of process resources.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - the operation to perform. </li> <li><code>arg2</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg3</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg4</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg5</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prctl/#sys_prctl","title":"sys_prctl","text":""},{"location":"docs/events/builtin/syscalls/prctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/prctl/#purpose","title":"Purpose","text":"<p>To trace the prctl system call.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#example-use-case","title":"Example Use Case","text":"<p>For example, a process can use the prctl() call to add/remove memory limits, limit the number of open files, set the process name, or to alter the process's virtual memory size. </p>"},{"location":"docs/events/builtin/syscalls/prctl/#issues","title":"Issues","text":"<p>Since the procedure is relatively complex and lengthy, it can be slow and unsafe when used to execute a task in critical paths. The calling program can be more prone to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#related-events","title":"Related Events","text":"<p>sys_exit, set_on_exit, duplicate_process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pread64/","title":"pread64","text":""},{"location":"docs/events/builtin/syscalls/pread64/#intro","title":"Intro","text":"<p>pread64 - read up to count bytes from file descriptor fd at offset offset</p>"},{"location":"docs/events/builtin/syscalls/pread64/#description","title":"Description","text":"<p>The pread64() system call reads up to <code>count</code> bytes from file descriptor <code>fd</code> at offset <code>offset</code>. It is identical to <code>read</code> except for the checking for a file descriptor that supports <code>pread</code> and the <code>offset</code> parameter.</p> <p>Unlike <code>read</code> the data is not read from the current file offset; instead, <code>offset</code> byteswithe counted from the start of the file.</p> <p>If some bytes were read before and <code>O_APPEND</code> was not set on the file descriptor, subsequent reads are made from the position which was 'current' at the time pread64() has been called. If the file was open with <code>O_APPEND</code> set, the data will be read from the current end of file.</p> <p>The pread64() system call does not change the file offset and it is not affected by whether or not <code>O_APPEND</code> is set on the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int - file descriptor of the file to be read</li> <li><code>buf</code>:void*[K] - a pointer to a buffer in which the data should be stored</li> <li><code>count</code>:size_t - the number of bytes to be read</li> <li><code>offset</code>:off_t - offset from the start of the file</li> </ul>"},{"location":"docs/events/builtin/syscalls/pread64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/pread64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pread64/#sys_pread64","title":"sys_pread64","text":""},{"location":"docs/events/builtin/syscalls/pread64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pread64/#purpose","title":"Purpose","text":"<p>To trace reads from the start of a file.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#example-use-case","title":"Example Use Case","text":"<p>A security audit might need to track activity that reads from the beginning of files. </p>"},{"location":"docs/events/builtin/syscalls/pread64/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#related-events","title":"Related Events","text":"<ul> <li>read</li> <li>pread2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/preadv/","title":"preadv","text":""},{"location":"docs/events/builtin/syscalls/preadv/#intro","title":"Intro","text":"<p>preadv - read data from a file descriptor into multiple vectors.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#description","title":"Description","text":"<p>preadv() allows the user to read data from a file descriptor into multiple vectors. It acts like a combination of the read() and lseek() system calls: it reads data from a given position in a file as specified by the pos_h and pos_l arguments and stores it in the buffers which are provided.</p> <p>The size of the data that is read is determined by the sum of the lengths of all the individual iov buffers. If the sum is greater than SSIZE_MAX, then the value stored in errno is set to EINVAL and -1 is returned. Additionally, preadv() can read less than the amount requested if the data is not present in the file.</p> <p>Preadv() respects file positioning flags such as O_APPEND and O_DIRECT. These flags are taken into consideration when determining the position from which data is read.</p> <p>Preadv() is atomic; when multiple threads/processes simultaneously try to read the same file, they will be guaranteed to read the correct data.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - file descriptor referring to a file which is to be read.</li> <li><code>iov</code>:const struct iovec*[K] - pointer to an array of struct iovec. Each element describes the destination buffer in which data will be stored. </li> <li><code>iovcnt</code>:unsigned long[K] - number of elements in iov array.</li> <li><code>pos_l</code>:unsigned long[K] - least significant 32 bits of file offset from which the data will be read. </li> <li><code>pos_h</code>:unsigned long[K] - most significant 32 bits of file offset from which the data will be read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/preadv/#syscall-preadv","title":"Syscall preadv:","text":""},{"location":"docs/events/builtin/syscalls/preadv/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/preadv/#purpose","title":"Purpose","text":"<p>To monitor calls to preadv and collect data about these calls.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#example-use-case","title":"Example Use Case","text":"<p>For example, preadv can be used to securely read metadata from a file on disk.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#issues","title":"Issues","text":"<p>Since preadv does not provide meaningful feedback when the data is not present in the file, it may be difficult to detect errors in the process of reading data.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#related-events","title":"Related Events","text":"<p>pread,pread64,writev,writev64.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/","title":"Preadv2","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#intro","title":"Intro","text":"<p>Preadv2 - read data from a file descriptor into multiple memory areas at a given position.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#description","title":"Description","text":"<p>Preadv2 reads iovcnt buffers from the file associated with the file descriptor fd into the structures pointed to by iov. The pos_l and pos_h arguments are taken together to form a 64-bit value that specifies the location in the file (offset) from which the data is to be read. By using <code>preadv2</code> the position of the file descriptor is left unchanged. The flags argument is a bit mask composed of the bitwise OR of zero or more of the following commands.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - File descriptor for the file to read from.</li> <li><code>iov</code>: <code>const struct iovec*</code> - Pointer to an array of <code>iovec</code>  structures pointing to the buffer where the data should be read into.</li> <li><code>iovcnt</code>: <code>unsigned long</code> - Number of elements in the iov buffer.</li> <li><code>pos_l</code>: <code>unsigned long</code> - Lower 32-bits of the 64-bit offset value.</li> <li><code>pos_h</code>: <code>unsigned long</code> - Higher 32-bits of the 64-bit offset value.</li> <li><code>flags</code>: <code>int</code> - Bitmask of options describing whether <code>preadv2</code> or <code>preadv2</code> should be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#sys_preadv2","title":"sys_preadv2","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#type","title":"Type","text":"<p>kprobe + fentry.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#purpose","title":"Purpose","text":"<p>To monitor the syscalls related to reading data from the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#example-use-case","title":"Example Use Case","text":"<p>Preadv2 can be used to read from a large file into multiple smaller buffers. It is useful for copying files, as seek and read don't need to be called for each read. It is also useful for applications that want to read a lot of data from a file in parallel.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#issues","title":"Issues","text":"<p>The flags argument is not yet supported in glibc.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#related-events","title":"Related Events","text":"<ul> <li>preadv</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/","title":"prlimit64","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#intro","title":"Intro","text":"<p>prlimit64 - manipulate resource limits of a process</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#description","title":"Description","text":"<p>The prlimit64() system call is used to both set and get the resource limits of a process. It is similar to the setrlimit and getrlimit functions but it can handle larger numerical values when specifying a resource limit. Resource limits can be set per user, and are a mechanism to prevent processes from using toomuch memory, growing too large, creating too many threads or processes, or creating files that are too large. It is important to note that this system call only changes the limits in the current process and not in any other processes that belong to the same user.</p> <p>There are some edge cases to be aware of. It is possible to set a limit that is lower than the current limit. In this case, the limit will remain the same. It is also possible to set a limit that is lower than the current usage. In this case, the process will be terminated. Finally, it is not possible to set a limit for another user using this system call.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the process ID of the process to change the limit for. If set to 0, it will default to the current process.</li> <li><code>resource</code>:<code>int</code> - the resource whose limit is being set/gotten. Examples are RLIMIT_AS (address space size of the process), RLIMIT_CORE (maximum size of core file that process can create), and RLIMIT_NOFILE (maximum number of open files). </li> <li><code>new_limit</code>:<code>const struct rlimit64*</code> - a pointer to a rlimit64 structure which contains the new limit value to set.</li> <li><code>old_limit</code>:<code>struct rlimit64*</code> - optionally, a pointer to a rlimit64 structure which the current limit will be copied into. </li> </ul>"},{"location":"docs/events/builtin/syscalls/prlimit64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/prlimit64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#sys_prlimit64","title":"sys_prlimit64","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#purpose","title":"Purpose","text":"<p>To track when the resource limits of a process are set and getting</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#example-use-case","title":"Example Use Case","text":"<p>A process monitoring system could use this event to mark when the resource limits of a process are changed in order to be aware of when a process is requesting more resources </p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#issues","title":"Issues","text":"<p>Since the new and old limit are stored in user-space provided pointers, they are vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#related-events","title":"Related Events","text":"<p>sys_setrlimit / getrlimit - the 32-bit versions of the same functions.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/","title":"process_madvise","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#intro","title":"Intro","text":"<p>process_madvise - system call applied to a specific process that provides information about the process' memory layout to the kernel</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#description","title":"Description","text":"<p>process_madvise is used to provide information about a process's memory layout to the kernel. This call is necessary for some of the more advanced memory management techniques in the kernel, such as transparent huge pages. It can also be used to advise the kernel on what kind of page replacement algorithm may be suitable for a process' memory (e.g. LRU or random). </p> <p>There are some drawbacks and advantages to using process_madvise. The main advantage is that it gives the kernel more insight into the process\u2019s memory layout, and allows for more effective memory management. The main drawback is that the process must call process_madvise for each region of memory it uses, which can slow down its execution.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>: <code>int</code> - a file descriptor for the process being analyzed.</li> <li><code>addr</code>: <code>void*</code> - address of the page within the process that is being analyzed.</li> <li><code>length</code>: <code>size_t</code> - size of the page that is being analyzed.</li> <li><code>advice</code>: <code>int</code> - advice provided to the kernel about the page.</li> <li><code>flags</code>: <code>unsigned long</code> - flags that control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_madvise/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_madvise/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#do_process_madvise","title":"do_process_madvise","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#purpose","title":"Purpose","text":"<p>To monitor the process_madvise syscall and get information about the process being analyzed.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#example-use-case","title":"Example Use Case","text":"<p>The process_madvise system call could be used to provide the kernel with information about a process's memory layout when a process is initialized or when it is about to exit. This information can then be used by the kernel to make decisions about memory management, such as which page replacement algorithm to use or when to use transparent huge pages.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#issues","title":"Issues","text":"<p>process_madvise has had some minor security issues in the past, such as the potential for kernel memory disclosure and a TOCTOU (time of check, time of use) vulnerability, but these have been addressed in recent kernel versions.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#related-events","title":"Related Events","text":"<p>The process_madvise system call is related to other memory management system calls, such as madvise, mincore, and mprotect. It is also related to other process-specific system calls, such as process_setrlimit or process_prctl.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/","title":"process_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#intro","title":"Intro","text":"<p>process_mrelease - allows releasing memory from mlock()/mlock2().</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#description","title":"Description","text":"<p>process_mrelease is used to release homogeneous memory locked using mlock() or mlock2(). It accepts two parameters: pidfd of type int, which is the PID of the process whose memory is to be released, and flags of type unsigned int, which is used to set flags to determine the behaviour of the syscall. The advantage of using process_mrelease over mlock()/mlock2() is that it offers more fine-grained control; however, a drawback is that it can only be used on homogeneous memory.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code>[K] - A file descriptor referring to the process whose memory is to be released. </li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags that can be used to alter the behaviour of the syscall. The flags must be provided as a bit mask, which can be ORed together.</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#do_mrelease","title":"do_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#type","title":"Type","text":"<p>Tracepoint probes</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#purpose","title":"Purpose","text":"<p>To monitor and trace a successful process mrelease call.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#sys_process_mrelease","title":"sys_process_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#type_1","title":"Type","text":"<p>Kprobe probes</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#purpose_1","title":"Purpose","text":"<p>To monitor and trace the entry and exit of a process mrelease call.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#example-use-case","title":"Example Use Case","text":"<p>A use case for process_mrelease would be for memory locking applications. An application could monitor memory usage changes, and if a certain threshold is met, it could call process_mrelease to release any memory that was locked using mlock()/mlock2().</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#issues","title":"Issues","text":"<p>The only issue with process_mrelease is that it can only be used with homogeneous memory. If the memory locked was not homogeneous, the syscall will not succeed.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#related-events","title":"Related Events","text":"<ul> <li>mlock() </li> <li>munlock()</li> <li>mlock2()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/","title":"process_vm_readv","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#intro","title":"Intro","text":"<p>process_vm_readv - transfer data between the address spaces of two processes.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#description","title":"Description","text":"<p>The <code>process_vm_readv()</code> system call is designed to perform a vectorized read from a specified process's address space, transferring data to another process's address space without the need for intermediate buffers or filesystem-based methods. This is primarily utilized for cross-process memory access, such as debugging tools or some specialized inter-process communication techniques.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the target process from which data is to be read.</li> <li><code>local_iov</code>:<code>struct iovec *</code>[U] - Pointer to an array of <code>iovec</code> structures that determine the local memory segments.</li> <li><code>liovcnt</code>:<code>unsigned long</code>[K] - Number of elements in <code>local_iov</code>.</li> <li><code>remote_iov</code>:<code>struct iovec *</code>[U] - Pointer to an array of <code>iovec</code> structures that determine the remote memory segments in the target process.</li> <li><code>riovcnt</code>:<code>unsigned long</code>[K] - Number of elements in <code>remote_iov</code>.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Flag bits to modify operation (usually set to 0).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#sys_process_vm_readv","title":"sys_process_vm_readv","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#purpose","title":"Purpose","text":"<p>To monitor and trace when the <code>process_vm_readv()</code> system call is executed, capturing details about the source and target memory regions and the processes involved.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#example-use-case","title":"Example Use Case","text":"<p>Building a debugging or monitoring tool that requires direct reading of memory from a target process without inducing significant overhead or relying on file-based methods.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#issues","title":"Issues","text":"<p><code>process_vm_readv()</code> could be exploited in specific scenarios where unauthorized memory access is attempted. Proper permissions and checks should always be in place to avoid unintended data leaks or security implications.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#related-events","title":"Related Events","text":"<ul> <li><code>process_vm_writev()</code> - Transfer data to the address space of another process.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/","title":"process_vm_writev","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#intro","title":"Intro","text":"<p>process_vm_writev - transfer data between the address spaces of two processes.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#description","title":"Description","text":"<p>The <code>process_vm_writev()</code> system call facilitates a vectorized write to a specified process's address space from another process's address space, enabling direct memory-to-memory data transfers. Like its counterpart <code>process_vm_readv()</code>, this syscall provides a mechanism for direct inter-process memory access, which is particularly beneficial for debugging tools or certain specialized inter-process communication methods.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the target process to which data is to be written.</li> <li><code>local_iov</code>:<code>struct iovec *</code>[U] - Pointer to an array of <code>iovec</code> structures indicating the local memory segments.</li> <li><code>liovcnt</code>:<code>unsigned long</code>[K] - Number of elements in <code>local_iov</code>.</li> <li><code>remote_iov</code>:<code>struct iovec *</code>[U] - Pointer to an array of <code>iovec</code> structures pointing to the remote memory segments in the target process.</li> <li><code>riovcnt</code>:<code>unsigned long</code>[K] - Number of elements in <code>remote_iov</code>.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Flag bits to modify operation (typically set to 0).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#sys_process_vm_writev","title":"sys_process_vm_writev","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#purpose","title":"Purpose","text":"<p>To monitor and capture instances when the <code>process_vm_writev()</code> system call is invoked, detailing the source and destination memory regions and the processes involved.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#example-use-case","title":"Example Use Case","text":"<p>Crafting a tool or utility that necessitates direct writing to the memory of a target process, bypassing file-based methods or other indirect techniques. This is seen in some advanced debugging or monitoring tools.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#issues","title":"Issues","text":"<p>The use of <code>process_vm_writev()</code> can introduce security risks, especially when not appropriately guarded. Unauthorized memory writes can compromise process integrity, and as such, proper permissions and checks must always be enforced to prevent malicious actions.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#related-events","title":"Related Events","text":"<ul> <li><code>process_vm_readv()</code> - Transfer data from the address space of another process.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/prof/","title":"prof","text":""},{"location":"docs/events/builtin/syscalls/prof/#intro","title":"Intro","text":"<p>prof - Event triggered when profiler events are enabled or disabled.</p>"},{"location":"docs/events/builtin/syscalls/prof/#description","title":"Description","text":"<p>The <code>prof</code> event is triggered when profiler events are enabled or disabled. It is used to enable and disable per-process event profiling, which is used to measure the performance and execution of a given process. The <code>prof</code> event allows for fine-grained control over the events that are monitored, allowing for granular tracking of process behavior. </p> <p>The <code>prof</code> event has several drawbacks and edge-cases. Since it is specific to the process being monitored, it can be potentially slow to set up and can have unexpected side-effects on the process performance when enabled. Additionally, since the event is being monitored at the process level, it may be dependent on the type of process being monitored. </p>"},{"location":"docs/events/builtin/syscalls/prof/#arguments","title":"Arguments","text":"<ul> <li><code>FLAGS</code>: <code>unsigned long</code>[K] - Flags to configure the event profiling.</li> <li><code>EVENTS</code>: <code>unsigned int</code>[K] - Array of events to monitor while profiling.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prof/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/prof/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prof/#sched_process_exec","title":"sched_process_exec","text":""},{"location":"docs/events/builtin/syscalls/prof/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prof/#purpose","title":"Purpose","text":"<p>Hook the <code>sched_process_exec</code> function to enable and disable the profiler events when the process executes.</p>"},{"location":"docs/events/builtin/syscalls/prof/#do_exit","title":"do_exit","text":""},{"location":"docs/events/builtin/syscalls/prof/#type_1","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prof/#purpose_1","title":"Purpose","text":"<p>Hook the <code>do_exit</code> function to shutdown the profiler before exiting the process.</p>"},{"location":"docs/events/builtin/syscalls/prof/#example-use-case","title":"Example Use Case","text":"<p>The <code>prof</code> event can be used to measure the performance or track the execution of specific processes on the system. It's commonly used in embedded and real-time applications where precise performance measurements are necessary. </p>"},{"location":"docs/events/builtin/syscalls/prof/#issues","title":"Issues","text":"<p>The <code>prof</code> event is highly process-dependent and can lead to unexpected performance issues or decreased efficiency when enabled. Additionally, because it requires a precise setup across the entire stack, it can be slow to configure and start. </p>"},{"location":"docs/events/builtin/syscalls/prof/#related-events","title":"Related Events","text":"<p>The <code>prof</code> event is related to the <code>perf</code> event, which is used to observation of hardware performance counters.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/profil/","title":"profil","text":""},{"location":"docs/events/builtin/syscalls/profil/#intro","title":"Intro","text":"<p>profil - write execution times of processes/threads to a buffer</p>"},{"location":"docs/events/builtin/syscalls/profil/#description","title":"Description","text":"<p>The profil system call is used to write the execution times of a programs or threads to a user-specified buffer. It can be used to identify code paths which are heavily used or those that are less efficient. It has been largely replaced by existing performance analysis tools like perf and flame graphs.</p> <p>Edge-cases should be taken into account when using the profil system call. The user-specified buffer will eventually fill up and depending on what kernel version is running, this can cause program terminating signals as the end of the buffer is hit. It is therefore important to make sure that the buffer used is large enough to avoid this case.</p>"},{"location":"docs/events/builtin/syscalls/profil/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:pointer[U] - the address of the buffer in the user memory.</li> <li><code>buflen</code>:unsigned int[U] - the size of the buffer in bytes.</li> <li><code>offset</code>:unsigned int[U] - the offset from the beginning of the buffer to start writing from. This should be no bigger than <code>buflen</code>.</li> <li><code>scale</code>:unsigned int[U] - the size of the scale to store the information. A scale of five, for example, would store the value in five-microsecond intervals.</li> <li><code>pc</code>:unsigned long[K] - the base address of the program counter used by the kernel for the profiling.</li> </ul>"},{"location":"docs/events/builtin/syscalls/profil/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/profil/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/profil/#sys_profil","title":"sys_profil","text":""},{"location":"docs/events/builtin/syscalls/profil/#type","title":"Type","text":"<p>Kprobe+kretprobe</p>"},{"location":"docs/events/builtin/syscalls/profil/#purpose","title":"Purpose","text":"<p>Assessing the performance of a user-space program or thread.</p>"},{"location":"docs/events/builtin/syscalls/profil/#example-use-case","title":"Example Use Case","text":"<p>Profiling and examining the performance of a given application or thread. </p>"},{"location":"docs/events/builtin/syscalls/profil/#issues","title":"Issues","text":"<p>The <code>buflen</code> and <code>offset</code> parameters are user-specified and there is no limit checking on the kernel side, so care must be taken when using them, and the size of the buffer should be sutable large enough to avoid running out of space during use.</p>"},{"location":"docs/events/builtin/syscalls/profil/#related-events","title":"Related Events","text":"<ul> <li>fork </li> <li>execve </li> <li>setitimer</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/","title":"pselect6","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#intro","title":"Intro","text":"<p>pselect6 - the Linux system call that syntactically combines select() and pselect() system calls.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#description","title":"Description","text":"<p>pselect6 is the Linux system call that syntactically combines select() and pselect() system calls. This system call can be used to select or monitor many files or sockets for readability, writability, prior-to-termination conditions etc. It can also optionally monitor a set of signal numbers for presence in the caller's signal mask without temporarily replacing the signal mask.</p> <p>The pselect6 system call takes 6 parameters. The first parameter is an integer, which specifies the maximum of the number of file descriptors in any of the three sets (readfds, writefds, exceptfds). The second, third and fourth parameters are pointers to sets of file descriptors (readfds, writefds, exceptfds). The fifth argument is a pointer to a timeval structure which specifies the absolute or relative timeout time. The sixth argument is a pointer to a signal set, or a null pointer, which specify the set of signals to be monitored for any pending signal during the monitor time.</p> <p>Once pselect6 is called, it will monitor all the file descriptors which are in the three sets until a file descriptor becomes \u2018ready\u2019 or a timeout occurs or a signal becomes \u2018pending.\u2019 When one of these events happens, the pselect6 returns to the caller with the ready filed descriptors and updated signal masks.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:<code>int</code>[K] - an integer specifying the maximum number of file descriptors in the set of files to monitor.</li> <li><code>readfds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for readability.</li> <li><code>writefds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for writability.</li> <li><code>exceptfds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for exceptional conditions.</li> <li><code>timeout</code>:<code>struct timespec*</code>[U] - Pointer to a time structure which specifies the absolute or relative timeout time.</li> <li><code>sigmask</code>:<code>void*</code>[K] - Pointer to a signal set or NULL. If not NULL, specifies the set of signals to be monitored for any pending signal during the monitor wait. If a signal is pending, pselect6 will return with an EINTR error code and will fill the sigmask parameter with the set of pending signals.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#do_syscall_64","title":"do_syscall_64","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#purpose","title":"Purpose","text":"<p>To monitor for calls to the system call related to pselect6.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#example-use-case","title":"Example Use Case","text":"<p>pselect6() system call can be used to monitor multiple sockets for readability, writeability, exceptions, or other conditions simultaneously. For example, a web server could use pselect6 to wait for incoming connections on a set of sockets, and have one single process to handle all of the sockets.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#issues","title":"Issues","text":"<p>The pselect6 system call is vulnerable to time of check/ time of use (TOCTOU) race condition because the process might have blocked on the selector before the I/O that it is waiting for will complete.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#related-events","title":"Related Events","text":"<ul> <li>select</li> <li>sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/","title":"pselect6_time32","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#intro","title":"Intro","text":"<p>pselect6_time32 - select a subset of file descriptors based on given time frame</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#description","title":"Description","text":"<p>This event is a Linux version of <code>select</code> system call. It allows user to select subset of file descriptors, or sockets, withing a given time frame. The time frame is defined by the last argument, a timeout structure.</p> <p>The <code>pselect6_time32</code> system call is used to wait for a given set of file descriptors to become ready to perform read, write orupdate operations, or to get a notification when one of the specified set of signals arrives within given time frame.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#arguments","title":"Arguments","text":"<ul> <li><code>n</code>:<code>int</code> - maximum number of file descriptors to select from.</li> <li><code>inp</code>:<code>fd_set*</code> - pointer to set of file descriptors that are being tested for readiness.</li> <li><code>outp</code>:<code>fd_set*</code> - pointer to a set of file descriptors that are set if they become ready.</li> <li><code>exp</code>:<code>fd_set*</code> - pointer to a set of file descriptors that will be set if an error occurs.</li> <li><code>tsp</code>:<code>struct old_timespec32*</code>[KU] - pointer to a timeout structure.</li> <li><code>sig</code>:<code>void*</code>[K] - pointer to set of signals to be watched.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#do_select_vec","title":"do_select_vec","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#type","title":"Type","text":"<p>Probes </p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#purpose","title":"Purpose","text":"<p>Log the arguments given to pselect6_time32 for troubleshooting.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#compat_sys_pselect6_time32","title":"compat_sys_pselect6_time32","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#type_1","title":"Type","text":"<p>In-kernel hooking </p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#purpose_1","title":"Purpose","text":"<p>To hook calls to the pselect6_time32 system call in kernel and log the arguments for further analysis.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#example-use-case","title":"Example Use Case","text":"<p>Let's say we have a whole set of file descriptors that have to be open in order to execute our program. However, the conditions under which they can be opened are limited, and we would like to know if all the file descriptors are ready to use within the given time frame. To do this, we can use <code>pselect6_time32</code> to wait for all the file descriptors to be ready, and provides us a subset of the file descriptors that are actually ready. On failure, the <code>exp</code> set contains file descriptors that couldn't be ready within the timeout.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#issues","title":"Issues","text":"<p>The last argument, <code>sig</code>, is designed to work as a synchronous equivalent of <code>sigevent</code>, which can be used to execute asynchronous operations on signals. As of version 5.4 of the Linux kernel, this argument is not implemented and have to be passed as null or ignored.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#related-events","title":"Related Events","text":"<ul> <li><code>select</code> - related event with wider compatiblity, but no support for timeout.</li> <li><code>pselect6</code> - similar to <code>pselect6_time32</code> except the timeout structure takes <code>old_timespec</code> instead of <code>old_timespec32</code> format.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/","title":"ptrace","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#intro","title":"Intro","text":"<p>ptrace - process trace system call for controlling and observing another process</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#description","title":"Description","text":"<p>The <code>ptrace()</code> system call is a means by which one process, termed the \"tracer\", can observe and control the execution of another process, known as the \"tracee\".</p> <p>Through <code>ptrace()</code>, a tracer can examine and alter the tracee's memory and registers, essentially gaining a mechanism to inspect and manipulate the internal state of the tracee. The primary use case for <code>ptrace()</code> is in the implementation of debugging tools and other code-analysis utilities, which serve as aids in software development.</p> <p>Additionally, <code>ptrace()</code> can be employed in malicious activities such as process injection, where it is used to attach to and modify a running process by writing arbitrary code into i.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#arguments","title":"Arguments","text":"<ul> <li><code>request</code>:<code>int</code>[K] - The specific operation to be performed, determined by constant values defined in the system headers.</li> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the tracee.</li> <li><code>addr</code>:<code>void *</code>[K] - Address in the tracee's memory or a request-dependent value.</li> <li><code>data</code>:<code>void *</code>[K] - Data to be written to the tracee's memory or a request-dependent value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ptrace/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/ptrace/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#sys_ptrace","title":"sys_ptrace","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>ptrace()</code> system call is invoked and to gather contextual information about the operation being performed, the target process, and the data being accessed or modified.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#example-use-case","title":"Example Use Case","text":"<p>Developing a security monitoring system that tracks the usage of <code>ptrace()</code> to identify potentially malicious activities like process injection or unauthorized debugging attempts.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#issues","title":"Issues","text":"<p><code>ptrace()</code> can be used maliciously for process injection attacks, where an attacker attaches to a running process to modify its behavior, potentially leading to privilege escalation or other security breaches.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#related-events","title":"Related Events","text":"<ul> <li><code>execve()</code> - Execution of new program in a process.</li> <li><code>fork()</code> - Creation of a new process.</li> <li><code>vfork()</code> - Creation of a new process, sharing memory with parent.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/","title":"putpmsg","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#intro","title":"Intro","text":"<p>putpmsg - send a message on a STREAMS pipe.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#description","title":"Description","text":"<p>The putpmsg() system call is used to write a message on a STREAMS pipe. It enables a process to place zero to two messages on the pipe in an atomic manner, the combination of two messages making a single queued message.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - the file descriptor associated with a STREAMS pipe.</li> <li><code>ctlptr</code>:<code>struct strbuf</code>[K] - The argument points to a strbuf structure which is used to point to the control part of a message.  If a control part is not desired then a null pointer may be used.</li> <li><code>dataptr</code>:<code>struct strbuf</code>[K] - The argument points to a strbuf structure which is used to point to the data part of a message, or may be a null pointer if no message data is requested.</li> <li> <p><code>flag</code>:<code>int</code> - The flag argument can take one of the values 0, MSG_BAND, MSG_HIPRI or MSG_ANY as defined below:</p> <ul> <li>MSG_BAND \u2014 if the pipe grants priority bands, the specified priority band is requested.</li> <li>MSG_HIPRI \u2014 the highest priority band is requested.</li> <li>MSG_ANY \u2014 any priority band is acceptable.</li> </ul> </li> </ul>"},{"location":"docs/events/builtin/syscalls/putpmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/putpmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#do_putpmsg","title":"do_putpmsg","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#purpose","title":"Purpose","text":"<p>To trace calls to putpmsg() system call.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#example-use-case","title":"Example Use Case","text":"<p>One use case for putpmsg() is executing daemon services. By hooking the putpmsg() kprobe, one can check if and in what order daemon services are receiving messages each time. </p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#issues","title":"Issues","text":"<p>As putpmsg() is specific to a STREAMS pipe, it will only be useful for applications that use it.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#related-events","title":"Related Events","text":"<ul> <li>link()</li> <li>open()</li> <li>read()</li> <li>write()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/","title":"pwrite64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#intro","title":"Intro","text":"<p>pwrite64 - A system call that writes data from a buffer described by <code>buf</code> of a given size <code>count</code> to a given file descriptor <code>fd</code> at a certain offset <code>offset</code> in the open file.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#description","title":"Description","text":"<p>The <code>pwrite64</code> system call, like the <code>write</code> system call, writes data from a buffer described by <code>buf</code> of a given size <code>count</code> to a specified file descriptor <code>fd</code>. The <code>pwrite64</code> system call differs from the <code>write</code> system call in that it writes a specified number of bytes to an open file descriptor at an offset instead of the current position. This offset can be specified with <code>offset</code>, a parameter of type <code>off_t</code>, which is a signed integer integer type frequently used to specify an offset or distance.This behavior is useful if, for example, an application needs to write data to a file at specific locations.</p> <p>The <code>pwrite64</code> system call is not vulnerable to Time-of-Check Time-of-Use (TOCTOU) because the parameters are evaluated before any action is taken.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor.</li> <li><code>buf</code>:<code>const void*</code>[KU] - Pointer to the buffer containing data for write operation. </li> <li><code>count</code>:<code>size_t</code>[K] - Quantity of data, in bytes, to be written to the file descriptor.</li> <li><code>offset</code>:<code>off_t</code>[K] - Specifies the position in the file where the data issued from <code>buf</code> should be written. </li> </ul>"},{"location":"docs/events/builtin/syscalls/pwrite64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwrite64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#sys_pwrite64","title":"sys_pwrite64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#purpose","title":"Purpose","text":"<p>Used to keep track of all calls to <code>pwrite64</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#do_syscall_64","title":"do_syscall_64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#type_1","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#purpose_1","title":"Purpose","text":"<p>Used to observe the start of all the execution of group 2 system calls.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#example-use-case","title":"Example Use Case","text":"<p>The <code>pwrite64</code> system call can be used by programs that need to modify an existing file in a very precise way. A good example would be a text editor that uses pwrite64 to modify the file at a particular byte offset, ensuring that it keeps the original file structure intact.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#issues","title":"Issues","text":"<p>Due to its parameters, the <code>pwrite64</code> system call can be rather slow when dealing with large files since its read/write operations occur at an offset specified in the parameter <code>offset</code>; hence, it performs one operation at a time (as opposed to <code>write</code> system call).</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#related-events","title":"Related Events","text":"<ul> <li><code>write</code></li> <li><code>pwritev64</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/","title":"pwritev","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#intro","title":"Intro","text":"<p>pwritev - write data from multiple buffers to a file descriptor at a given offset.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#description","title":"Description","text":"<p>The <code>pwritev</code> system call is used to write data from multiple buffers to a file descriptor at a given offset. It is similar to <code>readv</code> in the way that it can write data from multiple non-contiguous memory blocks, however, the data is written to a specific location instead of just to a file descriptor. This can be useful for writing data at a specific location, regardless of the current file offset.</p> <p>The <code>pwritev</code> system call is useful when writing data to a specific location in a file, but due to its reliance on a single file descriptor (FD) it can be vulnerable to race conditions when writing to multiple files, since the FD value might change between different calls.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - a valid file descriptor, for a file previously opened for writing.</li> <li><code>iov</code>: <code>const struct iovec*</code> - a pointer to a struct iovec* array of read buffers. The size of the array is specified in iovcnt.</li> <li><code>iovcnt</code>: <code>unsigned long</code> - the size of the read buffer array passed in iov.</li> <li><code>pos_l</code>: <code>unsigned long</code> - the low bits of the position in the file to start writing to.</li> <li><code>pos_h</code>: <code>unsigned long</code> - the high bits of the position in the file to start writing to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#sys_pwritev","title":"sys_pwritev","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#purpose","title":"Purpose","text":"<p>To instrument the pwritev syscall in order to get more insight into data being written.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#example-use-case","title":"Example Use Case","text":"<p>In a system where data needs to be written from buffers scattered throughout a wide memory range, <code>pwritev</code> can be used to write data directly to a specific file offset. This can eliminate the need to read the entire file in order to write data at a certain location.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#issues","title":"Issues","text":"<p><code>pwritev</code> is vulnerable to race conditions when the same file descriptor is used to write data to multiple files. If the FD value changes between multiple calls, data can be written in the wrong file.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#related-events","title":"Related Events","text":"<ul> <li>preadv</li> <li>readv</li> <li>writev</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/","title":"pwritev2","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#intro","title":"Intro","text":"<p>pwritev2 - attempts to write data to a file descriptor at a given position</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#description","title":"Description","text":"<p>pwritev2() is used to write data to a file descriptor at a given position. The data is written to the file descriptor in the form of an array of iovec structures, which allow for the writing of multiple buffers in a single call. </p> <p>pwritev2() differs from the pwritev() system call in that it has optional <code>flags</code> argument which controls the behavior of the syscall in more detail. The flag <code>PWRITEV_UPDATE_POSITION</code> causes the file pointer to be adjusted to reflect the amount of data written to the file descriptor.</p> <p>pwritev2() is useful for maximizing the performance of writing large amounts of data to a file descriptor, as it can allow for the writing of multiple buffers in a single call.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor of the opened file.</li> <li><code>iov</code>:<code>const struct iovec*</code> - pointer to an array of iovec structures that specify the source buffers from which data is written to the file descriptor.</li> <li><code>iovcnt</code>:<code>unsigned long</code> - the number of elements in the iovec array.</li> <li><code>pos_l</code>:<code>unsigned long</code> - lower 32 bits of 64-bit position data.</li> <li><code>pos_h</code>:<code>unsigned long</code> - higher 32 bits of 64-bit position data.</li> <li><code>flags</code>:<code>int</code>[OPT] - optional flags which control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#sys_pwritev2","title":"sys_pwritev2","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#type","title":"Type","text":"<p>KPROBE</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#purpose","title":"Purpose","text":"<p>To capture the data passed to the pwritev2() syscall.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#example-use-case","title":"Example Use Case","text":"<p>pwritev2() can be used to write data to a file descriptor at a specific position in an optimized way. For example, it could be used in an application that needs to write large amounts of data to a file in an efficient way.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#issues","title":"Issues","text":"<p>Due to the fact that pwritev2() writes data from multiple buffers, it can be vulnerable to race conditions. It is important to be aware of the possibility of race conditions when using the pwritev2() system call.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#related-events","title":"Related Events","text":"<p>pwritev() - similar system call but with fewer optional flags parameter. preadv2(), writev(), preadv(), writev2() - other system calls related to writing data to or from file descriptors.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/query_module/","title":"query_module","text":""},{"location":"docs/events/builtin/syscalls/query_module/#intro","title":"Intro","text":"<p>query_module - query the kernel for information about a loaded Linux Kernel Module</p>"},{"location":"docs/events/builtin/syscalls/query_module/#description","title":"Description","text":"<p>The query_module system call provides information about loaded Kernel Modules and information about those modules. It can be used to query for the module's size, symbol table, and other related information. The call is typically used by kernel debuggers and kernel developers, as well as system administrators who need to check the module's state. </p>"},{"location":"docs/events/builtin/syscalls/query_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>char*</code>[K] - name of the module to query.</li> <li><code>which</code>:<code>int</code>[K] - Parameter specifying the module information to return.</li> <li><code>buf</code>:<code>void*</code>[K, U] - data buffer to store the queried information in.</li> <li><code>bufsize</code>:<code>size_t</code>[K] - size of the data buffer.</li> <li><code>ret_size</code>:<code>size_t*</code>[K, U] - pointer to size_t store the size of the returned information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/query_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/query_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/query_module/#query_module_1","title":"query_module","text":""},{"location":"docs/events/builtin/syscalls/query_module/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/query_module/#purpose","title":"Purpose","text":"<p>This system call is often used by kernel debuggers and developers for obtaining information about Linux modules. As this call is highly involved in kernel development and debugging, it is important to be aware of when and how it is being used. Kprobes can be used to intercept the call in order to observe its parameters and behaviour.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#example-use-case","title":"Example Use Case","text":"<p>One scenario where query_module can be useful is for trouble-shooting issues with Linux modules. System administrators may use this system call to manually query the kernel for information on a module, in the event that module is not behaving correctly.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#issues","title":"Issues","text":"<p>There is a potential TOCTOU (Time of Check, Time of Use) vulnerability with query_module. As this system call has the potential to access user-space memory, it is possible for malicious code to overwrite the contents of the queried module before it is used. It is therefore recommended to use this system call with caution and only in well-controlled situations.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#related-events","title":"Related Events","text":"<ul> <li>init_module - initialize a Linux Kernel Module</li> <li>delete_module - delete a Linux Kernel Module</li> <li>get_kernel_syms - query the kernel for exported symbols.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/","title":"quotactl","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#intro","title":"Intro","text":"<p>quotactl - manipulate disk quotas from user space.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#description","title":"Description","text":"<p>The quotactl system call is used to set disk quotas and retrieve disk quota information from user space. It is a way to limit disk usage on a system-wide basis and provides the ability to do things like set disk quota limits, enforce the disk quota limits and record disk usage for users. There are several different parameters that can be set with quotactl, such as the maximum size of a user's files and the grace period for when the quota limit is exceeded.</p> <p>The quotactl system call can be used to manipulate the disk quota information stored in the quota setup files. It can also be used to enforce the quota limit and to revoke access to the files exceeding the quota limit until the usage is brought back within the limit.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - The command to be performed, which can be one of the following:</li> <li><code>Q_QUOTAON</code> - Turn quotas on</li> <li><code>Q_QUOTAOFF</code> - Turn quotas off</li> <li><code>Q_SETQUOTA</code> - Set the quota limits</li> <li><code>Q_GETQUOTA</code> - Get the quota limits</li> <li><code>Q_GETNEXTQUOTA</code> - Get information about the next user in the system </li> <li><code>special</code>:<code>const char*</code>[K] - A pointer to a pathname indicating the block device for whose quotas the command is to be applied.</li> <li><code>id</code>:<code>int</code>[K] - The user or group id for whom the quotas are set or retrieved.</li> <li><code>addr</code>:<code>void*</code>[K] - A pointer to a buffer which contains the requested quota information to set, or which will store the quota information retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#quotactl_1","title":"quotactl","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#purpose","title":"Purpose","text":"<p>To monitor the system calls and track disk quotas.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#example-use-case","title":"Example Use Case","text":"<p>quotactl can be used as an effective disk quota enforcement mechanism to keep a user from exceeding disk usage limits. It can be used to track and monitor disk usage in order to better control resource allocation.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#issues","title":"Issues","text":"<p>It is vulnerable to TOCTOU (time of check, time of use) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#related-events","title":"Related Events","text":"<ul> <li>getdents - manipulate directory entries.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/","title":"quotactl_fd","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#intro","title":"Intro","text":"<p>quotactl_fd - set/get filesystem quotas and limits</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#description","title":"Description","text":"<p>The quotactl_fd syscalls allows the retrieval and modification of disk quotas and limits, as well as get and set disk usage information, when given a valid file descriptor. It is used to invoke one of the available commands on the specified filesystem, with specific additional parameters. It is particularly useful for setting and retrieving hard and soft limits for quotas and limits for multiple users simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code> - an open file descriptor of a filesystem from which to get or set the information, or to which the command will be sent.</li> <li><code>cmd</code>:<code>unsigned int</code> - one of the available commands that can be used in the syscall, as listed in the manual page.</li> <li><code>id</code>:<code>qid_t</code> - represents the user/group/project ID to be associated with the specified filesystem.</li> <li><code>addr</code>:<code>void *</code>[K] - an address pointing to a memory area from which data can be read or to which data can be written, depending on the type of command sent.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#do_quotactl_fd","title":"<code>do_quotactl_fd</code>","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#type","title":"Type","text":"<p>KProbe + KRetProbe.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#purpose","title":"Purpose","text":"<p>Hooked to gain visibility into how this system call is used, when it is used, where it is used and what arguments are associated with its usage.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used for applications that need to set usage quotas and limits for disk usage on a certain file system. </p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#issues","title":"Issues","text":"<p>None so far.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#related-events","title":"Related Events","text":"<ul> <li><code>quotactl</code> - related system call.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/read/","title":"Read","text":""},{"location":"docs/events/builtin/syscalls/read/#intro","title":"Intro","text":"<p>read - Read from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/read/#description","title":"Description","text":"<p>The <code>read</code> syscall is used to read from an open file descriptor. It takes as input three arguments: <code>fd</code>, <code>buf</code>, and <code>count</code>, and returns a result in the form of the number of bytes read. </p> <p>The <code>fd</code> argument is an integer that represents a file descriptor, which can be retrieved using the <code>open</code> syscall. The <code>buf</code> argument is a pointer to the buffer used to store the read bytes, which should have size at least <code>count</code>. The <code>count</code> argument represents the maximum number of bytes to be read. </p> <p>The <code>read</code> syscall usually blocks the calling process until the requested data has been read. This can cause issues if the process was expected to remain responsive while waiting for the data. If this is an issue, one possible solution would be to use the <code>poll</code> syscall to check when data is available.</p>"},{"location":"docs/events/builtin/syscalls/read/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor representing the file or device to read from.</li> <li><code>buf</code>:<code>void*</code>[KU] - Pointer to the buffer to which the data should be written.</li> <li><code>count</code>:<code>size_t</code>[K] - The maximum number of bytes to be read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/read/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/read/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/read/#sys_read","title":"sys_read","text":""},{"location":"docs/events/builtin/syscalls/read/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/read/#purpose","title":"Purpose","text":"<p>To trace syscall execution in order to record useful data like time, arguments, and return codes.</p>"},{"location":"docs/events/builtin/syscalls/read/#example-use-case","title":"Example Use Case","text":"<p>The <code>read</code> syscall can be used to read data from a file in the system, such as the contents of log files or configuration files. It may be useful for profiling the system by monitoring which files are read and when.</p>"},{"location":"docs/events/builtin/syscalls/read/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/read/#related-events","title":"Related Events","text":"<p>write, poll, open</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readahead/","title":"Readahead","text":""},{"location":"docs/events/builtin/syscalls/readahead/#intro","title":"Intro","text":"<p>Readahead - readahead preloads a file or block device into the page cache.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#description","title":"Description","text":"<p>The readahead() system call initiates a read from a file or block device into the page cache of the kernel. It begins at an offset in the file and reads up to count bytes. If readahead has already been performed on this file, the kernel will extend the previous read by the additional count bytes. This call allows the kernel to prefetch more data than is needed before the data is requested. Thus, the act of calling readahead allows the kernel to speed up subsequent read operations by preloading the data before it is requested by the user.</p> <p>The readahead system call can be used to improve the slow-start performance of applications that read full files sequentially. By pre-loading data with readahead, the user has less wait time while the disk is being read.</p> <p>Readahead does not guarantee that the data will remain in the page cache. The kernel discards quickly-referenced pages from the page cache in order to make room for other page-cache requests.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor for the file. </li> <li><code>offset</code>:<code>off_t</code>[K] - The location in the file to begin reading from. </li> <li><code>count</code>:<code>size_t</code>[K] - The amount of bytes to read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readahead/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readahead/#hooks","title":"Hooks","text":"<p>No functions are hooked when readahead is called.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#example-use-case","title":"Example Use Case","text":"<p>One example use case of the readahead system call is the readahead_all() function in the Linux kernel. It is used to prefetch files in parallel to speed-up the start of an application that requires multiple files. This can significantly reduce I/O latency by allowing more data to be read in one go since the kernel can readahead to fill-up the page cache.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#issues","title":"Issues","text":"<p>No known issues exist with the readahead system call.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#related-events","title":"Related Events","text":"<ul> <li>madvise() - The madvise() system call can allow applications to inform the kernel about the expected usage patterns of data so that the optimal page management strategies can be implemented. It is typically used in conjunction with readahead() to optimize the performance of file reads.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readdir/","title":"readdir","text":""},{"location":"docs/events/builtin/syscalls/readdir/#intro","title":"Intro","text":"<p>readdir - Reads a directory structure from the given opened file descriptor</p>"},{"location":"docs/events/builtin/syscalls/readdir/#description","title":"Description","text":"<p>The readdir() system call reads a single directory entry from a directory opened with the open() system call. It returns the next directory entry in a directory stream pointed to by the file descriptor fd. Upon successful return, the content of the directory entry is copied to the old_linux_dirent structure pointed to by dirp.</p> <p>The readdir() system call is used to get information about each subdirectory in a filesystem, one entry at a time. It is possible to call this system call on any open file descriptor , regardless of the type of file is associated with it.</p> <p>The count argument specifies the length of the old_linux_dirent buffer. If the buffer size is not large enough to hold the entire directory entry, an error will be returned.</p> <p>readdir() does not guarantee that successive calls to this system call with the same file descriptor will always return the entries in the same order.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - A file descriptor returned from open system call.</li> <li><code>dirp</code>:<code>struct old_linux_dirent*</code>[K] - A pointer to the structure.</li> <li><code>count</code>:<code>unsigned int</code>[K] - Total number of bytes for the structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readdir/#readdir_1","title":"readdir()","text":""},{"location":"docs/events/builtin/syscalls/readdir/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readdir/#purpose","title":"Purpose","text":"<p>Monitoring calls to readdir.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#example-use-case","title":"Example Use Case","text":"<p>readdir() can be used to monitor a specific directory in the filesystem. It can be used to monitor or detect any changes or operations, such as the creation of files or the deletion of directories, in the monitored directory.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#issues","title":"Issues","text":"<p>readdir() is vulnerable to a Time of Check, Time of Use (TOCTOU) race condition, which can result in security vulnerabilities if not carefully handled.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#related-events","title":"Related Events","text":"<p>open(), seekdir(), getdents(), rewinddir()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readlink/","title":"readlink","text":""},{"location":"docs/events/builtin/syscalls/readlink/#intro","title":"Intro","text":"<p>readlink - read the contents of a symbolic link</p>"},{"location":"docs/events/builtin/syscalls/readlink/#description","title":"Description","text":"<p>The <code>readlink()</code> system call reads the contents of a symbolic link and stores the  result in the buffer pointed to by <code>buf</code>, which has a length of <code>bufsiz</code> bytes.  This call does not follow symbolic links; it reads the contents of the link itself.  The <code>readlink()</code> system call does not append a null byte to the buffer. </p>"},{"location":"docs/events/builtin/syscalls/readlink/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Pointer to the symbolic link pathname.</li> <li><code>buf</code>:<code>char*</code>[K+U] - A character array to store the contents of the link in.</li> <li><code>bufsiz</code>:<code>size_t</code>[K] - Size of the character array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readlink/#__x64_sys_readlink","title":"__x64_sys_readlink","text":""},{"location":"docs/events/builtin/syscalls/readlink/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readlink/#purpose","title":"Purpose","text":"<p>To capture information regarding the use of the readlink system call.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#example-use-case","title":"Example Use Case","text":"<p>A malicious user is attempting to use <code>readlink</code> for nefarious purposes. By  hooking the <code>__x64_sys_readlink</code> function, an analyst can track and collect  information regarding the use of the <code>readlink</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#related-events","title":"Related Events","text":"<ul> <li>open - The <code>open()</code> system call is used to open a file given its pathname. Used  in conjunction with <code>readlink()</code>, as one cannot use <code>readlink()</code> with a relative  path. </li> <li>access - The <code>access()</code> system call is used to determine whether a process has  permission to access a certain file or directory. Used in conjunction with  <code>readlink()</code>, as an analyst may want to see if a user has access to certain file  paths.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/","title":"readlinkat","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#intro","title":"Intro","text":"<p>readlinkat - read the contents of a symbolic link</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#description","title":"Description","text":"<p>The readlinkat() system call is used to read the contents of a symbolic link. The call requires a file descriptor for the directory that contains the symbolic link, the name of the link itself, a buffer for the link contents, and the size of the buffer. The call returns the contents of the link in the given buffer, or an error code if the buffer is too small for the link.</p> <p>The readlinkat() system call is similar to the readlink() system call, except it allows for more control of the environment in which the link is read. While readlink() always takes the path of the link as relative to the current working directory, readlinkat() allows the path to be relative to a directory that is different than the current working directory. </p> <p>The readlinkat() system call has some drawbacks. It is vulnerable to \"time of check, time of use\" (TOCTOU) race conditions, as the link could be changed between the time it is checked and when it is used. It also requires the user to provide a valid file descriptor for the target directory. This can be difficult when the target directory is a remote filesystem, or a virtual filesystem.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - file descriptor for directory containing the link.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - the pathname of the link.</li> <li><code>buf</code>:<code>char*</code>[KU] - buffer for the link contents. </li> <li><code>bufsiz</code>:<code>int</code>[K] - size of the buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#vfs_readlink","title":"vfs_readlink()","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#purpose","title":"Purpose","text":"<p>To add additional tracing capabilities to the readlinkat() system call.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#generic_permission","title":"generic_permission()","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#purpose_1","title":"Purpose","text":"<p>To record the return value of the readlinkat() system call.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#example-use-case","title":"Example Use Case","text":"<p>The readlinkat() system call can be used to read the contents of a symbolic link and ensure that the link points to the expected target. This can be useful for validation of the directory structure, or for creating a log of file and directory changes.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#issues","title":"Issues","text":"<p>The readlinkat() system call is vulnerable to \"time of check, time of use\" (TOCTOU) race conditions, as the link could be changed between the time it is checked and when it is used. </p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#related-events","title":"Related Events","text":"<p>The readlink() system call is the simplified version of readlinkat() and is used to read the contents of a link. The lstat() system call can be used to check the properties of the link and ensure it is a valid link. The openat() system call is used to open the target directory and get a file descriptor for use with readlinkat().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readv/","title":"readv","text":""},{"location":"docs/events/builtin/syscalls/readv/#intro","title":"Intro","text":"<p>readv - read data from a file descriptor into multiple buffers</p>"},{"location":"docs/events/builtin/syscalls/readv/#description","title":"Description","text":"<p>The readv() system call reads data from a file descriptor into multiple buffers, specified with the array iov. Each element in the array contains the location and number of bytes to read. Up to iovcnt elements can be read from an array.</p> <p>The readv() call operates similarly to a call of read() except for the arrays of vectors, rather than a single user buffer. The readv() call is then useful for reading from a file or socket into multiple buffers, allowing for greater efficiency when working with large datasets.</p> <p>Edge cases: Depending on the value used for the iovcnt argument, fewer than the requested number of bytes may be written to the output buffers.</p>"},{"location":"docs/events/builtin/syscalls/readv/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - the file descriptor from which the data should be read.</li> <li><code>iov</code>:<code>const struct iovec*</code>[KU] - an array containing the location and number of bytes to read.</li> <li><code>iovcnt</code>:<code>int</code> - the number of elements in the iov array that should be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readv/#readv_1","title":"readv","text":""},{"location":"docs/events/builtin/syscalls/readv/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/readv/#purpose","title":"Purpose","text":"<p>To be able to trace when the system call readv gets triggered, in order to determine when data is being read from a file descriptor into multiple buffers.</p>"},{"location":"docs/events/builtin/syscalls/readv/#example-use-case","title":"Example Use Case","text":"<p>readv() can be used to read a large amount of data from a file descriptor into multiple buffers, for example for writing to a log file or sending large datasets over a network.</p>"},{"location":"docs/events/builtin/syscalls/readv/#issues","title":"Issues","text":"<p>No issues known for this event.</p>"},{"location":"docs/events/builtin/syscalls/readv/#related-events","title":"Related Events","text":"<ul> <li>writev</li> <li>preadv</li> <li>preadv2</li> <li>pwritev</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/reboot/","title":"reboot","text":""},{"location":"docs/events/builtin/syscalls/reboot/#intro","title":"Intro","text":"<p>reboot - reboot a computer</p>"},{"location":"docs/events/builtin/syscalls/reboot/#description","title":"Description","text":"<p>The reboot() system call causes the system to be rebooted. The magic parameter and magic2 parameter, if non-zero, are passed to the kernel and the behavior of the call can depend on their values. The cmd parameter may be one of the following:</p> <ul> <li>RB_AUTOBOOT - Forces the system to restart, no questions asked.</li> <li>RB_HALT_SYSTEM - Halts the system after the system has been shut down.</li> <li>RB_POWER_OFF - Powers the system off and is the equivalent of using the power   button on a PC.</li> </ul> <p>The arg parameter can be set to a pointer to a character array, which is used to provide additional information such as a shutdown message, but it is generally ignored.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#arguments","title":"Arguments","text":"<ul> <li><code>magic</code>:<code>int</code> - Magic argument. Used to tell the kernel certain privileges   for the reboot procedure.</li> <li><code>magic2</code>:<code>int</code>-[K] - Magic argument number two. Used to tell the kernel   certain privileges for the reboot procedure.</li> <li><code>cmd</code>:<code>int</code> - Command to execute. Can be one of the following: RB_AUTOBOOT,   RB_HALT_SYSTEM and RB_POWER_OFF.</li> <li><code>arg</code>:<code>void*</code>-[U] - A pointer to a character array that can be used to   provide additional information but is generally ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/reboot/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/reboot/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/reboot/#do_sys_reboot","title":"do_sys_reboot","text":""},{"location":"docs/events/builtin/syscalls/reboot/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/reboot/#purpose","title":"Purpose","text":"<p>To intercept attempts to reboot the system.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#example-use-case","title":"Example Use Case","text":"<p>Reboot the system to apply a kernel patch or a system configuration change.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#issues","title":"Issues","text":"<p>The reboot system call does not return, so it needs to be used with caution to avoid inadvertently affecting system stability.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#related-events","title":"Related Events","text":"<ul> <li>sys_reboot - Generates a system reboot.</li> <li>sys_restart_syscall - Restarts a system call after it was interrupted by a   signal.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/","title":"recvfrom","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#intro","title":"Intro","text":"<p>recvfrom - receive a message from a network socket</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#description","title":"Description","text":"<p>The recvfrom() system call reads a message from a socket, and stores it in a buffer. The flags argument can be used to alter the behavior of the call. If src_addr is not NULL, then the source address of the message is filled in. For connection-oriented sockets (e.g., type SOCK_STREAM), this is attempted only on the first message on the socket. If addrlen is not NULL, then it is filled in with the size of the address actually returned.</p> <p>The recvfrom() call is usually used with connectionless sockets (type SOCK_DGRAM). With a connectionless socket, the source address of the message is returned in src_addr and addrlen holds the size of the address. If src_addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - File descriptor referring to a socket.</li> <li><code>buf</code>:<code>void*</code>[KU] - Pointer to the buffer in which the message should be stored.</li> <li><code>len</code>:<code>size_t</code>[KU] - Length of the buffer.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for the call.</li> <li><code>src_addr</code>:<code>struct sockaddr*</code>[KU] - Pointer to a buffer which will contain the source address of the message. Can be NULL.</li> <li><code>addrlen</code>:<code>int*</code>[KU] - Pointer to a buffer which will contain the length of the source address. Can be NULL.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvfrom/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvfrom/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#sys_recvfrom","title":"sys_recvfrom","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#type","title":"Type","text":"<p>Kprobes and Uprobe</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#purpose","title":"Purpose","text":"<p>To observe the use of recvfrom syscall, the entry point of the syscall can be intercepted with a kprobe. This allows the function to be handled in a safe environment and the arguments to be intercepted and passed to the tracer.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#mm_access","title":"mm_access","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#purpose_1","title":"Purpose","text":"<p>This kprobe is used to handle the buffer passed to the syscall to ensure that it can be read by the kernel safely.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for recvfrom is for a server logging program, which needs to read the data contained in incoming messages. The program can use recvfrom to receive the messages from the appropriate socket, and it can then process the data contained in the message.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#issues","title":"Issues","text":"<p>The recvfrom() system call is vulnerable to Time-of-Check-Time-of-Use (TOCTOU) attacks. This means that an attacker could modify the data between the time it is checked and the time it is used. To mitigate this, checks should be performed on the data at both the time of check and time of use.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#related-events","title":"Related Events","text":"<ul> <li>sendto</li> <li>getsockname</li> <li>recv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/","title":"recvmmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#intro","title":"Intro","text":"<p>recvmmsg - Receive multiple messages on a socket</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#description","title":"Description","text":"<p>The recvmmsg() system call is used to receive multiple messages from a socket, similar to recvmsg(), but allows passing a user-space array to retrieve multiple messages into different buffers with a single call, instead of having to call the function multiple times.</p> <p>There are several advantages to using recvmmsg(): - It is much faster, because it can receive multiple messages at once, thus   avoiding the need for multiple system calls. - It can be used for better network performance, since it does fewer system   calls, meaning less context switches from user-space to kernel-space. - It can be used to receive multiple messages from different sockets (as   opposed to recvmsg(), which receives from only one)</p> <p>There are also a few drawbacks to using recvmmsg(): - It is not suitable for small messages, since the overhead for using it is   higher than that of using the single message system call (recvmsg()) - If the socket is set to non-blocking, recvmmsg() will return an error if   there are not enough messages in the queue, whereas recvmsg() would return   immediately with the messages it has (if any).</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - The file descriptor of the socket.</li> <li><code>msgvec</code>:<code>struct mmsghdr*</code>[U] - An array of mmsghdr structures, each one   containing a message that recvmmsg() receives into. The caller should ensure   that this array is large enough for up to vlen messages.</li> <li><code>vlen</code>:<code>unsigned int</code>[K] - The maximum size of the msgvec array.</li> <li><code>flags</code>:<code>int</code>[K] - Socket flags, such as MSG_DONTWAIT.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - If not null, a pointer to a timespec   structure to be used for timeouts.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#sys_recvmmsg","title":"sys_recvmmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#purpose","title":"Purpose","text":"<p>To monitor the receipt of multiple messages on a socket.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#example-use-case","title":"Example Use Case","text":"<p>By using recvmmsg(), multiple file descriptors can be monitored in a single system call, thus avoiding the need for making multiple system calls. This can be useful when working with high-performance applications, such as distributed systems, where a single system call needs to receive many messages at once.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#related-events","title":"Related Events","text":"<ul> <li>recvmsg() - Receive a message from a socket.</li> <li>sendmmsg() - Send multiple messages on a socket.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/","title":"recvmmsg_time32","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#intro","title":"Intro","text":"<p>recvmmsg_time32 system call - an implementation for recvmmsg for 32-bit timeval structures.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#description","title":"Description","text":"<p>The recvmmsg_time32() system call is an implementation of the recvmmsg() system call that uses the old_timespec32 data type instead of timespec. This allows the receiving of multiple messages with a single system call, instead of multiple calls. The old_timespec32 structure allows a 32-bit seconds and microseconds fields, as opposed to the timespec structure, which uses a 64-bit nanoseconds field.</p> <p>This function is using pointers to user space memory, to fetch multiple messages, which could be potentialy vulnerable to TOCTOU (Time Of Check, Time Of Use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[KU] - The file descriptor from which to receive the message.</li> <li><code>mmsg</code>:<code>struct mmsghdr*</code>[KU] - A pointer to an array of mmsghdr structures containing information about the messages that are to be received by recvmsg().</li> <li><code>vlen</code>:<code>unsigned int</code>[K] - The length of the array of mmsghdr structures.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - The flags to be used for the recvmsg() syscalls used in the process.</li> <li><code>timeout</code>:<code>struct old_timespec32*</code>[K] - A pointer to a struct old_timespec32 containing the timeout for the recvmmsg call to wait for incoming messages.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#tracepoint_sys_enter_recvmmsg_time32","title":"tracepoint_sys_enter_recvmmsg_time32","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#purpose","title":"Purpose","text":"<p>To trace calls to the recvmmsg_time32 syscall.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#ptrace_recv_syscall","title":"ptrace_recv_syscall","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#type_1","title":"Type","text":"<p>Ptrace hook</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#purpose_1","title":"Purpose","text":"<p>To be able to hook the recvmmsg_time32 syscall, and modify its arguments before syscall enter.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to receive multiple messages in one system call, for example for an event-based server application. It can be used to wait in a select()-like loop on multiple sockets, but instead of having to perform multiple recvmsg() calls, a single recvmmsg_time32() system call can be used to receive messages from all the sockets.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#issues","title":"Issues","text":"<p>TBD</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#related-events","title":"Related Events","text":"<ul> <li>recvmsg,</li> <li>sendmsg,</li> <li>select,</li> <li>poll,</li> <li>epoll_wait</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/","title":"recvmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#intro","title":"Intro","text":"<p>recvmsg - read a message from a socket</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#description","title":"Description","text":"<p>recvmsg() is used to receive messages from a  socket,  and  may  be  used  to  receive  both  connection-based  and  connectionless messages. recvmsg() may also be used to receive file descriptors sent by means of the sendmsg() system call.</p> <p>The flags argument provides further options and is constructed by giving the bitwise OR of one or more of the following: * MSG_CMSG_CLOEXEC - Indicates that associated to each control message an close-on-exec flag must be set. * MSG_DONTWAIT - Non-blocking operation - make the call fail if the socket is not available for receive. * MSG_ERRQUEUE - Receive messages from the kernel error queue. * MSG_OOB - Receive out-of-band data.</p> <p>Advantage of using recvmsg is the possibility of merging several different types of input into one system call. Drawback is that it does not provide any data ordering assurance.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - File descriptor of the socket from which to receive messages. </li> <li><code>msg</code>:<code>struct msghdr*</code>[K] - Pointer to a msghdr structure which will contain the message of up to size 65535 bytes.</li> <li><code>flags</code>:<code>int</code>[K] - OR-ed bit flags of the possible flags: MSG_CMSG_CLOEXEC, MSG_DONTWAIT, MSG_ERRQUEUE and MSG_OOB.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#syscall_recvmsg","title":"syscall_recvmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#purpose","title":"Purpose","text":"<p>To analyze and control the messages received from the given socket.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#example-use-case","title":"Example Use Case","text":"<p>An example use of recvmsg is when using socket-level security for validating messages. By using recvmsg, messages delivery can be allowed or denied according to some criteria.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#issues","title":"Issues","text":"<p>No known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#related-events","title":"Related Events","text":"<ul> <li>sendmsg - opposite of recvmsg, used to send messages.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/","title":"remap_file_pages","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#intro","title":"Intro","text":"<p>remap_file_pages - Map or remap part of a file into the process's address space</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#description","title":"Description","text":"<p>The <code>remap_file_pages</code> system call changes the protection and mapping of memory pages in the virtual address space of the calling process. It can remap an existing file mapping, create a new one, or unmap a range of pages previously mapped. It can also be used to change the permissions of the mapped pages. </p> <p>This call provides support for memory mapped files that can be used as shared memory or for other kinds of memory sharing among processes. </p> <p>An edge-case that can be encountered when using <code>remap_file_pages</code> is when the requested range of file pages is not available. This can be caused by the underlying file having been truncated, or if the requested mapping overlaps with another existing mapping.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Starting address of the mapping.</li> <li><code>size</code>:<code>size_t</code>[U] - Size of the mapping.</li> <li><code>prot</code>:<code>int</code>[U] - Memory protection flags to set for the mapping.</li> <li><code>pgoff</code>:<code>size_t</code>[U] - File offset in bytes corresponding to the start of the mapping.</li> <li><code>flags</code>:<code>int</code>[U] - Flags for the mapping. Can be set to 0 for default behavior. </li> </ul>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#do_mmap_pgoff","title":"do_mmap_pgoff","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#purpose","title":"Purpose","text":"<p>To monitor the <code>do_mmap_pgoff</code> syscall which is used by the kernel to handle <code>remap_file_pages</code> calls. </p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#update_mmap_zero_pfn","title":"update_mmap_zero_pfn","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#type_1","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#purpose_1","title":"Purpose","text":"<p>To monitor the <code>update_mmap_zero_pfn</code> syscall which is used by the kernel to handle <code>remap_file_pages</code> calls.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#example-use-case","title":"Example Use Case","text":"<p><code>remap_file_pages</code> can be used when a process needs to share parts of its address space with other processes. This can be done through the use of memory mapped files or shared memory.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#issues","title":"Issues","text":"<p>Due to its underlying implementation, <code>remap_file_pages</code> can be vulnerable to TOCTOU races. This means that between the time when the data is read and the data is used, other operations can take place which make the read data obsolete.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code>: used to create mappings in the virtual address space</li> <li><code>mprotect</code>: used to change page permissions</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/","title":"removexattr","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#intro","title":"Intro","text":"<p>removexattr() - removes the extended attribute to the file system object</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#description","title":"Description","text":"<p>The removexattr() system call removes an extended attribute associated with the given file system object path. It is used to control access to file system objects. It removes only one attribute per invocation, which is specified by the given name argument.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The main drawback of using removexattr() is that it does not provide any mechanism for setting a default value for an attribute.  Additionally, it does not support any type of transactional behavior.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - The path name of the file system object.</li> <li><code>name</code>:<code>const char*</code>[K] - The name of the extended attribute to remove.</li> </ul>"},{"location":"docs/events/builtin/syscalls/removexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/removexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#__x64_sys_removexattr","title":"__x64_sys_removexattr","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#purpose","title":"Purpose","text":"<p>To capture information related to the invocation of the removexattr() system  call, including the arguments and return value, for tracing and performance  analysis.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event is for security-related purposes. It can be used to monitor for suspicious activity, such as the removal of extended attributes from a file system object.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#related-events","title":"Related Events","text":"<ul> <li>setxattr</li> <li>getxattr</li> <li>listxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rename/","title":"rename","text":""},{"location":"docs/events/builtin/syscalls/rename/#intro","title":"Intro","text":"<p>rename - change the name or location of a file</p>"},{"location":"docs/events/builtin/syscalls/rename/#description","title":"Description","text":"<p>The <code>rename()</code> syscall is used to change the name or location of a file. It can also be used to move a file from one directory to another, or to rename a file. This can be important for system processes, for example making changes to files during updates or installation processes, or for application processes like renaming a file with a new version number.  Edge cases can arise from differing permissions levels between the two paths. It can also be vulnerable to TOCTOU (time of check, time of use) attacks if not properly handled, as the operation of the rename can be interrupted between the check that the file exists and when the rename happens.</p>"},{"location":"docs/events/builtin/syscalls/rename/#arguments","title":"Arguments","text":"<ul> <li><code>oldpath</code>: <code>const char*</code>[K] - Path to existing file</li> <li><code>newpath</code>: <code>const char*</code>[K] - New path of file</li> </ul>"},{"location":"docs/events/builtin/syscalls/rename/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rename/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rename/#sys_rename","title":"sys_rename","text":""},{"location":"docs/events/builtin/syscalls/rename/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rename/#purpose","title":"Purpose","text":"<p>Monitoring the rename syscall</p>"},{"location":"docs/events/builtin/syscalls/rename/#example-use-case","title":"Example Use Case","text":"<p>An example use-case of the <code>rename()</code> syscall could be updating a program. A program would call <code>rename()</code> to move an existing version of the file to a new directory and/or with a different name, and then place a new version of the program into the proper directory.</p>"},{"location":"docs/events/builtin/syscalls/rename/#issues","title":"Issues","text":"<p>TOCTOU (Time of Check, Time of Use) attacks are possible when using the <code>rename()</code> syscall. If a file is checked to exist and then renamed, an attacker can theoretically create the file in the meantime and cause an attack vector through the rename.</p>"},{"location":"docs/events/builtin/syscalls/rename/#related-events","title":"Related Events","text":"<p>The <code>rename()</code> syscall is often used in conjunction with other syscalls, such as <code>open()</code>, <code>stat()</code>, <code>unlink()</code> or <code>mkDIR()</code>. Additionally, other related syscalls like <code>link()</code> and <code>symlink()</code> can achieve similar effects.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/renameat/","title":"renameat","text":""},{"location":"docs/events/builtin/syscalls/renameat/#intro","title":"Intro","text":"<p>renameat - rename a file or directory, relative to an existing file descriptor</p>"},{"location":"docs/events/builtin/syscalls/renameat/#description","title":"Description","text":"<p>The <code>renameat</code> syscall is used to rename a file or directory, relative to an existing file descriptor. It takes four arguments: two file descriptors, <code>olddirfd</code> and <code>newdirfd</code>, and two file paths, <code>oldpath</code> and <code>newpath</code>. <code>olddirfd</code> and <code>newdirfd</code> must refer to valid file descriptors associated with directories, while <code>oldpath</code> and <code>newpath</code> must refer to valid file paths. If these arguments are not provided, the <code>renameat</code> syscall will fail with an error.</p> <p>This syscall is used for managing files and directories. It is useful for providing an extra level of protection when renaming files and directories, because it allows the user to specify a file descriptor rather than a full path. It also allows for easier, more portable file and directory management.</p> <p>Note that the <code>renameat</code> syscall is vulnerable to TOCTOU (time of check, time of use) issues, because the file path and file descriptor can become invalid between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - the file descriptor of the directory containing the file to be renamed. Must be a valid file descriptor associated with a directory.</li> <li><code>oldpath</code>:<code>const char*</code>[K] - the path of the file to be renamed, relative to the directory referenced by <code>olddirfd</code>. Must be a valid file path.</li> <li><code>newdirfd</code>:<code>int</code>[K] - the file descriptor of the directory in which to rename the file. Must be a valid file descriptor associated with a directory.</li> <li><code>newpath</code>:<code>const char*</code>[K] - the path of the new file, relative to the directory referenced by <code>newdirfd</code>. Must be a valid file path.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/renameat/#__x32_sys_renameat","title":"__x32_sys_renameat","text":""},{"location":"docs/events/builtin/syscalls/renameat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/renameat/#purpose","title":"Purpose","text":"<p>To trace the <code>renameat</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#example-use-case","title":"Example Use Case","text":"<p>A user wants to move a file from one directory to another, without knowing the full file paths. The user can use the <code>renameat</code> syscall to move the file, using the two file descriptors to refer to the respective directories.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#issues","title":"Issues","text":"<p>The <code>renameat</code> syscall is vulnerable to TOCTOU issues. This can cause unexpected behavior if the file path or file descriptor becomes invalid between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#related-events","title":"Related Events","text":"<ul> <li>openat - open a file relative to an existing file descriptor.</li> <li>unlinkat - delete a file or directory, relative to an existing file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/","title":"renameat2","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#intro","title":"Intro","text":"<p>renameat2 - Atomically change the name and/or location of a file relative to two directories.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#description","title":"Description","text":"<p>renameat2 is used to rename or move a file from one directory to another. It is similar to renameat, but allows for additional flags to be specified for more fine grained control. The flags can be used to set the behavior when the target of the rename operation is a non-directory file, when a rename operation is attempted across file system boundaries, and when the target of the rename operation already exists. </p>"},{"location":"docs/events/builtin/syscalls/renameat2/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - A file descriptor referring to the old directory, or AT_FDCWD (use the current working directory). </li> <li><code>oldpath</code>:<code>const char*</code>[U] - The relative pathname of the file to be renamed.</li> <li><code>newdirfd</code>:<code>int</code>[K] - A file descriptor referring to the new directory, or AT_FDCWD (use the current working directory).</li> <li><code>newpath</code>:<code>const char*</code>[U] - The relative pathname of the file to be created. </li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags which can be used to change the behavior of the call. These flags are specified as bitwise OR of the values, RENAME_EXCHANGE, RENAME_NOREPLACE, and RENAME_WHITEOUT.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#do_rename","title":"do_rename","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#type","title":"Type","text":"<p>Ftrace</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#purpose","title":"Purpose","text":"<p>To track all rename operations across multiple subsystems for debugging and to detect malicious files.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#example-use-cases","title":"Example Use Cases","text":"<p>One example of a use case for this event would be a security audit of a system. By analyzing the flow of files and processes, an auditor could identify any suspicious events such as potential malware or privilege escalation attempts.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#issues","title":"Issues","text":"<p>This syscall is vulnerable to race conditions, as the former and new paths of the file are evaluated at different times. The RENAME_EXCHANGE flag can be used to atomically trade two files, which solves the race condition issue.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#related-events","title":"Related Events","text":"<p>The renameat syscall can be used in a similar fashion as renameat2, though it does not have the flags parameter and cannot set the behavior in edge cases. Additionally, the process_exec syscall can be used to detect when a user is attempting to execute a malicious file.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/request_key/","title":"request_key","text":""},{"location":"docs/events/builtin/syscalls/request_key/#intro","title":"Intro","text":"<p>request_key - create or update an object based on a given type, description and callout information.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#description","title":"Description","text":"<p>request_key is a system call used to create an object of a given type, with a specified description, and callout information that could be used by a userspace program to process that object. The call will return a key serial, which is the id associated with the created object. The request key call can also be used to update an existing object; this is done by providing the same type and description, and an updated callout info, and the key serial of the object needing to be updated.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>const char*</code>[K] - the type of the object.</li> <li><code>description</code>:<code>const char*</code>[K] - description of the object.</li> <li><code>callout_info</code>:<code>const char*</code>[K] - callout information that can be processed by an userspace program.</li> <li><code>dest_keyring</code>:<code>key_serial_t</code>[K] - the key serial of the keyring that will receive the new/updated object (defaults to the current thread keyring).</li> </ul>"},{"location":"docs/events/builtin/syscalls/request_key/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/request_key/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/request_key/#request_key_1","title":"request_key","text":""},{"location":"docs/events/builtin/syscalls/request_key/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/request_key/#purpose","title":"Purpose","text":"<p>To trace and log the creation/update of an object passed to the request_key system call.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#example-use-case","title":"Example Use Case","text":"<p>A use case example for request_key is an authentication system or encryption program. request_key can be called with the callout_info set to the user information and encrypted with the users public key, allowing the userspace application to verify the caller is the same user that encrypted the object.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#issues","title":"Issues","text":"<p>request_key could be vulnerable to TOCTOU attack, where the value of the object being updated is checked before the update and then changed before the update finishes its operations.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#related-events","title":"Related Events","text":"<ul> <li>keyctl_describe_key - get information about a given key.</li> <li>keyctl_delete_key - delete a key.</li> <li>keyctl_read - read the contents of a key.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/","title":"restart_syscall","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#intro","title":"Intro","text":"<p>restart_syscall - Restarts a stopped system call that was previously interrupted by a signal</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#description","title":"Description","text":"<p>The <code>restart_syscall</code> system call restarts a previously suspended system call using the <code>SA_RESTART</code> flag supplied when setting a signal handler with <code>sigaction</code>. This system call restarts the call which was previously interrupted using <code>sigprocmask</code> and allows execution to continue where it left off. This system call is useful in situations where a signal was handled by a signal handler, such as when a child process is killed, but without restarting the system call, execution could be left in an inconsistent state.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#arguments","title":"Arguments","text":"<ul> <li><code>None</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#available-tags","title":"Available Tags","text":"<ul> <li>None</li> </ul>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#sys_restart_syscall","title":"sys_restart_syscall","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#purpose","title":"Purpose","text":"<p>Tracing restarted system calls to monitor the impact of signals in the system.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#example-use-case","title":"Example Use Case","text":"<p>Tracing restarted system calls to detect a system call that is taking too long to complete, or to determine how long it takes to restart a system call.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#issues","title":"Issues","text":"<p>There may be some system calls which cannot be restarted, and in those cases the <code>restart_syscall</code> system call may fail.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#related-events","title":"Related Events","text":"<ul> <li>sigaction</li> <li>sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/","title":"rmdir","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#intro","title":"Intro","text":"<p>rmdir - delete an empty directory</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#description","title":"Description","text":"<p>The rmdir() system call deletes an empty directory. The directory must be empty, and the calling process must have the necessary permissions to delete it. It is possible to use relative pathnames to remove directories that are not in the current working directory.</p> <p>The rmdir() system call is often used to remove a parent directory that contains a now-unneeded subdirectory. For example, if an application creates a subdirectory \"foo\" under \"/tmp\", it should call rmdir() on \"/tmp/foo\" as soon as the subdirectory is no longer needed.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char</code>* - The pathname of the directory to delete.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rmdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rmdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#do_rmdir","title":"do_rmdir","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#purpose","title":"Purpose","text":"<p>To inspect when an empty directory is deleted.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#example-use-case","title":"Example Use Case","text":"<p>Using rmdir in order to remove a directory created by an application after it is no longer needed.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#issues","title":"Issues","text":"<p>The rmdir system call will fail if the directory is not empty. Furthermore, it will not delete directories that contain files that have been unlinked, but are still open.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#related-events","title":"Related Events","text":"<ul> <li>unlink: to delete a file from a directory.</li> <li>rename: to rename or move a directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rseq/","title":"rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#intro","title":"Intro","text":"<p>rseq - registers a specified region in a given address space before user-level code execution.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#description","title":"Description","text":"<p>rseq is a Linux syscall that enables user-level code to register and reserve a specific memory region for exclusive execution without outside interruption. It does this by reserving a specific address space for exclusive execution and using the kernel to enforce atomicity of this exclusive code region. The main purpose of rseq is to provide a lightweight concurrency mechanism for multithreaded applications. This syscall is useful when implementing certain performance optimizations, such as loop-level parallelism, where it is critical that only one thread is allowed to execute a specific region of code.</p> <p>The syscall takes a pointer to a region event structure (struct rseq), the length of that structure, an optional flags argument, and an optional signal argument. The flags are used to indicate what kind of operations the application wishes to perform, such as reading or writing memory. The signal argument allows the application to optionally specify a signal to be sent to the calling process if the operation fails.</p> <p>By using rseq, user-level code can register and reserve a specific memory region for exclusive execution that is guaranteed to return success or failure atomically.  It is important to note, however, that rseq is currently only supported on 64-bit x86 systems and Linux kernel versions 4.13 and later.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#arguments","title":"Arguments","text":"<ul> <li><code>rseq</code>: <code>struct rseq*</code>[KU] - Pointer to the data structure used to specify a region for exclusive execution. </li> <li><code>rseq_len</code>: <code>u32</code>[KU] - Length of the data structure in bytes. Must be given as an argument for safety reasons.</li> <li><code>flags</code>: <code>int</code>[K] - Optional argument to indicate what kind of operations the application wishes to perform.</li> <li><code>sig</code>: <code>u32</code>[K] - Optional argument to specify a signal to be sent to the calling process if rseq fails.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rseq/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rseq/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rseq/#do_rseq","title":"do_rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#purpose","title":"Purpose","text":"<p>retrieve the arguments for the syscall, then store them as part of the context related to the calling process</p>"},{"location":"docs/events/builtin/syscalls/rseq/#sys_rseq","title":"sys_rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#type_1","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#purpose_1","title":"Purpose","text":"<p>Verifiy that the parameters retrieved by the previous probe are valid before attempting to execute the actual system call.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#example-use-case","title":"Example Use Case","text":"<p>rseq is useful when implementing certain performance optimizations, where it is critical that only one thread is allowed to execute a specific region of code. An example would be loop-level parallelism, where a programmer can take advantage of multiple CPU cores to increase the performance of loops. </p>"},{"location":"docs/events/builtin/syscalls/rseq/#issues","title":"Issues","text":"<p>rseq is currently only supported on 64-bit x86 systems and Linux kernel versions 4.13 and later. It is also not yet supported on memory model architectures, like ARM.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#related-events","title":"Related Events","text":"<p>The <code>rseq</code> system call can be used in conjunction with the <code>set_tid_address</code> system call to create a reliable thread-local region event.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/","title":"rt_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#intro","title":"Intro","text":"<p>rt_sigaction - install or confirm action for specified signal.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#description","title":"Description","text":"<p><code>rt_sigaction</code> is a system call that changes the action taken by a process on receipt of a specific signal. Signal actions are explained in signal(7).</p> <p>Using <code>rt_sigaction</code>, a process can specify the action to be taken when a specific signal is delivered. This can include ignoring the signal, catching it with a signal handler, or setting a flag in the process's signal mask. </p> <p><code>rt_sigaction</code> is available on Linux systems and is a more recent, improved way of setting signal handlers compared to <code>signal</code> syscall. It can be used to install signal handlers that take an extra parameter, an <code>ucontext_t *</code>, which will be used by the handler to store the context of the signal where it was caught.</p> <p>The main advantage of using this system call over the <code>signal</code> syscall is that it allows for the setting of a real-time signal, in addition to the usual POSIX signals. A critical limitation of the <code>signal</code> syscall is that it does not provide a way to set real-time signals, which are useful for applications needing to respond quickly to events.</p> <p><code>rt_sigaction</code> is also useful for working with signals that have been registered using <code>sigaction</code>. For example, <code>sigaction</code> can be used to register a signal handler, but <code>rt_sigaction</code> is the only way to retrieve the currently installed signal handler. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>signum</code>:int[K] - Signal to be handled, which can either be a POSIX signal or real-time signal.</li> <li><code>act</code>:const struct sigaction*[K] - New signal action, or NULL to restore default action.</li> <li><code>oldact</code>:struct sigaction*[K] - Output parameter which will return the previous signal action, or NULL if not required.</li> <li><code>sigsetsize</code>:size_t[K] - Size of the sigset specified by <code>act</code> in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#purpose","title":"Purpose","text":"<p>Hook function to capture signal handler changes made using <code>rt_sigaction</code> syscall. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#signal_deliver_stop","title":"signal_deliver_stop","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#purpose_1","title":"Purpose","text":"<p>Hook function to capture signals as they are delivered to the process. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#example-use-case","title":"Example Use Case","text":"<p><code>rt_sigaction</code> can be used to enable a process to react quickly to a signal sent from another process, or another thread in the same process. For example, a signal handler can be registered with <code>rt_sigaction</code> that sets a flag when the signal is received. The flag can then be checked in an application loop, and its presence will trigger an action. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#issues","title":"Issues","text":"<p>It is possible to register a signal handler using <code>rt_sigaction</code> that does not take an additional parameter for the <code>ucontext_t *</code>, even though this parameter is required for real-time signals. While this will work for most OS versions without failing, this may cause unexpected results or failures on some systems. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#related-events","title":"Related Events","text":"<p><code>signal</code>, <code>rt_sigprocmask</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/","title":"rt_sigpending","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#intro","title":"Intro","text":"<p>rt_sigpending - examine a pending signal mask</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#description","title":"Description","text":"<p>The rt_sigpending() system call asks the kernel to store the currently pending signal set for the calling process in the location pointed to by <code>set</code>. The <code>sigsetsize</code> argument specifies the size (in bytes) of the memory pointed to by <code>set</code>.</p> <p>The purpose of this system call is to allow applications to examine the set of signals which are currently blocked for the caller's execution. This could be useful for synchronizing processes waiting on signals, or to simply query their signal state.</p> <p>There are some edge cases or drawbacks to using rt_sigpending, particularly with regard to thread-safe signal handling. If the signal set in <code>set</code> is not protected by a mutex or other thread-safe mechanisms, multiple threads may race to modify the signal set and cause unexpected results. Furthermore, the kernel may not be able to accurately detect any pending signals if an application handles them with a signal handler, as the pending signals may be consumed before the kernel can list them.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>sigset_t*</code>[U] - pointer to a sigset_t type in user space.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - The size of the <code>set</code> argument in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#do_rt_sigpending","title":"do_rt_sigpending","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#purpose","title":"Purpose","text":"<p>The do_rt_sigpending() function is the kernel entry point for the rt_sigpending system call. It is responsible for copying the set of pending signals for the calling process into the location pointed to by <code>set</code>. It is hooked with a Kprobe to provide userspace visibility into the details of pending signal sets.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#example-use-case","title":"Example Use Case","text":"<p>An example use case for rt_sigpending() is to query the current blocked signal set of the calling process. This is useful to synchronize processes waiting on signals, or to simply query the process's blocked signal state.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#issues","title":"Issues","text":"<p>No issues have been identified with the rt_sigpending system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#related-events","title":"Related Events","text":"<ul> <li>sighandler - Set a signal handler for a given signal. May be useful to set a handler for the signal which is blocked.</li> <li>sigprocmask - Examine or change the blocked signal set of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/","title":"rt_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#intro","title":"Intro","text":"<p>rt_sigprocmask - examine and change a signal mask</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#description","title":"Description","text":"<p>rt_sigprocmask is a system call used to examine and change a signal mask for a process. The signal mask is a set of signals used to control what signals are blocked and thus not delivered to a process. It also allows for the manipulation of the process' signal mask atomically (in one instruction). The rt_sigprocmask system call is a realtime version of the sigprocmask system call, and will preserve the realtime signals.</p> <p>There are some edge cases to be aware of when using rt_sigprocmask. For example, if the sigsetsize parameter is greater than the size of a sigset_t (128 bytes on 64-bit architectures), then the call will fail with EINVAL.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#arguments","title":"Arguments","text":"<ul> <li><code>how</code>:<code>int</code> - Specifies how the signal mask is to be changed. It is one of the following constants:</li> <li>SIG_BLOCK: The resulting set is the union of the current set and the set argument.</li> <li>SIG_UNBLOCK: The resulting set is the intersection of the current set and the complement of the set argument.</li> <li>SIG_SETMASK: The resulting set is the set argument.</li> <li><code>set</code>:<code>sigset_t*</code>[K] - Pointer to a signal set whose elements will be added (SIG_BLOCK) or deleted (SIG_UNBLOCK) from the current set.</li> <li><code>oldset</code>:<code>sigset_t*</code> - Pointer to a signal set which will be filled with the old signal mask.</li> <li><code>sigsetsize</code>:<code>size_t</code> - The size of the signal set oldset in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#do_rt_sigprocmask","title":"do_rt_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#purpose","title":"Purpose","text":"<p>This function is hooked to enable monitoring of the behavior of the rt_sigprocmask system call. With this hook, you can monitor when the system call is called and how long the call takes.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#example-use-case","title":"Example Use Case","text":"<p>One example of where this event could be useful is in monitoring system calls for benchmarking applications. By monitoring the rt_sigprocmask system call you can measure how long this system call takes to execute, which can give an indication of how fast the overall application is.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#issues","title":"Issues","text":"<p>One issue to be aware of when using this system call is that it is vulnerable to a time-of-check-to-time-of-use (TOCTOU) race condition due to the fact that the signal mask can be changed between the time of the check and the time of the use.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#related-events","title":"Related Events","text":"<ul> <li>rt_sigaction()</li> <li>sigprocmask()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/","title":"rt_sigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#intro","title":"Intro","text":"<p>rt_sigqueueinfo - send a signal with associated data to a thread</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#description","title":"Description","text":"<p>The <code>rt_sigqueueinfo()</code> system call sends a signal, <code>sig</code>, and associated data, <code>info</code>, to the thread identified by <code>tgid</code>. This call is like <code>kill()</code>, but allows to pass the extra data.</p> <p>Compared to <code>sigqueue()</code>, the <code>info</code> is passed as a pointer rather than an argument.</p> <p>The <code>siginfo_t</code>data type typically includes signal information such as signal number and sender information. </p> <p>In  kernels prior to 2.6.9, the <code>info</code> argument is limited to a <code>si_value</code> value, which indicate the signal value.</p> <p>Using <code>rt_sigqueueinfo</code> has some advantages: * It can pass the additional data, such as <code>si_value</code>, for signal information. * Its use is thread-safe.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>pid_t</code>[K] - thread group identifier for which signal is to be sent.</li> <li><code>sig</code>:<code>int</code>[U] - signal to be sent.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - signal info.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#do_sigaction","title":"do_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#purpose","title":"Purpose","text":"<p>To get the signal information before being sent.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#example-use-case","title":"Example Use Case","text":"<p>An example use case of rt_sigqueueinfo is when an application needs to send a signal with data from kernel-space to a thread in user-space.  It can be used to report information about a critical event or abort a process.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#issues","title":"Issues","text":"<ul> <li>The signal info (<code>siginfo_t</code>) is limited to a <code>si_value</code> value for kernels   prior to 2.6.9.</li> <li>The third argument, <code>info</code>, is a pointer to user space. Therefore, information   from user space might not be reliable, as it might be subject to TOCTOU   attacks.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#related-events","title":"Related Events","text":"<ul> <li><code>kill()</code> - send a signal to a process.</li> <li><code>sigqueue()</code> - send a signal with data to a process or thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/","title":"rt_sigreturn","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#intro","title":"Intro","text":"<p>rt_sigreturn - System call to return from user-owned signal handlers</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#description","title":"Description","text":"<p>The <code>rt_sigreturn</code> system call restores the caller's user-space context previously saved by the kernel at the occurrence of a signal. It is used on architectures that don't store the user-space registers (in particular context) when a signal handler is invoked by the kernel, so the user-space has to do it instead. After restoring the context, the <code>rt_sigreturn</code> call will return to the address the execution was at before the signal happened. </p> <p>It's important to note that returning from a signal handler or restarting a system call instead of executing a <code>sigreturn</code> call may be a source of bugs which could lead to privilege escalation or other vulnerabilites. In addition, due to the race conditions which are present due to the nature of the signal handling in Linux, it is vulnerable to TOCTOU attacks as noted below.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#arguments","title":"Arguments","text":"<ul> <li><code>ustack</code>:<code>pointer</code>[KU] - Pointer to the user-space signal stack context. The signal stack context is defined by each architecture.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#sys_rt_sigreturn","title":"sys_rt_sigreturn","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#type","title":"Type","text":"<p>Trampoline</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#purpose","title":"Purpose","text":"<p>To capture the context when a signal handler exits.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#example-use-case","title":"Example Use Case","text":"<p>An example use-case for <code>rt_sigreturn</code> is for tracing signal handler return paths, for example for debugging purposes or for catching vulnerabilities. All the user-space registers and the stack content used when the signal handler was called can be obtained from the <code>ustack</code> argument. This data could be used in order to detect if a bug or an exploit has been triggered. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#issues","title":"Issues","text":"<p><code>rt_sigreturn</code> can be used in an attempt of privilege escalation if an attacker can find a way to modify the <code>ustack</code> argument which is only present in kernel-space. In addition, <code>rt_sigreturn</code> is vulnerable to TOCTOU (time of check, time of use) attacks, since it can be interrupted before the operation is completely finished.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#related-events","title":"Related Events","text":"<ul> <li>signal - system call used to send signals to processes.</li> <li>signal handler - signal handlers are functions called by the kernel when a signal is delivered.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/","title":"rt_sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#intro","title":"Intro","text":"<p>rt_sigsuspend - temporarily replace the signal mask and wait for a signal</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#description","title":"Description","text":"<p>The rt_sigsuspend() system call is used to temporarily replace the signal mask of the calling process and wait for a signal to be delivered. It is a layer on top of the sigprocmask() system call which atomically performs the operations of replacing the signal mask and suspending execution of the calling thread. It is mostly used in signal handlers when temporarily blocking the signal the handler is responding to.</p> <p>The main advantage of this system call is that it does not require the user to pass the current blockmask when temporarily replacing it.</p> <p>However, there are some drawbacks when using rt_sigsuspend(). Firstly, the process resumes execution from the same address it was interrupted in (as opposed to other system calls such as sigsuspend() which resumes execution from the start of the signal handler). This can lead to the atomicity issues when signals are delivered while the process is trying to do several operations, leading to inconsistent states. Secondly, it can only be used in signal handlers and is not appropriate for other synchronisation tasks.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:<code>sigset_t*</code>[K, U] - pointer to user space memory which holds the signal mask to be replaced.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - size of the mask in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#do_rt_sigsuspend","title":"do_rt_sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#purpose","title":"Purpose","text":"<p>Tracing when the rt_sigsuspend system call is executed. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#example-use-case","title":"Example Use Case","text":"<p>Tracing when a process invokes the rt_sigsuspend system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask - get blocked signals or set blocked signals</li> <li>sigsuspend - suspend process until signal</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/","title":"rt_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#intro","title":"Intro","text":"<p>rt_sigtimedwait - a system call that waits for a signal to arrive</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#description","title":"Description","text":"<p>rt_sigtimedwait is a system call that atomically waits for a signal to arrive and removes the signal from the queue. It operates similarly to the pselect() system call, except it waits for a signal instead of a file descriptor to become readable and writable. The set parameter specifies the set of signals to wait for, info points to a structure where information about the signal caught is stored, timeout specifies an upper limit on the amount of time that the call should block, and sigsetsize specifies the size of the signal set in bytes. </p> <p>This system call should not be used if the signal being waited for is handled by a signal handler registered by sigaction(). In such cases, the signal is delivered directly to the signal handler instead of the process's signal queue.</p> <p>The event can cause the calling process to sleep until the signal is received or the timeout has reached. Additionally, real-time signals that are not caught or ignored by the process may cause it to terminate.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>const sigset_t*</code>[K] - a pointer to a structure to examine a set of signals that the process may be waiting for.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - a pointer to a structure where information about the signal caught is stored.</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K] - a pointer to a structure that specifies an upper limit on the amount of time that the call should block.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - the size of the signal set in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#rt_sigtimedwait_1","title":"rt_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#type","title":"Type","text":"<p>Kernel function</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#purpose","title":"Purpose","text":"<p>Hooked to monitor the use and arguments of the system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#example-use-case","title":"Example Use Case","text":"<p>rt_sigtimedwait can be used to create a timeout mechanism by waiting for a signal in a loop. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#issues","title":"Issues","text":"<p>One of the key drawbacks of using rt_sigtimedwait is that the process may sleep until the signal arrives or the timeout has been reached, which may be undesirable in cases where having a responsive application is important.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#related-events","title":"Related Events","text":"<ul> <li>sigaction() - the system call to register a signal handler</li> <li>sigprocmask() - the system call to examine and change the currently blocked signals</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/","title":"rt_sigtimedwait_time32","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#intro","title":"Intro","text":"<p>rt_sigtimedwait_time32 - wait synchronously for queued signals arising within a given time</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#description","title":"Description","text":"<p>rt_sigtimedwait_time32 is a system call that allows waiting for one of the pending signals occurring in the signal set <code>uthese</code> with a timeout of <code>uts</code>, which is rounded up to the system clock granularity (specified by <code>uts</code>). The signal's number and its associated <code>uinfo</code> are returned in the <code>uinfo</code> argument if available. <code>sigsetsize</code> is used to indicate size in bytes of the signal set pointed by <code>uthese</code>. Status of the signal for which the call was unblocked is returned. The time is limited by the <code>uts-&gt;tv_sec</code> and <code>uts-&gt;tv_nsec</code> arguments. If timeout is set to 0 and no signals are present on the queue, then this will cause an error. </p> <p>This system call provides an easy to use way to wait for signals that arrive over a short period of time with the benefit of minimizing the chances of missing them.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#arguments","title":"Arguments","text":"<ul> <li><code>uthese</code>:<code>sigset_t*</code> - pointer to a signal set containing the signals which are to be waited for. <li><code>uinfo</code>:<code>siginfo_t*</code>[K] - pointer to a <code>siginfo_t</code> structure to store the information about the signal, may be <code>NULL</code>.</li> <li><code>uts</code>:<code>struct old_timespec32*</code>[K] - a structure that specifies the end time for the timeout, may be <code>NULL</code>.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - number of bytes in the signal set pointed to by <code>uthese</code>.</li>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#do_sigtimedwait","title":"do_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#purpose","title":"Purpose","text":"<p>This function is hooked to measure the time it takes for each time <code>rt_sigtimedwait_time32</code> system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#old_sigaction","title":"old_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#purpose_1","title":"Purpose","text":"<p>This function is hooked to record some information related to the signals and their structure when it is used in conjunctiob with the <code>rt_sigtimedwait_time32</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#example-use-case","title":"Example Use Case","text":"<p>The rt_sigtimedwait_time32 system call can be used to wait on synchronous signals arrivals with a given timeout, which is useful in workflows and systems which depend on real-time performance. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#issues","title":"Issues","text":"<p>rt_sigtimedwait_time32 is susceptible to TOCTOU (time of check, time of use), because between the check and the actual use of the signal, the signal might change. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#related-events","title":"Related Events","text":"<ul> <li>rt_sigtimedwait</li> <li>rt_sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/","title":"rt_tgsigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#intro","title":"Intro","text":"<p>rt_tgsigqueueinfo - send signal information to a specific thread in a specific process.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#description","title":"Description","text":"<p>The rt_tgsigqueueinfo() system call sends the signal sig with the additional information provided in info to any thread with the thread ID tid, who is part of the process with process ID tgid.</p> <p>This syscall was developed to create a non-intrusive way to work with threads, not to risk them being suddenly paused or interrupted, as those events could cause lost progress.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>pid_t</code> - the process ID (tgid) of the targeted process.</li> <li><code>tid</code>:<code>pid_t</code> - the thread ID (tid) of the targeted thread within the process identified by tgid.</li> <li><code>sig</code>:<code>int</code> - the signal to send.</li> <li><code>info</code>:<code>siginfo_t*</code>[K U] - Data to be sent to the thread, defined in a _siginfo_t struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#do_rt_tgsigqueueinfo","title":"do_rt_tgsigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#purpose","title":"Purpose","text":"<p>To trace the system calls and arguments of this event.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#example-use-case","title":"Example Use Case","text":"<p>The rt_tgsigqueueinfo() system call can be used to send a signal to a specific thread within a specific process. This is often used for communication within multithreaded programs, or for debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#issues","title":"Issues","text":"<p>Due to the non-intrusive nature of this system call, there may be issues with latency as it does not force a thread to accept the signal if not ready for it.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#related-events","title":"Related Events","text":"<ul> <li>sigaction() - Used to set up a signal handler.</li> <li>waitid() - Used to wait for a thread to stop or signal to be delivered.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/","title":"<code>sched_get_priority_max</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#intro","title":"Intro","text":"<p><code>sched_get_priority_max</code> - get the maximum priority value for a given scheduling policy</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#description","title":"Description","text":"<p>The <code>sched_get_prority_max</code> function returns the maximum priority value allowed by a given scheduling policy. It is used to obtain the highest allowed scheduling priority for the specified policy of a particular process.</p> <p><code>sched_get_priority_max</code> is most commonly used in combination with the <code>sched_get_priority_min</code> syscall, which returns the minimum priority value allowed by a given policy. Together, the two syscalls allow the range of valid scheduling priorities to be determined. It returns the maximum value allowed according to the operating systems configuration, but this value may be limited by the user or system.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#arguments","title":"Arguments","text":"<ul> <li><code>policy</code>: <code>int</code>[K] - Specifies the scheduling policy for which the maximum priority value is to be returned. </li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#sched_get_priority_max_1","title":"<code>sched_get_priority_max</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#type","title":"Type","text":"<p>kprobes </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#purpose","title":"Purpose","text":"<p>To obtain the maximum priority value for a given scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to get task or thread priority values in order to properly manage the scheduling of threads in a system.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#related-events","title":"Related Events","text":"<ul> <li><code>sched_get_priority_min</code> - get the minimum priority value for a given scheduling policy.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/","title":"sched_get_priority_min","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#intro","title":"Intro","text":"<p>sched_get_priority_min - returns the minimum priority value that can be used with the scheduling policy</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#description","title":"Description","text":"<p>This system call is used to get the minimum priority value that can be used when using the scheduling policy mentioned as the parameter. This call will usually return -1 if the policy is invalid, and will return the minimum priority value that can be used with the scheduling policy upon successful completion. </p> <p>There are a few drawbacks when using this system call. Firstly, it may be too restrictive in that it is limited to only one scheduling policy, meaning if multiple scheduling policies are used, multiple separate calls are needed. Additionally, the accuracy of the minimum priority value depends on the implementation of the OS, and may not be as precise as desired. </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#arguments","title":"Arguments","text":"<ul> <li><code>policy</code>:<code>int</code>[K] - a scheduling policy identified by an integer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#sched_get_priority_min_1","title":"sched_get_priority_min","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#purpose","title":"Purpose","text":"<p>To inform the user of the minimum priority value that can be used in the given scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#example-use-case","title":"Example Use Case","text":"<p>This system call can be utilized to define the limits on the chosen priorities for various threads in a multithreading application.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#issues","title":"Issues","text":"<p>There can be a margin of error present when considering the minimum priority values, depending on the implementation of the OS. </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#related-events","title":"Related Events","text":"<p>sched_get_priority_max, sched_setscheduler, sched_setparam</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/","title":"sched_getaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#intro","title":"Intro","text":"<p>sched_getaffinity - retrieve the CPU affinity of a process</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#description","title":"Description","text":"<p>The sched_getaffinity() system call retrieves the CPU affinity mask of the process whose ID is specified in pid, and places it in the cpusetsize bytes of memory pointed to by mask. </p> <p>The CPU affinity mask is a bit mask where each bit represents a CPU that the process is able to execute on. A set bit signifies that a CPU is able to be used while an unset bit signifies that the CPU is unavailable.  The argument cpusetsize is the size of the mask pointed to by mask and must not be smaller than the size of the kernel's internal CPU mask, returned by sysconf(_SC_NPROCESSORS_ONLN).</p> <p>This system call is useful for optimizing the process's compatibility when switching between systems with different numbers of processors.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[U] - process ID of the thread whose affinity is to be retrieved.</li> <li><code>cpusetsize</code>:<code>size_t</code>[U] - number of bytes in the bitmask pointed to by mask.</li> <li><code>mask</code>:<code>unsigned long*</code>[U] - pointer to a bit mask for the CPUs on which the thread may run.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#sys_sched_getaffinity","title":"sys_sched_getaffinity()","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#purpose","title":"Purpose","text":"<p>To monitor the state of CPU affinity for different threads. </p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for this system call would be to ensure that a user's thread or process is only running on one CPU or multiple CPUs across different physical processors. </p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#issues","title":"Issues","text":"<p>The most common issue with this system call is when the size of the mask pointed to by mask is not sufficient to contain the kernel's internal CPU mask, leading to truncation of the actual CPU mask.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#related-events","title":"Related Events","text":"<ul> <li>sched_setaffinity(): Set the CPU affinity mask of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/","title":"sched_getattr","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#intro","title":"Intro","text":"<p>sched_getattr - Retrieve scheduling policy and attributes from a given process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#description","title":"Description","text":"<p>The <code>sched_getattr()</code> system call retrieves the scheduling policy and attributes of a given process. It allows for retrieving of scheduling policy and attributes of other processes, if given the appropriate privileges. It supports the following flags: <code>SCHED_FLAG_KEEP_POLICY</code>, <code>SCHED_FLAG_KEEP_PARAMS</code>, and <code>SCHED_FLAG_ALLOW_NULL</code>. The <code>attr</code> argument is a pointer to a <code>struct sched_attr</code>, which stores the scheduling parameters.</p> <p>The <code>sched_getattr()</code> system call retrieves the scheduling attributes of the given process. When used with the <code>SCHED_FLAG_KEEP_POLICY</code> and <code>SCHED_FLAG_KEEP_PARAMS</code> flags, this allows for retrieving of scheduling policy and attributes of other processes, if given the appropriate privileges.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - The pid of the process to query.</li> <li><code>attr</code>:<code>struct sched_attr*</code>[K] - A pointer to a <code>struct sched_attr</code> where the retrieved attributes will be stored.</li> <li><code>size</code>:<code>unsigned int</code>[K] - The size of the <code>struct sched_attr</code> in bytes.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags specifying how the scheduling attributes should be retrieved, allowed values are <code>SCHED_FLAG_KEEP_POLICY</code>, <code>SCHED_FLAG_KEEP_PARAMS</code>, and <code>SCHED_FLAG_ALLOW_NULL</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#sys_sched_getattr","title":"<code>sys_sched_getattr</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#purpose","title":"Purpose","text":"<p>To monitor retrieval of scheduling attributes of a given process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#example-use-case","title":"Example Use Case","text":"<p>An administrator who needs to monitor scheduling policies of other processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#issues","title":"Issues","text":"<p>This system call requires appropriate privileges in order to monitor processes of other users.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#related-events","title":"Related Events","text":"<ul> <li><code>sched_setattr</code> - Set scheduling policy and attributes for a given process. </li> <li><code>sched_setscheduler</code> - Set the scheduling policy for a given process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/","title":"sched_getparam","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#intro","title":"Intro","text":"<p>sched_getparam - fetch scheduling parameters of the target process</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#description","title":"Description","text":"<p>sched_getparam is a function used to modify the scheduling parameters of the target process with the given pid according to the changes specified in the second argument, the parameters of the used scheduling policy. It is often used by system administrators to make sure that a certain process is always given the same priority relative to other processes on the system.</p> <p>One of the advantages of using this function over other methods of setting policy parameters is that it works with any policy, regardless of the number of parameters. This can save time when configuring policies that have a large number of parameters, as the system administrator does not have to manually set each parameter individually.</p> <p>One of the drawbacks is that it is not an atomic operation. If the pid argument provided is the same as the pid of the calling process, then the operation may take a relatively long time, as the operation must first be carried out on the caller's process, then on the target process. This operation can also lead to race conditions if the pid of the calling process and the pid of the target process are both the same.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:pid_t[K] - pid of the process to query the parameters of.</li> <li><code>param</code>:struct sched_param*[K+U] - pointer to a struct sched_param to store the policy information in.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#do_sys_sched_getparam","title":"do_sys_sched_getparam","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#purpose","title":"Purpose","text":"<p>Collecting information about the scheduling parameters of a particular process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#example-use-case","title":"Example Use Case","text":"<p>sched_getparam can be used in a monitoring process which keeps track of the scheduling parameters of processes, in order to ensure that they do not \"starve\" in terms of resources and can run to completion.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#issues","title":"Issues","text":"<p>The operation is not atomic, which may lead to race conditions with multiple threads trying to access the same process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler - set scheduling policy and parameters of the target process </li> <li>sched_get_priority_min - get the minimum priority value for the given scheduling policy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/","title":"sched_getscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#intro","title":"Intro","text":"<p>sched_getscheduler - Retrieve the scheduling policy of a process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#description","title":"Description","text":"<p>The sched_getscheduler() system call retrieves the scheduling policy currently applied to the process identified by pid. If pid is zero, the policy of the calling process is retrieved. </p> <p>The available scheduling policies are: * SCHED_OTHER - the traditional time-sharing policy. * SCHED_FIFO   - a first-in, first-out policy * SCHED_RR     - a round-robin policy</p> <p>sched_getscheduler() can be used to retrieve the currently used scheduling policy for any process, allowing for the comparison of different policies for a process or for multiple processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - The tid of the process whose policy will be retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#hooks","title":"Hooks","text":"<p>No functions are hooked in order to allow execution of the system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used in the context of a monitoring application to compare scheduling policies between different processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#related-events","title":"Related Events","text":"<p>The system call <code>sched_setscheduler</code> is related to this system call, as it allows for the setting of the scheduling policy for a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/","title":"sched_rr_get_interval","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#intro","title":"Intro","text":"<p>sched_rr_get_interval - get the time quantum for a given pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#description","title":"Description","text":"<p>This syscall is used to get the current time quantum for the real-time scheduler for a given process. This allows for useful information about the scheduling policy for a particular process to be retrieved. Additionally, this syscall can be used in debugging applications to help identify exactly which process is consuming resources in an unexpected way.</p> <p>There are, however, some caveats to using this syscall. On some operating systems, the time quantum may not be reset when a real-time process is stopped or suspended. This can lead to unexpected behavior if a process is stopped or suspended in the middle of its time quantum. There are also some caveats with regard to pre-emption on some operating systems with regard to real-time processes, so care should be taken to ensure that any processes using this syscall will not suffer any ill effects due to pre-emption.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the pid of the process for which the time quantum should be retrieved.</li> <li><code>tp</code>:<code>struct timespec*</code>[U] - a pointer to a timespec structure which will be filled in with the time quantum for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#sched_rr_get_interval_1","title":"sched_rr_get_interval","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#purpose","title":"Purpose","text":"<p>Debugging and monitoring purposes.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#example-use-case","title":"Example Use Case","text":"<p>sched_rr_get_interval can be used to retrieve the time quantum of a real-time process that is consuming more resources than expected.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#issues","title":"Issues","text":"<p>On some operating systems, the time quantum may not be reset when a real-time process is stopped or suspended. This can lead to unexpected behavior if a process is stopped or suspended in the middle of its time quantum.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler()</li> <li>sched_getparam()</li> <li>sched_getaffinity()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/","title":"sched_rr_get_interval_time32","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#intro","title":"Intro","text":"<p>sched_rr_get_interval_time32 - Retrieve the Round Robin scheduling interval of the thread with the corresponding pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#description","title":"Description","text":"<p>The sched_rr_get_interval_time32 system call is used to determine the current Round Robin scheduling interval of the thread with the corresponding pid. It retrieves the interval on which the thread will be executed in Round Robin scheduling. </p> <p>There are several drawbacks to this syscall such as the fact that it only works with threads, not processes. In addition, the time precision of the interval is limited to second granularity. It also has some advantages such as the ability to determine the scheduling order of tasks.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Thread ID of the thread of whom the scheduling interval will be retrieved.</li> <li><code>interval</code>:<code>struct old_timespec32*</code>[K] - Pointer to a structure of type old_timespec32 that will store the interval of the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#kernel_sched_rr_get_interval_time32","title":"kernel_sched_rr_get_interval_time32","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#purpose","title":"Purpose","text":"<p>To understand the structure of Round Robin scheduling and the duration of tasks in this scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#example-use-case","title":"Example Use Case","text":"<p>Monitoring and understanding the utilization of a CPU by a certain thread.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#issues","title":"Issues","text":"<p>This system call can only be used for threads, not processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler - To adjust scheduling policy and priority of processes</li> <li>sched_get_priority_min &amp; sched_get_priority_max - To check the priority range of the current scheduling policy in the system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/","title":"sched_setaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#intro","title":"Intro","text":"<p>sched_setaffinity - sets the CPU affinity mask of the process or thread with given pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#description","title":"Description","text":"<p>The <code>sched_setaffinity()</code> system call is used to set the CPU affinity mask of the process or thread with the specified <code>pid</code>.  The <code>cpusetsize</code> argument is the size in bytes of the data pointed to by <code>mask</code>.  This allows applications to set the processor affinity of threads to selected processors in a processor group.  This eliminates the need to rely on system scheduler to selecting a processor for a thread to execute on, and provides for more control for the user about the processor a particular thread will run on.</p> <p>The call will fail if the process does not have the appropriate privileges, or if the process does not exist.  In addition, it can fail if there are more bits in the <code>mask</code> than the system allows, or if the <code>mask</code> is invalid in some other way. </p> <p>Due to the amount of detail that goes into implementing an optimized thread scheduling strategy, there may be edge-cases or other considerations to take into account when using this system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>: <code>pid_t</code>[K] - The pid of the process or thread whose affinity mask should be set.</li> <li><code>cpusetsize</code>: <code>size_t</code>[K] - The size in bytes of the data pointed to by <code>mask</code>.</li> <li><code>mask</code>: <code>unsigned long*</code>[K] - A pointer to an array of unsigned longs that comprises the CPU affinity mask.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#do_sched_setaffinity","title":"do_sched_setaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#type","title":"Type","text":"<p>kprobe + uprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#purpose","title":"Purpose","text":"<p>To monitor when processes are setting the CPU affinity mask of their threads or child processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#example-use-case","title":"Example Use Case","text":"<p>For applications that need to be distributed across CPU cores, scheduling affinity allows programs to manually dictate the cores a process should use, rather than relying on the operating system's scheduler. For example, if a group of threads need to prioritize one process over another, scheduling affinity can be used to ensure threads are allocated to the appropriate cores.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#issues","title":"Issues","text":"<p>The scheduling affinity is not always respected if the load is heavy on the system. This means that processes may land on cores that were not originally assigned to them due to the demand. In addition, it may not be possible to set the affinity to cores that do not exist on the system, and so the appropriate checks must be made before calling the system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#related-events","title":"Related Events","text":"<p>sched_getaffinity - gets the CPU affinity mask of the process or thread with given pid.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/","title":"sched_setattr","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#intro","title":"Intro","text":"<p>sched_setattr - sets the scheduling policy and attributes of a process </p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#description","title":"Description","text":"<p>sched_setattr takes a pid, attr and flags and performs the setting of a process's scheduling policy and attributes. The only allowable scheduling policy is the SCHED_DEADLINE policy. The function returns the scheduling policy that has been set for the process. This function is useful to set up specific parameters for a process that require real-time scheduling.</p> <p>Edge cases that can occur when using this function include out of memory errors, when the system does not have enough memory to set the attributes specified, as well as policy errors, when attempting to set a policy that is not supported.</p> <p>Another issue that could possibly occur is related to the scheduling priority set by the scheduling policy, namely when attempting to set up a higher priority than what is allowed based on the system permissions. </p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - the process id of the process whose scheduling policy and attributes are to be set.</li> <li><code>attr</code>:<code>struct sched_attr*</code>[K] - the struct containing the scheduling policy, period and runtime and other scheduling details.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that can be used to override the default behavior of sched_setattr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#syscall_trace_enter","title":"syscall_trace_enter","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#purpose","title":"Purpose","text":"<p>Tracing system calls for debugging, performance analysis, and other various use cases.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#sched_setattr_1","title":"sched_setattr","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#purpose_1","title":"Purpose","text":"<p>To trace calls to sched_setattr, in order to debug the scheduling of processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#example-use-case","title":"Example Use Case","text":"<p>To verify the operation of application processes with real-time requirements.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#issues","title":"Issues","text":"<p>The flags argument of sched_setattr is currently not used.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#related-events","title":"Related Events","text":"<p>sched_getattr, sched_setscheduler, sched_getscheduler</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/","title":"sched_setparam","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#intro","title":"Intro","text":"<p>sched_setparam - sets parameters for a process in the scheduling process table</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#description","title":"Description","text":"<p>Sched_setparam is a Linux system call that sets parameters for a given process  in the scheduling process table. It changes the scheduling policy and parameters  associated with a given process. The scheduling policy is not changed, however the  parameters used for the selected policy are set for the process in question. This  helpful for defining more fine-grained scheduling controls.</p> <p>When a process has its scheduling parameters modified it can affect how the CPU  performs. It can also affect the way that a process interacts with users, which  can have an effect on user experience.</p> <p>There can be drawbacks to using sched_setparam, as setting the right schedules  parameters are quite complex and depend on a variety of factors, such as other  running processes, the architecture, and so on.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - This argument specifies the process ID of the process that  the scheduling parameters will be set to.</li> <li><code>param</code>:<code>struct sched_param*</code>[U] - This argument specifies a pointer to a  struct sched_param, which contains the scheduling parameters to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#do_sched_setparam","title":"do_sched_setparam","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#purpose","title":"Purpose","text":"<p>To log information about processes that are executing the do_sched_setparam  system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#sched_setscheduler","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#purpose_1","title":"Purpose","text":"<p>To capture the return value of the sched_setparam call in order to determine if the  scheduling parameters have been set successfully.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#example-use-case","title":"Example Use Case","text":"<p>One use case for this system call is using sched_setparam to set a certain CPU  scheduling priority for a certain process. This could be done if a process is  causing issues with other processes or user experience and needs to be given a  lower priority in order to allow other processes to run.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#issues","title":"Issues","text":"<p>There can be a number of issues when using sched_setparam. The parameters set in  the struct sched_param can be specific to a certain architecture, so the values  need to be set correctly for the current architecture. Also, the parameters can be  complex to set correctly, as they can depend on other running processes or the  architecture.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#related-events","title":"Related Events","text":"<ul> <li>sched_getscheduler - retrieves the scheduling policy of the process with given pid</li> <li>sched_getparam - retrieves the scheduling parameters associated with a given process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#intro","title":"Intro","text":"<p>sched_setscheduler - Set scheduling policy and parameters of a process</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#description","title":"Description","text":"<p>sched_setscheduler can be used to set the scheduling policy and scheduling parameter of an existing process with specified process ID (pid) and specified scheduling parameters (param). It can be used to set and toggle between different scheduling policies, e.g. SCHED_FIFO, SCHED_RR, SCHED_NORMAL, etc., depending on the requirements of the process. It can also be used to set the process' priority within the specified scheduling policy, using the struct sched_param.</p> <p>This call is subject to the CAP_SYS_NICE capability.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the process whose scheduling policy should be set.</li> <li><code>policy</code>:<code>int</code>[K] - Scheduling policy. Must be one of SCHED_OTHER (normal time-sharing), SCHED_FIFO (run until blocked or killed), SCHED_RR (same as FIFO but timesliced), or SCHED_BATCH (batch job).</li> <li><code>param</code>:<code>struct sched_param*</code>[K] - Scheduling parameters, to set the process priority within the specified scheduling policy.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#sched_setscheduler_1","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#purpose","title":"Purpose","text":"<p>To track the scheduling policy and parameters being set for a process.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#example-use-case","title":"Example Use Case","text":"<p>sched_setscheduler can be used when one needs fine-grained control over how a process is scheduled on a system. It can be used to prioritize processes, for example, when one process demands more resources than other processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#issues","title":"Issues","text":"<p>Before 4.15, scheduling parameters did not work with SCHED_IDLE or SCHED_BATCH.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#related-events","title":"Related Events","text":"<ul> <li>sched_getparam - Get scheduling parameters of a process.</li> <li>sched_getaffinity - Get/set the CPU affinity of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/","title":"sched_yield","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#intro","title":"Intro","text":"<p>sched_yield - temporarily pause the current thread in favor of other threads</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#description","title":"Description","text":"<p>The task sched_yield() cause the calling thread to relinquish the CPU. The thread is put to the end of the queue for its static priority and another thread will be scheduled to run. If there are no other threads running in the system, the yield will cause the thread to continue to run.</p> <p>sched_yield() is useful for an application to allow other threads to run (i.e. to prevent starvation of other threads) or for a thread to be scheduled in to reduce the latency for an scheduling event.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#arguments","title":"Arguments","text":"<p>No arguments for this syscall.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#do_sys_sched_yield","title":"do_sys_sched_yield","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#purpose","title":"Purpose","text":"<p>To monitor context switches.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#example-use-case","title":"Example Use Case","text":"<p>sched_yield() should be used when a process needs to pause its execution and give a chance to the other threads, waiting in the same priority queue.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#issues","title":"Issues","text":"<p>If there are no runnable threads with the same priority level, then the current thread will not be context switched and all other threads will be stuck behind it.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler: to change the scheduling policy and priority of selected thread.</li> <li>sched_get_priority_max/min: to get the highest/lowest priority limit of a scheduling policy.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/seccomp/","title":"seccomp","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#intro","title":"Intro","text":"<p>seccomp - Used to filter allowed syscalls</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#description","title":"Description","text":"<p>seccomp is a Linux-specific syscall used to restrict system calls available to a process and as such, can be used to harden system security. It utilizes a secure computing mode (hence the acronym) to place limitations on what a process can do. This limitation is applied to any system call made within the secure computing environment.</p> <p>There are a number of drawbacks to using seccomp, such as the difficulty in configuring it due to its restrictive nature, as well as the black box nature of the call, which can hamper debugging. Additionally, runtime errors can be difficult to diagnose and handle as the underlying cause may be hidden from the developer.</p> <p>Overall, seccomp is a powerful tool that can help strengthen security in cases where it is necessary. The best use case is one where there are specific system calls a process must avoid.</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#arguments","title":"Arguments","text":"<ul> <li><code>operation</code>:<code>unsigned int</code>[K] - Sets the operation of seccomp.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Sets the flags that control the behavior of seccomp.</li> <li><code>args</code>:<code>const void*</code>[K] - Source of additional information used in setting up seccomp.</li> </ul>"},{"location":"docs/events/builtin/syscalls/seccomp/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/seccomp/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#sys_seccomp","title":"sys_seccomp","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#purpose","title":"Purpose","text":"<p>Hook the system call to filter allowed syscalls</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#example-use-case","title":"Example Use Case","text":"<p>seccomp could be used as an addition to existing firewall configurations to restrict the kinds of system calls that can be made by different processes. </p>"},{"location":"docs/events/builtin/syscalls/seccomp/#issues","title":"Issues","text":"<p>Due to seccomp's restrictive nature, it can be difficult to configure and maintain. Additionally, runtime errors can be particularly perplexing to debug due to the opaque nature of the syscall. </p>"},{"location":"docs/events/builtin/syscalls/seccomp/#related-events","title":"Related Events","text":"<ul> <li>prctl() - Used to set seccomp rules on a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/security/","title":"security","text":""},{"location":"docs/events/builtin/syscalls/security/#intro","title":"Intro","text":"<p>security - checks if the current security context is valid</p>"},{"location":"docs/events/builtin/syscalls/security/#description","title":"Description","text":"<p>The security syscall call is used to check if the current security context is valid. It is used to check whether a security context is able to access a given resource. If the current security context does not have access to the resource, it can be updated to match the security context of the resource. It is important to note that the security context of a resource is determined by the security measure, or policy, of the particular resource.</p> <p>The security syscall is a key part of any security-minded application. It can help to ensure that only certain users are allowed to access certain resources, and that any access is done in a secure way. In addition, the security syscall can help to ensure that the security measures of a system are not circumvented or broken. </p> <p>There are a few key points to keep in mind when using the security syscall. The security context of the user needs to be checked for validity at all times, and the user\u2019s security context should be updated whenever necessary. In addition, the security syscall should never be used to perform authentication or authorization checks, as these should be done using a separate system.</p>"},{"location":"docs/events/builtin/syscalls/security/#arguments","title":"Arguments","text":"<ul> <li><code>context</code>:<code>char const *</code>[U, TOCTOU] - a pointer to a security context string.</li> <li><code>resource</code>:<code>char const *</code>[U, TOCTOU] - a pointer to a resource string.</li> <li><code>access</code>:<code>int</code>[U] - a bit mask representing the access rights.</li> <li><code>timeout</code>:<code>long</code>[U, OPT] - maximum time in milliseconds to wait for a security change before returning an error (if not provided, will wait indefinitely).</li> </ul>"},{"location":"docs/events/builtin/syscalls/security/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/security/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/security/#__x86_sys_security","title":"__x86_sys_security","text":""},{"location":"docs/events/builtin/syscalls/security/#type","title":"Type","text":"<p>bpf + kprobe</p>"},{"location":"docs/events/builtin/syscalls/security/#purpose","title":"Purpose","text":"<p>The purpose of hooking this function is to detect when the security syscall is called, and to obtain information about the context, resource, access and timeout arguments used.</p>"},{"location":"docs/events/builtin/syscalls/security/#security_update","title":"security_update","text":""},{"location":"docs/events/builtin/syscalls/security/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/security/#purpose_1","title":"Purpose","text":"<p>The purpose of hooking this function is to detect when the security context of a resource is updated and to obtain information about the context, resource, and access arguments used.</p>"},{"location":"docs/events/builtin/syscalls/security/#example-use-case","title":"Example Use Case","text":"<p>A security-minded application may use the security syscall to check a user\u2019s access rights to a particular resource. If the user is not authorized to access the resource, the security syscall can be used to update the user\u2019s security context to match the resource\u2019s security settings. This allows the user to access the resource in a secure fashion.</p>"},{"location":"docs/events/builtin/syscalls/security/#issues","title":"Issues","text":"<p>The security syscall can be vulnerable to TOCTOU attacks. If a malicious user is able to manipulate the security context of a resource, they can bypass the security checks done by the security syscall.</p>"},{"location":"docs/events/builtin/syscalls/security/#related-events","title":"Related Events","text":"<ul> <li>execve - spawns a new process</li> <li>getgid - returns the group identifier (GID) of the current effective user</li> <li>chroot - changes the root directory of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/select/","title":"select","text":""},{"location":"docs/events/builtin/syscalls/select/#intro","title":"Intro","text":"<p>select - Wait for some event on a group of files or sockets</p>"},{"location":"docs/events/builtin/syscalls/select/#description","title":"Description","text":"<p>The select event is used to monitor changes on a set of sockets or files. It  allows for the asynchronous detection of changes on these objects in a  time-efficient manner. After calling select, the application will be notified  when any of the objects in the set changes and is able to take action  accordingly. Select also supports waiting for a timeout.</p>"},{"location":"docs/events/builtin/syscalls/select/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:int - The highest numbered file descriptor in any of the sets and should be one more than the descriptor of the last file or socket that the select() statement is being asked to watch.</li> <li><code>readfds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors whose status the caller wishes to query.</li> <li><code>writefds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors on which the caller is asking to be notified when it is possible to write data.</li> <li><code>exceptfds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors which the system will report when there is an exceptional condition pending.</li> <li><code>timeout</code>:struct timeval* - Optional argument. A pointer to a timeval structure containing the maximum time for which the caller wishes to wait for the select() call to complete before returning. </li> </ul>"},{"location":"docs/events/builtin/syscalls/select/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/select/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/select/#do_select","title":"do_select","text":""},{"location":"docs/events/builtin/syscalls/select/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/select/#purpose","title":"Purpose","text":"<p>Hooked in order to detect when the kernel is awaiting on a select call.</p>"},{"location":"docs/events/builtin/syscalls/select/#example-use-case","title":"Example Use Case","text":"<p>The select event can be used for an application to keep track of multiple users concurrently without having to wait for each action by every user. This can be done by calling select on multiple sockets to maintain a listen client and detect when one of the clients has sent data.   </p>"},{"location":"docs/events/builtin/syscalls/select/#issues","title":"Issues","text":"<p>When calling select with more than one objects, if the data in one object changes, the application will have to wait additional time to serve the other objects in the set. This can lead to longer wait times if one of the objects in the set has data which changes rapidly or is frequently use accessed. </p>"},{"location":"docs/events/builtin/syscalls/select/#related-events","title":"Related Events","text":"<ul> <li>epoll - event-driven I/O model which uses events instead of the select/poll APIs </li> <li>poll - provides much of the same functionality as select.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semctl/","title":"semctl","text":""},{"location":"docs/events/builtin/syscalls/semctl/#intro","title":"Intro","text":"<p>semctl - a command used to perform operations on System V semaphore sets. </p>"},{"location":"docs/events/builtin/syscalls/semctl/#description","title":"Description","text":"<p>The semctl command is used to perform operations on System V semaphore sets. It has four arguments, a semaphore set identifier, a semaphore number, a command and an optional additional argument. The purpose of this command is to set and retrieve the control information associated with a semaphore set and to set the operational parameters associated with a semaphore. The semctl command can be used to stat, set, mark and get information related to a semaphore set. Some of the drawbacks of using this command is that it can potentially set a semaphore set to a state which can be used in a deadlock situation, or cause race conditions if not handled correctly.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code>[K] - A semaphore set identifier returned by semget().</li> <li><code>semnum</code>:<code>int</code>[K] - The number of the semaphore in the set to be affected by cmd.</li> <li><code>cmd</code>:<code>int</code>[K] - Semaphore control command.</li> <li><code>arg</code>:<code>unsigned long</code>[K+U+OPT] - Optional structure pointer or value returned from or passed to the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semctl/#sys_semctl","title":"sys_semctl","text":"<p>Type: kprobe + kretprobe. Purpose: To trace the execution of the sys_semctl system call. </p>"},{"location":"docs/events/builtin/syscalls/semctl/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event is a system administrator using the semctl command to monitor the semaphore set for errors or for debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#issues","title":"Issues","text":"<p>No issues are currently known for this event.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#related-events","title":"Related Events","text":"<ul> <li>semget - get a semaphore set identifier</li> <li>semop - perform semaphore operations</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semget/","title":"semget","text":""},{"location":"docs/events/builtin/syscalls/semget/#intro","title":"Intro","text":"<p>semget - allows processes to obtain access to semaphore sets</p>"},{"location":"docs/events/builtin/syscalls/semget/#description","title":"Description","text":"<p><code>semget</code> is used to identify and access an existing semaphore set, or to create a new semaphore set.  It is typically used to control access to a shared resource. When using <code>semget</code> to create a new semaphore set, an application must specify the size of the set, along with the read and write permissions.  The new semaphore set will remain until removed with <code>semctl</code> or the system is rebooted.</p> <p>If a process attempts to semget a semaphore set with a key that already exists, the process will be granted access to the semaphore set that already exists provided the permissions matches.</p> <p>There is an upper limit for the number of semaphore sets that may be created with semget. This limit is determined by the hardware platform and kernel configuration.</p>"},{"location":"docs/events/builtin/syscalls/semget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code> - Key of the semaphore set. Used to identify a unique semaphore set and can be created using the <code>ftok</code> function. </li> <li><code>nsems</code>:<code>int</code> - The number of semaphores contained in the semaphore set specified by <code>key</code>.</li> <li><code>semflg</code>:<code>int</code>[U,K,TOCTOU] - Permissions to access the semaphore set, to perform read and write operations.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semget/#sys_semget","title":"sys_semget","text":""},{"location":"docs/events/builtin/syscalls/semget/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/semget/#purpose","title":"Purpose","text":"<p>To track the use of <code>semget</code> syscalls, to identify any potential race conditions, deadlocks or failed resource allocation.</p>"},{"location":"docs/events/builtin/syscalls/semget/#example-use-case","title":"Example Use Case","text":"<p><code>semget</code> is a useful tool for controlling access to a shared resource amongst multiple processes. For example, a server application may want to control access to a file by having one process obtain the file and then use <code>semget</code> to set up a semaphore set that can be used to coordinate between multiple clients that need to access it.</p>"},{"location":"docs/events/builtin/syscalls/semget/#issues","title":"Issues","text":"<p>When using <code>semget</code> to create a new semaphore set, care must be taken to ensure that it has been configured properly and the permissions have been set correctly. Race conditions may occur if the semaphore set is not properly configured. Additionally, Once created, the <code>semget</code> call will return a semaphore set identifier and it is the responsibility of the calling process to manage the semaphore set. If the process exits without freeing up the semaphore set it was responsible for, the semaphore set will remain in the system until the system is rebooted.</p>"},{"location":"docs/events/builtin/syscalls/semget/#related-events","title":"Related Events","text":"<ul> <li>semop - to specify the operations to be carried out on the semaphore set </li> <li>semctl - to control the state of the semaphore set</li> <li>semtimedop - similar to <code>semop</code> but with an option of timing out</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semop/","title":"semop","text":""},{"location":"docs/events/builtin/syscalls/semop/#intro","title":"Intro","text":"<p>semop - atomically perform operations on a set of semaphores</p>"},{"location":"docs/events/builtin/syscalls/semop/#description","title":"Description","text":"<p>Semop is a Linux system call used to perform operations on a set of semaphores. It ensures that all operations specified in the argument <code>sops</code> will either be completed or none of them will be performed at all. This call can be used for synchronization between threads or processes. The only drawback is that if the maximum number of semaphores allowed is reached, the call will fail.</p>"},{"location":"docs/events/builtin/syscalls/semop/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code> - ID of the set of semaphores.</li> <li><code>sops</code>:<code>struct sembuf*</code> - pointer to an array of semaphore operations.</li> <li><code>nsops</code>:<code>size_t</code> - number of semaphores in the array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semop/#available-tags","title":"Available Tags","text":"<ul> <li>KU - Originated from kernel-space or user space.</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semop/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semop/#sys_semop","title":"sys_semop","text":""},{"location":"docs/events/builtin/syscalls/semop/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/semop/#purpose","title":"Purpose","text":"<p>To gain insight to the arguments passed to semop, as well as to log any broken semaphore constraints.</p>"},{"location":"docs/events/builtin/syscalls/semop/#example-use-case","title":"Example Use Case","text":"<p>If you need to synchronize between threads or processes, semop can be used to guarantee that a set of operations on a set of semaphores will either all succeed or none of them will.</p>"},{"location":"docs/events/builtin/syscalls/semop/#issues","title":"Issues","text":"<p>If the maximum number of semaphores allowed is reached, the call will fail.</p>"},{"location":"docs/events/builtin/syscalls/semop/#related-events","title":"Related Events","text":"<ul> <li>semget - Gets an existing semaphore set or allocate a new one.</li> <li>semctl - Examine or change an existing semaphore set.</li> <li>semtimedop - Like <code>semop</code>, but with an additional timeout parameter.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/","title":"semtimedop","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#intro","title":"Intro","text":"<p>semtimedop - acquire a semaphore in a timed manner</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#description","title":"Description","text":"<p>The <code>semtimedop()</code> system call is used to acquire a semaphore in an asynchronous manner with a timeout. It is designed to acquire one or multiple semaphores atomically. If the specified <code>timeout</code> is reached, the call will fail with an <code>EAGAIN</code> error. The return value of the call will contain information about the number of semaphores actually acquired.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code> - ID of the semaphore set.</li> <li><code>sops</code>:<code>struct sembuf*</code> - Pointer to an array of <code>sembuf</code> structs. Each struct contains the index of the semaphore inside the semaphore array and condition of the operation (unlock/lock).</li> <li><code>nsops</code>:<code>size_t</code> - Size of the array of <code>sembuf</code> structs.</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K, OPT] - Pointer to a timespec struct describing the time duration of the wait.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semtimedop/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semtimedop/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#sys_semtimedop","title":"sys_semtimedop","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#purpose","title":"Purpose","text":"<p>To monitor the execution of <code>semtimedop()</code> and modify behavior when needed.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#example-use-case","title":"Example Use Case","text":"<p><code>semtimedop()</code> is especially useful when implementing synchronization mechanisms into a system. These synchronization mechanisms could be related to multi-threaded application, and the <code>semtimedop()</code> could be used to allow access  to shared resources in a controlled manner.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#issues","title":"Issues","text":"<p>At the time of writing, the <code>timeout</code> argument does not work as expected on all  supported architectures.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#related-events","title":"Related Events","text":"<ul> <li>semop()</li> <li>semtimedop_time64()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/","title":"sendfile","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#intro","title":"Intro","text":"<p>sendfile() - copies data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#description","title":"Description","text":"<p>The sendfile() syscall copies data between two file descriptors. It copies data from the file descriptor in_fd and sends it to the file descriptor out_fd. The offset argument is an offset pointer, and it is used to define the position within the file from which the data will be read. The count argument defines how much data from the in_fd should be transferred.</p> <p>When using sendfile() it is important to note that the data is read from the in_fd file descriptor and written directly to the out_fd descriptor without passing through user-space. This can be faster than the traditional file-read-to-user-space-buffer-and-write-to-file approach.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#arguments","title":"Arguments","text":"<ul> <li><code>out_fd</code>:<code>int</code> - File descriptor from which the data will be written</li> <li><code>in_fd</code>:<code>int</code> - File descriptor from which the data will be read</li> <li><code>offset</code>:<code>off_t*</code>[K] - Pointer to an offset value </li> <li><code>count</code>:<code>size_t</code> - Length of data in bytes which will be transferred </li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#sys_sendfile","title":"sys_sendfile","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#type","title":"Type","text":"<p>KProbe + KRetProbe </p>"},{"location":"docs/events/builtin/syscalls/sendfile/#purpose","title":"Purpose","text":"<p>Track the arguments passed to the kernel sendfile() syscall, as well as its return values.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#example-use-case","title":"Example Use Case","text":"<p>sendfile() can be used to efficiently transfer large amounts of data between two file descriptors. It can be used to provide a way to efficiently transfer a stream of data between two network sockets.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#issues","title":"Issues","text":"<p>The count argument for sendfile() is limited to 32-bits of size. If more data must be transferred, it is necessary to iterate over multiple calls to sendfile().</p> <p>Additionally, passing a null pointer for the offset argument is not supported on all architectures.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#related-events","title":"Related Events","text":"<ul> <li>writev() - performs scatter-gather I/O</li> <li>send() - sends data on a socket </li> <li>splice() - constructs a pipe out of two files/file descriptors</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/","title":"sendfile32","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#intro","title":"Intro","text":"<p>sendfile32 - used to copy data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#description","title":"Description","text":"<p>sendfile32 is a system call used to copy data between two file descriptors. It is used to copy data using zero copy system calls, which can potentially improve the performance when dealing with large IO sizes. The operation may fail or complete with a partial result, depending on the size of the data being sent.</p> <p>Advantages of using sendfile32 include its ability to do zero-copy IO and to handle large IO requests. Drawbacks include the fact that it can only be used to send data from one file descriptor to another, and that it is not atomic and therefore vulnerable to time-of-check/time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#arguments","title":"Arguments","text":"<ul> <li><code>out_fd</code>:<code>int</code> - file descriptor from which data is to be read.</li> <li><code>in_fd</code>:<code>int</code> - file descriptor to which data is to be written.</li> <li><code>offset</code>:<code>off_t*</code>[U,TOCTOU] - pointer to an offset to start reading from the <code>in_fd</code> descriptor.</li> <li><code>count</code>:<code>size_t</code>[OPT] - the number of byte to copy. If not passed, the value is assumed to be the size of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#_1","title":"","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#purpose","title":"Purpose","text":"<p>Used to trace each time the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#example-use-case","title":"Example Use Case","text":"<p>A monitoring system might use this event to track the rate at which each user is copying data from one file descriptor to another.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#issues","title":"Issues","text":"<p>sendfile32 is not atomic and therefore vulnerable to time of check/time of use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#related-events","title":"Related Events","text":"<ul> <li>execve: used to call the sendfile32 system call.</li> <li>pread: used to read data from a file descriptor.</li> <li>write: used to write data to a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/","title":"sendmmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#intro","title":"Intro","text":"<p>sendmmsg - send multiple messages at once</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#description","title":"Description","text":"<p>The sendmmsg() system call is used to send multiple messages on a socket. It takes the parameters: <code>sockfd</code> (an integer file descriptor referring to a socket), <code>msgvec</code> (an array of struct mmsghdr structures, which contain the message payload and flags of each message, as well as an ancillary data buffer and an ancillary data buffer length), <code>vlen</code> (an unsigned integer specifying the size of the array of structures and thus the number of messages sent in one call), and <code>flags</code> (an integer specifying flags applied to each message sent in the call). Sending multiple messages at once allows the user to send multiple messages at once with the same system call instead of having to issue multiple calls for different messages; this reduces the number of system calls issued, increases the efficiency of the program, and does not harm any of the messages' delivery if any fail.</p> <p>This call may fail if the socket is not connected.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor of the socket to send the messages on</li> <li><code>msgvec</code>:<code>struct mmsghdr*</code>[KU] - An array of struct mmsghdr structures which contain the message payload and flags, as well as an ancillary data buffer and an ancillary data buffer length</li> <li><code>vlen</code>:<code>unsigned int</code> - The size of the array of structures and thus the number of messages sent in one call</li> <li><code>flags</code>:<code>int</code> - Flags applied to each message sent in the call</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#sys_sendmmsg","title":"sys_sendmmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#purpose","title":"Purpose","text":"<p>The purpose of this hook is to track calls to this syscall and log the arguments passed to it. This is useful for monitoring the behavior of applications, or determining the source of an error when something goes wrong.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#sock_sendmsg","title":"sock_sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#purpose_1","title":"Purpose","text":"<p>The purpose of this hook is to track returns from this syscall and log any errors that occurred. This is useful for debugging applications or analysis of security issues.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor applications for suspicious behavior, by logging calls to this syscall and tracking the arguments passed to it. This could be used, for example, to detect applications that are using excessive amounts of data, or using data in an unlikely way.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#issues","title":"Issues","text":"<p>This system call may fail if the socket is not connected.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#related-events","title":"Related Events","text":"<ul> <li>recvmsg - receive messages from a socket</li> <li>recvmmsg - receive multiple messages from a socket</li> <li>recvfrom - receive data from a socket</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/","title":"sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#intro","title":"Intro","text":"<p>sendmsg - send a message to another socket</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#description","title":"Description","text":"<p>The <code>sendmsg()</code> system call is used to send a message to another socket on the system. It is used when the message needs to be sent with a socket address, or if you need to specify control information headers. There are a few different control information headers that can be used, such as the SCM_RIGHTS and SCM_CREDENTIALS which are used to supply permissions and credentials. One of the benefits of using <code>sendmsg()</code> is that it can be used to send data between processes without relying on shared memory. Some of the drawbacks are that it requires additional overhead when encoding the control information and it can be quite difficult to debug.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - file descriptor of the target socket</li> <li><code>msg</code>:<code>struct msghdr*</code> - pointer to a <code>struct msghdr</code> containing information on the message buffer, destination address and optional control headers</li> <li><code>flags</code>:<code>int</code>[OPT] - a bitmask of flags to control the interpretation of the data</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#sys_sendmsg","title":"sys_sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#purpose","title":"Purpose","text":"<p>Measure time taken to perform the <code>sendmsg()</code> system call</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#example-use-case","title":"Example Use Case","text":"<p>One example of the use of the <code>sendmsg()</code> event is in applications that need to send data to multiple sockets simultaneously. By sending messages via <code>sendmsg()</code> instead of individual writes to each socket, the overhead of setting up and tearing down connected sockets can be greatly reduced.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#issues","title":"Issues","text":"<p>One of the common issues with <code>sendmsg()</code> is related to copying buffers to/from userspace. If these operations are done quickly enough, an attacker could exploit time-of-check-time-of-use (TOCTOU) vulnerabilities on the source machine.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#related-events","title":"Related Events","text":"<ul> <li>sendto</li> <li>recvmsg</li> <li>sendfile</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendto/","title":"sendto","text":""},{"location":"docs/events/builtin/syscalls/sendto/#intro","title":"Intro","text":"<p>sendto - send a message on a socket</p>"},{"location":"docs/events/builtin/syscalls/sendto/#description","title":"Description","text":"<p>The sendto() system call is used to send a message to a socket. The message is specified by a pointer to a buffer buf, and is specified to be of a length len. The flags argument specifies the type of message transmission. The dest_addr argument is a pointer to a socket address structure, which contains the address of the receiving socket. The addrlen argument specifies the size of this structure. If the socket is connection-oriented, the address of the target socket is already specified, and dest_addr should be NULL. If the socket is not connection-oriented, the address of the target socket must be specified and addrlen must be set to its size.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[U] - file descriptor for the socket (returned from socket call).</li> <li><code>buf</code>:<code>void*</code>[U] - pointer to the message buffer to be sent.</li> <li><code>len</code>:<code>size_t</code>[U] - length of the message to be sent.</li> <li><code>flags</code>:<code>int</code>[U] - message transmission flags.</li> <li><code>dest_addr</code>:<code>struct sockaddr*</code>[U] - pointer to a socket address structure containing the target socket address.</li> <li><code>addrlen</code>:<code>int</code>[U] - size of the socket address structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendto/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendto/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendto/#sys_sendto","title":"sys_sendto","text":""},{"location":"docs/events/builtin/syscalls/sendto/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/sendto/#purpose","title":"Purpose","text":"<p>Tracking the flow of messages sent via sockets.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#example-use-case","title":"Example Use Case","text":"<p>When debugging an application, one could hook sendto system call to monitor the flow of messages being sent from the application.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#related-events","title":"Related Events","text":"<ul> <li>recvfrom</li> <li>sendmsg</li> <li>recvmsg</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/","title":"set_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#intro","title":"Intro","text":"<p>set_mempolicy - one sentence description of the event</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#description","title":"Description","text":"<p>set_mempolicy() is a system call that sets the policy of allocation of memory on NUMA machines. It sets the default memory policy for how threads in the current process interact with memory across different NUMA nodes. It is used mainly by two types of processes: runtime linker or dynamic loader to directly specify which memory policy should be used when loading the newly loaded shared objects, or NUMA-aware applications that create huge pages or allocate big objects and tune how their threads interact with different NUMA nodes.</p> <p>There are two main drawbacks of using this system call. First, it does not check whether certain memory is located on a certain NUMA node, so there can be unnecessary cross-node migrations that might happen if set_mempolicy is used incorrectly. Second, it might have bad performance due to the different policies available being conflicting.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#arguments","title":"Arguments","text":"<ul> <li><code>mode</code>:<code>int</code>[K] - sets the mode of the policy. Can be either MPOL_DEFAULT, MPOL_PREFERRED, MPOL_BIND, MPOL_INTERLEAVE, which sets the policy depending on the specified argument.</li> <li><code>nodemask</code>:<code>const unsigned long*</code>[U,TOCTOU] - pointer to an array of unsigned long that contains the nodes to be used by the policy. The array will include up to maxnode unsigned longs.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - the maximum number of the nodes that can be used by the policy.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#__do_sys_set_mempolicy","title":"__do_sys_set_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#type","title":"Type","text":"<p>kretprobe </p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#purpose","title":"Purpose","text":"<p>Hooking __do_sys_set_mempolicy allows us to capture all invocations of the set_mempolicy syscall.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#example-use-case","title":"Example Use Case","text":"<p>set_mempolicy is used in applications that allocate huge memory objects and need to be aware of the NUMA node the memory originates from. It is also used in runtime linkers and dynamic loaders in order to allocate shared objects on specific NUMA nodes.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#issues","title":"Issues","text":"<p>set_mempolicy does not check whether certain memory is located on a certain NUMA node, so there can be unnecessary cross-node migrations that might happen if set_mempolicy is used incorrectly.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#related-events","title":"Related Events","text":"<ul> <li>set_numa_affinity - Used to set which NUMA nodes should be used for subsequent memory allocations.</li> <li>get_mempolicy - Used to get information about the memory policy of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/","title":"set_robust_list","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#intro","title":"Intro","text":"<p>set_robust_list - Sets head for the list of robust futexes for the current thread</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#description","title":"Description","text":"<p>The <code>set_robust_list</code> syscall sets the head for the list of robust futexes for the current thread. This list is created when a robust futex is allocated. The <code>set_robust_list</code> syscall can be used to create, modify and/or remove the list. It takes two arguments, head and len. The head is a pointer to the list of robust futexes and the len is the size of the list in bytes. </p> <p>The <code>set_robust_list</code> syscall is used to guard against data races in user-space software. If the robust futex is detected to be in use by another thread, it means that a data race is occurring and the current thread can take steps to avoid the race condition.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#arguments","title":"Arguments","text":"<ul> <li><code>head</code>: <code>struct robust_list_head*</code>[U] - Pointer to the head of the list of robust futexes.</li> <li><code>len</code>: <code>size_t</code>[U] - Size of the list in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#sys_set_robust_list","title":"sys_set_robust_list","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#purpose","title":"Purpose","text":"<p>Hooking on sys_set_robust_list is useful for tracking when the list of robust futexes is modified or created.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#example-use-case","title":"Example Use Case","text":"<p>One example of <code>set_robust_list</code> being used is in thread synchronization mechanisms. In this case, a thread can call the <code>set_robust_list</code> syscall in order to create or modify a list of robust futexes in order to guard against data races.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#issues","title":"Issues","text":"<p>The <code>set_robust_list</code> syscall is vulnerable to TOCTOU (time of check, time of use) attacks and in some cases it may be necessary to take extra precautions to secure this system call.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#related-events","title":"Related Events","text":"<p>The <code>get_robust_list</code> syscall can be used to get the current list of robust futexes from a thread and is related to the <code>set_robust_list</code> syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/","title":"set_thread_area","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#intro","title":"Intro","text":"<p>set_thread_area - Sets the area in which a thread's registers are saved</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#description","title":"Description","text":"<p>The set_thread_area() system call sets the thread-local storage (TLS) area for  the calling thread via the ldt_entry structure passed in the u_info argument.  The TLS area stores the segment registers (fs and gs). This area is found on  the user stack of the thread and is initialized after a thread is created.  The size of the area is implementation-defined, but at least 28 bytes of  space must be provided.</p> <p>Using this system call, the user can specify which segment descriptor should  be used for fs/gs. This is mostly useful for thread libraries. </p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#arguments","title":"Arguments","text":"<ul> <li><code>u_info</code>:struct user_desc*[KU] - Pointer to a user_desc structure which contains the information about the TLS area that the system call should set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#do_set_thread_area","title":"do_set_thread_area","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#purpose","title":"Purpose","text":"<p>To track when the set_thread_area syscall is called and to inspect the arguments.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#example-use-case","title":"Example Use Case","text":"<p>The set_thread_area syscall can be used when implementing thread-local storage (TLS) for a thread library and setting the memory area for storing the segment registers.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#related-events","title":"Related Events","text":"<p>set_tid_address, get_thread_area, clone, rt_sigaction</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/","title":"set_tid_address","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#intro","title":"Intro","text":"<p>set_tid_address - sets the thread ID used by the kernel for this thread</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#description","title":"Description","text":"<p>The set_tid_address system call sets the thread ID used by the kernel for this thread. This system call is used when creating new threads with the clone system call. It is usually used in conjunction with the CLONE_CHILD_SETTID flag. It allows the thread to receive the child thread's ID through the pointer provided.</p> <p>The set_tid_address system call takes a single argument, a pointer to an integer, <code>tidptr</code> that points to an integer that can be used to store the thread ID from the kernel.</p> <p>Edge cases, drawbacks or advantages of using it: * It ensures that the thread ID returned in the clone system call is valid and will not be reused by another thread. This makes it easier to detect thread creation errors. * If the thread is created without the CLONE_CHILD_SETTID flag, the pointer passed in this system call will not be used by the kernel.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#arguments","title":"Arguments","text":"<ul> <li><code>tidptr</code>:<code>int*</code>[K] - pointer to an integer that can be used to store the thread ID from the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#sys_set_tid_address","title":"SyS_set_tid_address","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#purpose","title":"Purpose","text":"<p>Hook the entry point to set_tid_address system call in order to trace threads created using the clone system call.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#example-use-case","title":"Example Use Case","text":"<p>set_tid_address is commonly used when creating new threads with the clone system call. It allows the thread to receive the child thread's ID through the pointer provided.</p> <p>One example of using set_tid_address is in the Linux kernel source code. The _do_fork syscall uses set_tid_address in order to set the thread ID for the new thread.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#issues","title":"Issues","text":"<p>The set_tid_address system call is not supported on some architectures.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#related-events","title":"Related Events","text":"<ul> <li>clone - used together with set_tid_address to create new threads.</li> <li>gettid - can be used to obtain the thread ID after set_tid_address is called.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/","title":"setdomainname","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#intro","title":"Intro","text":"<p>setdomainname - sets the system's hostname to the given name </p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#description","title":"Description","text":"<p>The setdomainname() system call is used to set the domain name of the system. The name is set to the value pointed to by the argument name, which is subject to the size restrictions on the hostname parameter as specified by length.</p> <p>The setdomainname() syscall is generally used in conjunction with the sethostname() syscall, which sets the hostname parameter. </p> <p>This system call is useful for setting the full domain name of a system as part of a larger system or network. It is also useful for setting up servers and switches on a local network.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>: <code>const char*</code>[K] - a pointer to a character string specifying the domain name of the system. </li> <li><code>len</code>: <code>size_t</code>[K] - length of the supplied name, in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setdomainname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setdomainname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#sys_setdomainname","title":"sys_setdomainname","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#purpose","title":"Purpose","text":"<p>To log every setdomainname call and its arguments.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#example-use-case","title":"Example Use Case","text":"<p>You are setting up a local network with several servers and computers in order to host an application. You can use the sethostname and setdomainname calls to quickly configure the system to have the unique domain name and host name that is required for this application.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#related-events","title":"Related Events","text":"<ul> <li>sethostname - sets the system's hostname. </li> <li>uname - gets system information, including domainname and hostname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/","title":"setfsgid","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#intro","title":"Intro","text":"<p>setfsgid - set the filesystem group ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#description","title":"Description","text":"<p>The <code>setfsgid()</code> system call allows a process to alter its filesystem group ID.</p> <p>This ID is utilized primarily for determining file access permissions during a system call. While the filesystem GID is usually identical to the effective GID of a process, they can differ under specific circumstances.</p> <p><code>setfsgid()</code> provides a mechanism for a process to adjust its identity temporarily when accessing filesystem resources without altering its effective GID. This capability facilitates a more detailed level of access control for the filesystem, particularly beneficial for applications that handle files on behalf of multiple users.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#arguments","title":"Arguments","text":"<ul> <li><code>fsgid</code>:<code>gid_t</code>[K] - The new filesystem group ID to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#sys_setfsgid","title":"sys_setfsgid","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#purpose","title":"Purpose","text":"<p>To monitor and record instances when the <code>setfsgid()</code> system call is executed, capturing specifics about the new filesystem group ID being assigned.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#example-use-case","title":"Example Use Case","text":"<p>Observing alterations in filesystem GIDs is essential for overseeing file access patterns, ensuring that processes aren't modifying file permissions in unexpected ways or accessing files beyond their designated privileges.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#issues","title":"Issues","text":"<p>Misuse of the <code>setfsgid()</code> system call or vulnerabilities in software utilizing it can lead to potential security issues, resulting in unauthorized group access or inadvertent permission changes.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#related-events","title":"Related Events","text":"<ul> <li><code>setfsuid()</code> - Set the filesystem user ID.</li> <li><code>setgid()</code> - Set the effective group ID.</li> <li><code>setegid()</code> - Set effective group ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/","title":"setfsgid16","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#intro","title":"Intro","text":"<p>setfsgid16 - set the effective group id for the current thread</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#description","title":"Description","text":"<p>The setfsgid16() call sets the effective group ID for the current thread to fsgid. It is analogous to setegid(), but can only be used to set the effective group ID of the calling process to one of the real, effective, or saved GIDs.</p> <p>setfsgid16() is intended for use only in systems with an 16-bit GID type. On Linux and other systems with a 32-bit GID type, the setfsgid() wrapper function is provided using the new setfsgid32() system call.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#arguments","title":"Arguments","text":"<ul> <li><code>fsgid</code>:<code>old_gid_t</code>[U, OPT] - the new group id for the current thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#sys_setfsgid16","title":"sys_setfsgid16","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#type","title":"Type","text":"<p>Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#purpose","title":"Purpose","text":"<p>To monitor attempts to change the effective group ID of the current thread.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#example-use-case","title":"Example Use Case","text":"<p>A user space application could use setfsgid16() to change its effective GID after verifying its permission to do so.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#related-events","title":"Related Events","text":"<p>setegid(), setfsgid32()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/","title":"setfsuid","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#intro","title":"Intro","text":"<p>setfsuid - set the filesystem user ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#description","title":"Description","text":"<p>The <code>setfsuid()</code> system call permits a process to change its filesystem user ID, which is utilized primarily for determining file access permissions during the execution of a system call. The filesystem UID is typically equal to the effective UID of a process, but they can differ in certain contexts.</p> <p>The primary intent of <code>setfsuid()</code> is to allow a process to temporarily alter its identity when accessing filesystem resources without changing the effective UID. It offers a more granular level of access control to the filesystem, especially useful for programs that manage files on behalf of other users.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#arguments","title":"Arguments","text":"<ul> <li><code>fsuid</code>:<code>uid_t</code>[K] - The new filesystem user ID to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#sys_setfsuid","title":"sys_setfsuid","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#purpose","title":"Purpose","text":"<p>To observe and trace occurrences of the <code>setfsuid()</code> system call, capturing details about the new filesystem user ID being set.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#example-use-case","title":"Example Use Case","text":"<p>Tracking changes in filesystem UIDs provides a way to monitor and audit file access behaviors, ensuring that processes aren't manipulating file permissions inappropriately or accessing files they shouldn't.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#issues","title":"Issues","text":"<p>If not used with caution, <code>setfsuid()</code> can lead to incorrect file access permissions, possibly giving processes more permissions than intended or bypassing certain security mechanisms.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#related-events","title":"Related Events","text":"<ul> <li><code>setfsgid()</code> - Set the filesystem group ID.</li> <li><code>setuid()</code> - Set the effective user ID.</li> <li><code>seteuid()</code> - Set effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/","title":"setfsuid16","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#intro","title":"Intro","text":"<p>setfsuid16 - sets the effective user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#description","title":"Description","text":"<p>The setfsuid16 syscall sets the effective user ID of the calling process to fsuid. This syscall will only be successful if the user process has the appropriate privileges to set their own effective user ID to the given value. This syscall can be used to change the effective user ID of the calling process, and it may also set the saved set-user-ID if the user has appropriate privileges. It is important to note that this does not change the real user ID or group ID, or the process credentials. </p> <p>In order for a process to make use of this syscall, the user needs to have the capability CAP_SETUID set.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#arguments","title":"Arguments","text":"<ul> <li><code>fsuid</code>:<code>old_uid_t</code>[K] - The effective user ID of the calling process will be set to this value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#sys_setfsuid16","title":"sys_setfsuid16","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#purpose","title":"Purpose","text":"<p>To monitor processes changing their effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to set the effective user ID of the calling process to a different value, which might be necessary in the case of switching users in a process.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#issues","title":"Issues","text":"<p>This syscall can lead to a privilege escalation vulnerability if used incorrectly. Care should be taken to ensure that the user has the appropriate privileges to set their own effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#related-events","title":"Related Events","text":"<p>setresuid16</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgid/","title":"setgid","text":""},{"location":"docs/events/builtin/syscalls/setgid/#intro","title":"Intro","text":"<p>setgid - set the effective group ID of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#description","title":"Description","text":"<p>The <code>setgid()</code> system call enables a process to change its effective group ID.</p> <p>This is an essential mechanism in Unix-like operating systems, allowing processes to acquire or drop group-based permissions. Just as with <code>setuid()</code>, programs that run with set-group-ID-on-exec (the setgid bit) will operate with the file's group ID as its effective group ID.</p> <p><code>setgid()</code> is often used in conjunction with <code>setuid()</code> in programs that need to temporarily escalate or change privileges to perform specific tasks. By using <code>setgid()</code>, programs can ensure they operate with the least amount of group-based privilege necessary, enhancing system security.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#arguments","title":"Arguments","text":"<ul> <li><code>gid</code>:<code>gid_t</code>[K] - The group ID which will be set as the effective group ID of the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgid/#sys_setgid","title":"sys_setgid","text":""},{"location":"docs/events/builtin/syscalls/setgid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setgid/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>setgid()</code> system call is performed, capturing details about the group ID being set.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in group privileges in a system, particularly in scenarios where group-based access control is crucial for security or resource sharing.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#issues","title":"Issues","text":"<p>Similar to <code>setuid()</code>, if <code>setgid()</code> is misused or if programs leveraging it contain vulnerabilities, it can pave the way for privilege escalation attacks. Care must be taken to ensure that programs drop group-based privileges appropriately and securely.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#related-events","title":"Related Events","text":"<ul> <li><code>setuid()</code> - Set the effective user ID of the calling process.</li> <li><code>setegid()</code> - Set the effective group ID, but retain the original real group ID.</li> <li><code>setregid()</code> - Set real and/or effective group ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/","title":"setgid16","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#intro","title":"Intro","text":"<p>setgid16 - change the effective of the calling process and the saved set-group-ID</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#description","title":"Description","text":"<p>The setgid16() system call is used to set the user's real group ID, effective group ID, and the saved set-group-ID of the calling process. This can be used to change the privileges of a process to that of a new group. The setgid16() call is one of the set-ID system calls, meaning that the real user ID and effective user ID of the calling process will also be set. This call is made obsolete by the setgid() call.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#arguments","title":"Arguments","text":"<ul> <li><code>gid</code>:<code>old_gid_t</code>[KU] - represents a group ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#sys_setgid16","title":"sys_setgid16","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#purpose","title":"Purpose","text":"<p>To capture calls to the setgid16 system call.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#example-use-case","title":"Example Use Case","text":"<p>The setgid16 system call could be used to temporarily switch the effective group ID of a process from a privileged group to that of an unprivileged single-user group in order to perform a task that requires elevated privileges. After the task is complete, the process can be switched back to its original group ID.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#issues","title":"Issues","text":"<p>The setgid16 system call is obsolete and should not be used in modern Linux systems. It should be replaced with setgid.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#related-events","title":"Related Events","text":"<ul> <li>setgid</li> <li>getgid</li> <li>setegid</li> <li>getegid</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/","title":"setgroups","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#intro","title":"Intro","text":"<p>setgroups - sets the list of supplementary groups of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#description","title":"Description","text":"<p>The setgroups() system call allows the calling process to set its supplementary group IDs directly, without manipulating the supplementary group IDs with  the  initgroups() system call.  The setgroups() system call is limited to  processes  with  the  CAP_SETGID  capability  and with an effective user ID of 0. </p> <p>This system call is the complementary system call to the getgroups() system call, which gets the supplementary group IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code> - The  number of supplementary group IDs in the list. </li> <li><code>list</code>:<code>gid_t*</code>[K] - A pointer to the list of group IDs.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#sys_setgroups","title":"sys_setgroups","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#type","title":"Type","text":"<p>kprobe+kretprobe</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#purpose","title":"Purpose","text":"<p>Observe setgroups() calls and the return values.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#example-use-case","title":"Example Use Case","text":"<p>For example, an administrator could use the setgroups() system call to change the supplementary group IDs associated with a process in order to temporarily assign it additional privileges.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#issues","title":"Issues","text":"<p>One possible issue with setgroups is that it may be vulnerable to time of check, time of use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#related-events","title":"Related Events","text":"<p>getgroups - gets the list of supplementary groups of the calling process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/","title":"setgroups16","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#intro","title":"Intro","text":"<p>setgroups16 - assign process's supplementary group IDs</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#description","title":"Description","text":"<p>The <code>setgroups16()</code> system call sets the supplementary group IDs for the process. The argument <code>size</code> specifies the number of group IDs passed in <code>list</code>. The group IDs in <code>list</code> are set for the range <code>0 &lt;= i &lt; size</code>. If the process is privileged, all request IDs can be set; otherwise, an error may be returned if any of the IDs specified by <code>list</code> are invalid or are not valid and permissible for the real user ID of the calling process.</p> <p>Unlike <code>setgroups()</code> which sets the object's Supplementary Group IDs to exactly those supplied in <code>list</code>, <code>setgroups16()</code> sets filling the Supplementary Group IDs with values taken from <code>list</code> and leaves empty entries after the last one specified in <code>list</code>, following the BSD 4.3 behaviour.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>size_t</code>[K] - specifies the number of group Ids passed in list.</li> <li><code>list</code>:<code>const gid_t*</code>[U] - contains the group IDs to be set for the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#do_setgroups16","title":"do_setgroups16","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#purpose","title":"Purpose","text":"<p>This hook is used to monitor the system call do_setgroups16 which is responsible for setting the supplementary group IDs of a process.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#example-use-case","title":"Example Use Case","text":"<p>This function can be used to detect changes in the supplementary group IDs of a process. For example, this can be used to detect if a malicious process is setting itself as the root user.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#related-events","title":"Related Events","text":"<p>This system call is related to the <code>setgroups()</code> system call since it set the supplementary group IDs of a process in a similar way. Also related is the <code>getgroups16()</code> system call which can be used to retrieve the current supplementary group IDs assigned to a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/","title":"sethostname","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#intro","title":"Intro","text":"<p>sethostname - a syscall to set the system's hostname </p>"},{"location":"docs/events/builtin/syscalls/sethostname/#description","title":"Description","text":"<p>The sethostname() system call is used to set the system's hostname. The hostname is a single component of the fully qualified domain name (FQDN) of a system. The sethostname() call takes two arguments; the first argument is a pointer to a character string specifying the host name, and the second argument is the size of the character string pointed to by the first argument. The system hostname is limited to a maximum length of __HOST_NAME_MAX bytes (defined in limits.h) not including the NUL terminator.</p> <p>The sethostname() call does not make any consistency checks for the given hostname. The only requirement for setting the hostname is that it should be a valid NUL terminated character string. It is up to the caller to ensure that the hostname is valid and properly formatted.</p> <p>The sethostname() call is provided for compatibility with BSD systems. It is recommended that applications use sethostname() with caution and verify that the hostname is properly formed.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[KU] - Pointer to a character string specifying the system's hostname.  </li> <li><code>len</code>:<code>size_t</code>[K] - Length of the character string specified by name.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sethostname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sethostname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#sys_sethostname","title":"sys_sethostname","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/sethostname/#purpose","title":"Purpose","text":"<p>To record system calls and argument passing information.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#example-use-case","title":"Example Use Case","text":"<p>The sethostname() system call can be used to set the hostname of a system. This can be useful in cloud environments, where automated scripts can set hostnames based on the environment they're running in.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#issues","title":"Issues","text":"<p>The sethostname() call does not verify the hostname given to it. This can be a security issue if an attacker is able to manipulate the parameters being passed. </p> <p>To mitigate this, it is important to always verify the hostname being passed to the sethostname() call.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#related-events","title":"Related Events","text":"<ul> <li>gethostname() - retrieve the system's hostname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/","title":"setitimer","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#intro","title":"Intro","text":"<p>setitimer - set value of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#description","title":"Description","text":"<p>The <code>setitimer</code> system call sets the value of an interval timer. It sets the clock associated with the timer <code>which</code> according to the <code>new_value</code> argument. If <code>old_value</code> is non-NULL, the previous value of the timer is stored there. The time is measured in seconds, microseconds and nanoseconds (if possible on the platform); if required, the time is rounded up to the system clock granularity, and kernel-internal quantities are measured in jiffies (1/100ths of a second).</p> <p>This system call is useful for applications that need to be periodically notified, for example to update statistics or audit data.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - Specifies which of the four interval timers to set. It can take one of the following values: ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF or ITIMER_MONOTONIC.</li> <li><code>new_value</code>:<code>struct itimerval*</code>[KU] - A pointer to a <code>struct itimerval</code> data structure which sets the new values of the interval timer.</li> <li><code>old_value</code>:<code>struct itimerval*</code>[U] - A pointer to a <code>struct itimerval</code> data structure that will be filled with the reset value(s) of the interval timer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setitimer/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setitimer/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#do_setitimer","title":"do_setitimer","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#purpose","title":"Purpose","text":"<p>To monitor when an interval timer is set.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#example-use-case","title":"Example Use Case","text":"<p>An application which needs to perform multiple periodic tasks, each on a different interval, can use <code>setitimer</code> system call to set up different interval timers. </p>"},{"location":"docs/events/builtin/syscalls/setitimer/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#related-events","title":"Related Events","text":"<ul> <li><code>getitimer</code>, <code>timer_create</code>, <code>timer_delete</code>, <code>timer_settime</code>, <code>timer_gettime</code>, <code>timer_getoverrun</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setns/","title":"setns","text":""},{"location":"docs/events/builtin/syscalls/setns/#intro","title":"Intro","text":"<p>setns - reassociate a process with a namespace.</p>"},{"location":"docs/events/builtin/syscalls/setns/#description","title":"Description","text":"<p>The <code>setns()</code> system call is used to associate a process with an existing namespace.</p> <p>Namespaces are a feature of the Linux kernel that partition kernel resources such that one set of processes sees one set of resources, while another set sees a different set. The <code>setns()</code> system call enables processes to transition between these namespaces, or more technically, to be reassociated with different namespaces. It's an integral part of container technologies, where isolation of resources is paramount.</p>"},{"location":"docs/events/builtin/syscalls/setns/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor of the target namespace.</li> <li><code>nstype</code>:<code>int</code>[OPT] - An optional bitmask specifying the type of namespace. If this argument is zero, the type of namespace is inferred from the type of the file referred to by <code>fd</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setns/#namespace-types","title":"Namespace Types:","text":"<ul> <li><code>CLONE_NEWCGROUP</code>: Cgroup namespace</li> <li><code>CLONE_NEWIPC</code>: IPC namespace</li> <li><code>CLONE_NEWNET</code>: Network namespace</li> <li><code>CLONE_NEWNS</code>: Mount namespace</li> <li><code>CLONE_NEWPID</code>: PID namespace</li> <li><code>CLONE_NEWUSER</code>: User namespace</li> <li><code>CLONE_NEWUTS</code>: UTS namespace</li> </ul>"},{"location":"docs/events/builtin/syscalls/setns/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setns/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setns/#sys_setns","title":"sys_setns","text":""},{"location":"docs/events/builtin/syscalls/setns/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setns/#purpose","title":"Purpose","text":"<p>To monitor and capture instances when the <code>setns()</code> system call is executed, recording details on the type of namespace and the process being reassociated.</p>"},{"location":"docs/events/builtin/syscalls/setns/#example-use-case","title":"Example Use Case","text":"<p>In containerized environments, where process and resource isolation is vital, monitoring the invocation of <code>setns()</code> is pivotal to ensure processes are only engaging with the appropriate namespaces.</p>"},{"location":"docs/events/builtin/syscalls/setns/#issues","title":"Issues","text":"<p>Misuse or misconfigurations with <code>setns()</code> might allow processes to access unintended namespaces, potentially undermining the isolation principles of container technologies and other namespace-dependent mechanisms.</p>"},{"location":"docs/events/builtin/syscalls/setns/#related-events","title":"Related Events","text":"<ul> <li><code>unshare()</code> - Disassociates parts of the process execution context.</li> <li><code>clone()</code> - Creates a child process, potentially sharing certain resources with the parent.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/","title":"setpgid","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#intro","title":"Intro","text":"<p>setpgid - set the process group ID for a process.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#description","title":"Description","text":"<p>The <code>setpgid()</code> system call is used to set the process group ID of a specific process.</p> <p>This is particularly useful for creating or changing sessions, job control, and other process grouping related tasks in Unix-like operating systems. When a new process is created, it inherits the process group ID of its parent. Using <code>setpgid()</code>, processes can be re-assigned to different groups, facilitating group-based operations like signaling.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the target process. If <code>pid</code> is zero, the process ID of the calling process is used.</li> <li><code>pgid</code>:<code>pid_t</code>[K] - The process group ID to be set. If <code>pgid</code> is zero, the process ID of the process specified by <code>pid</code> is used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#sys_setpgid","title":"sys_setpgid","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#purpose","title":"Purpose","text":"<p>To observe and trace the invocation of the <code>setpgid()</code> system call, capturing information about the process and the new process group ID.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring process group changes, especially in scenarios where job control or session management is vital, such as in shell environments or process managers.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#issues","title":"Issues","text":"<p>Improper usage of <code>setpgid()</code> can lead to processes being unintentionally grouped together, potentially causing unintended signaling or termination of processes.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#related-events","title":"Related Events","text":"<ul> <li><code>getpgid()</code> - Retrieve the process group ID of a process.</li> <li><code>setsid()</code> - Create a new session and set the process group ID.</li> <li><code>getpgrp()</code> - Get the process group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/","title":"setpriority","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#intro","title":"Intro","text":"<p>setpriority - modifies the scheduling priority of specified process</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#description","title":"Description","text":"<p>The setpriority() system call is used to modify the scheduling priority of specified process or process group.</p> <p>The which argument allows the priority of one of the following selections to be changed: * PRIO_PROCESS -  change the priority of specified process * PRIO_PGRP -  change the priority of all processes in the specified process group * PRIO_USER -  change the priority of all processes for the specified user</p> <p>The who argument specifies the process, process group, or user the priority of which is to be changed. The who argment should be different from 0 to specify a process instead of a process group or user.</p> <p>The prio argument allows the priority to be specified as a value in the range -20 to 19. A lower numerical value causes a process to be scheduled with higher priority.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - specifies which selection is to be modified</li> <li><code>who</code>:<code>int</code>[K] - user ID of the process or process group to be modified </li> <li><code>prio</code>:<code>int</code>[K] - the new priority value in the range -20 to 19</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpriority/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpriority/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#sys_setpriority","title":"sys_setpriority","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#purpose","title":"Purpose","text":"<p>Capture information about process scheduling priority changes</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#example-use-case","title":"Example Use Case","text":"<p>The setpriority() system call can be used to customize the scheduling priorities for certain processes on the system. For example, setting the scheduling priority of a process containing a real-time task to a higher priority than that of other processes.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#issues","title":"Issues","text":"<p>This system call only gives priority to processes with non-real-time priority scheduling. Real-time priority schedulers should be done with other syscalls.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#related-events","title":"Related Events","text":"<ul> <li>sched_setattr() - sets attributes for process scheduling</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setregid/","title":"setregid","text":""},{"location":"docs/events/builtin/syscalls/setregid/#intro","title":"Intro","text":"<p>setregid - set real and effective group IDs.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#description","title":"Description","text":"<p>The <code>setregid()</code> system call allows a process to change both its real group ID and its effective group ID.</p> <p>This capability is similar to setting user IDs but operates on the group level, providing processes the ability to modify their association with user groups. In Unix-like systems, the real group ID identifies the primary group of the user who initiated the process, while the effective group ID influences the group-based permissions for that process.</p> <p>This mechanism is instrumental for processes that need to alternate between different group-based privileges temporarily, ensuring resource access control and security at the group level.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t</code>[K] - The real group ID to be set. If this argument is -1, the real GID is not changed.</li> <li><code>egid</code>:<code>gid_t</code>[K] - The effective group ID to be set. If this argument is -1, the effective GID is not changed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setregid/#sys_setregid","title":"sys_setregid","text":""},{"location":"docs/events/builtin/syscalls/setregid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setregid/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>setregid()</code> system call is executed, collecting data about the changes to the real and effective group IDs.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#example-use-case","title":"Example Use Case","text":"<p>Observing group-level privilege changes is essential in secure environments, especially when monitoring potential group-based privilege escalation or processes frequently transitioning between group contexts.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#issues","title":"Issues","text":"<p>Improper usage or vulnerabilities in programs using <code>setregid()</code> can be exploited to gain unauthorized group privileges, leading to potential security lapses.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#related-events","title":"Related Events","text":"<ul> <li><code>setgid()</code> - Set the effective group ID of the calling process.</li> <li><code>setresgid()</code> - Set real, effective, and saved group IDs.</li> <li><code>setegid()</code> - Set effective group ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setregid16/","title":"setregid16","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#intro","title":"Intro","text":"<p>setregid16 - Set real and effective group IDs in a 16-bit environment</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#description","title":"Description","text":"<p>The setregid16() system call changes the real and effective group IDs of the calling process to rgid and egid, respectively.  The argument rgid is taken as the new real group ID, and the argument egid is taken as the new effective group ID. If the effective UID of the process is 0 (root), then both arguments are taken as the real group ID and the saved group ID is set to egid. If the effective UID of the process is nonzero, then only rgid needs to be equal to the real group ID, and setregid16() sets the effective group ID to egid provided that it is equal to either the real group ID or the saved group ID.</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_gid_t</code>[K] - Real group ID to be set.</li> <li><code>egid</code>:<code>old_gid_t</code>[K] - Effective group ID to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#sys_setregid16","title":"sys_setregid16","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#purpose","title":"Purpose","text":"<p>Trace when the setregid16 system call is called. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#example-use-case","title":"Example Use Case","text":"<p>Setregid16 can be useful in security contexts as it allows to change the real GID of the current process to a specific number or values which is important for granting or revoking access to certain resources which could be guarded by specific modern capabilities. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#issues","title":"Issues","text":"<p>It is important to note that setregid16 system call has been deprecated in newer versions of Linux in favor of setregid system call. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#related-events","title":"Related Events","text":"<ul> <li><code>setregid</code> system call</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/","title":"setresgid","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#intro","title":"Intro","text":"<p>setresgid - set real, effective, and saved group IDs.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#description","title":"Description","text":"<p>The <code>setresgid()</code> system call allows a process to modify its real group ID, effective group ID, and saved set-group-ID simultaneously.</p> <p>The real group ID denotes the primary group associated with the user that initiated the process. The effective group ID dictates the group-based permissions of that process. The saved set-group-ID is kept as a reference to remember the effective group ID, especially useful when a process temporarily relinquishes its group privileges and wishes to revert them at a later point.</p> <p>This utility offers both flexibility and security for processes that need to alternate their group-related privileges for specific tasks and then revert back to their original group privileges.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t</code>[K] - The real group ID to be set. If this value is -1, the real GID remains unchanged.</li> <li><code>egid</code>:<code>gid_t</code>[K] - The effective group ID to be set. If this value is -1, the effective GID remains unchanged.</li> <li><code>sgid</code>:<code>gid_t</code>[K] - The saved set-group-ID to be set. If this value is -1, it remains unchanged.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#sys_setresgid","title":"sys_setresgid","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#purpose","title":"Purpose","text":"<p>To track and record instances of the <code>setresgid()</code> system call being called, capturing detailed insights about the modifications to the real, effective, and saved group IDs.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#example-use-case","title":"Example Use Case","text":"<p>In security-sensitive environments, observing transitions between group IDs is crucial. Tracking these changes can aid in detecting possible unauthorized group privilege escalations or processes that switch their group privileges for particular operations.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#issues","title":"Issues","text":"<p>Misuse of the <code>setresgid()</code> system call or vulnerabilities in applications using it can lead to potential exploitation, resulting in unauthorized group access or other security implications.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#related-events","title":"Related Events","text":"<ul> <li><code>setgid()</code> - Set the effective group ID.</li> <li><code>setregid()</code> - Set real and effective group IDs.</li> <li><code>setegid()</code> - Set effective group ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/","title":"setresgid16","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#intro","title":"Intro","text":"<p>setresgid16 - set real, effective and saved user or group ID</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#description","title":"Description","text":"<p>The setresgid16() system call sets the real GID, effective GID, and saved set-user-ID of the calling process. This call sets the three GIDs with a single syscall, instead of the sets the individual GID values with setregid(2). </p> <p>The three GIDs are set according to the following rules:</p> <ul> <li> <p>If rgid is not (uid_t)-1, it is set as the real GID of the process;</p> </li> <li> <p>If egid is not (uid_t)-1, it is set as the effective GID of the process;</p> </li> <li> <p>If suid is not (uid_t)-1, it is set as the saved set-GID of the process.</p> </li> </ul> <p>It is permitted that the real GID, effective GID, and saved set-GID are all set to the same value. </p> <p>By convention, a set-user-ID or set-GID program should clear the saved set-user-ID or set-GID when it starts, and should do so early in its initialization before other things that might open files or create child processes. In an environment where file names are relied on to be predictable and unchanging, using setresgid16() to clear the saved set-GID avoids certain security problems (but also see getresgid16(2), below).</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_uid_t</code>[K] - real group ID of the calling process. </li> <li><code>euid</code>:<code>old_uid_t</code>[K] - effective group ID of the calling process. </li> <li><code>suid</code>:<code>old_uid_t</code>[K] - saved set-group-ID of the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#sys_setresgid16","title":"sys_setresgid16","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#purpose","title":"Purpose","text":"<p>To monitor execution of the setresgid16() system call and get the values of the given arguments.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor changes in the real GID, effective GID and saved set-GID of the running process. It can be used to identify abnormal behavior or unexpected modifications in these GIDs.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#related-events","title":"Related Events","text":"<ul> <li>sys_setregid16() - sets the real GID and effective GID of the calling process.</li> <li>sys_setresuid16() - sets the real UID, effective UID, and saved set-user-ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/","title":"setresuid","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#intro","title":"Intro","text":"<p>setresuid - set real, effective, and saved user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#description","title":"Description","text":"<p>The <code>setresuid()</code> system call provides a process with the capability to set its real user ID, effective user ID, and saved set-user-ID.</p> <p>While the real user ID and effective user ID represent the identity of the process and the identity used for evaluating privileges, respectively, the saved set-user-ID is stored to remember the effective user ID, particularly when a process drops its privileges temporarily and wishes to restore them later.</p> <p>This mechanism is especially useful for ensuring security and flexibility in scenarios where processes need to alter their privileges for a short duration and revert to their original privileges subsequently.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t</code>[K] - The real user ID to be set. A value of -1 indicates no change.</li> <li><code>euid</code>:<code>uid_t</code>[K] - The effective user ID to be set. A value of -1 indicates no change.</li> <li><code>suid</code>:<code>uid_t</code>[K] - The saved set-user-ID to be set. A value of -1 indicates no change.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#sys_setresuid","title":"sys_setresuid","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#purpose","title":"Purpose","text":"<p>To observe and trace the invocation of the <code>setresuid()</code> system call, capturing details about the modifications to the real, effective, and saved user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#example-use-case","title":"Example Use Case","text":"<p>It's essential to monitor transitions between user IDs in secure environments. Observing such changes can help in identifying potential privilege escalation attempts or processes that toggle their privileges for specific operations.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#issues","title":"Issues","text":"<p>If mishandled or if applications using <code>setresuid()</code> have vulnerabilities, they might be exploited to gain unauthorized privileges, leading to security breaches.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#related-events","title":"Related Events","text":"<ul> <li><code>setuid()</code> - Set the effective user ID.</li> <li><code>setreuid()</code> - Set real and effective user IDs.</li> <li><code>seteuid()</code> - Set effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/","title":"setresuid16","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#intro","title":"Intro","text":"<p>setresuid16 - set real, effective and saved user identity</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#description","title":"Description","text":"<p>The setresuid16 syscall sets the effective, real, and saved user identities depending on the value of the argument flags. A process with the CAP_SETUID capability can set its own user ID's. A process without the CAP_SETUID capability can set the real and effective user ID's to the effective user ID of the process. All the ID's are changed regardless of the value of the flags argument, so group and supplemental group changes can not be suppressed.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t</code>[K] - real user ID</li> <li><code>euid</code>:<code>old_uid_t</code>[K] - effective user ID</li> <li><code>suid</code>:<code>old_uid_t</code>[K] - saved set-user-ID</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#sys_setresuid16","title":"sys_setresuid16","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#purpose","title":"Purpose","text":"<p>To monitor changes in user ID's.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for this event is if a system administrator wanted to monitor user ID changes as they occur. This event can be used to detect any attempts to change a user's identity in order to access resources they are not authorized to access.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#issues","title":"Issues","text":"<p>There are no known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#related-events","title":"Related Events","text":"<ul> <li>getresuid16 - get real, effective, and saved user identity</li> <li>setreuid16 - set real and effective user identity </li> <li>setfsuid16 - set filesystem user identity</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/","title":"setreuid","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#intro","title":"Intro","text":"<p>setreuid - set real and effective user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#description","title":"Description","text":"<p>The <code>setreuid()</code> system call allows a process to set both its real user ID and its effective user ID.</p> <p>This provides flexibility in managing user-based privileges, especially for processes that need to toggle between different levels of privileges temporarily. In Unix-like systems, the real user ID identifies the user who launched the process, whereas the effective user ID dictates the permissions for process operations.</p> <p>By modifying these IDs selectively, processes can execute specific tasks under one identity and then revert to another, thereby enhancing system security by minimizing the time a process runs with elevated privileges.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t</code>[K] - The real user ID to be set. If this argument is -1, the real UID is not changed.</li> <li><code>euid</code>:<code>uid_t</code>[K] - The effective user ID to be set. If this argument is -1, the effective UID is not changed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#sys_setreuid","title":"sys_setreuid","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>setreuid()</code> system call is executed, capturing information about the changes made to the real and effective user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring privilege transitions is crucial in environments that prioritize security, particularly when tracking potential privilege escalation scenarios or processes that are expected to change their operational context frequently.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#issues","title":"Issues","text":"<p>If misused or if programs leveraging <code>setreuid()</code> contain vulnerabilities, they can be exploited to gain unauthorized privileges, leading to potential security breaches.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#related-events","title":"Related Events","text":"<ul> <li><code>setuid()</code> - Set the effective user ID of the calling process.</li> <li><code>setresuid()</code> - Set real, effective, and saved user IDs.</li> <li><code>seteuid()</code> - Set effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/","title":"setreuid16","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#intro","title":"Intro","text":"<p>setreuid16() - sets real and effective user ids of the current process to given values</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#description","title":"Description","text":"<p>setreuid16() sets the real and effective user ids of the current process to the given values. It is the equivalent of setreuid(2) that uses 16 bit user identifiers, which is the same as the setuid(2) system call on 16 bit ids. This allows programs which use the 16 bit user identifiers to switch the user id of the current process. To change the user ids of another process use setreuid(2). </p> <p>Edge cases: * If the effective user id is equal to the process's real user id and the effective user id is changed, then the saved set-user-ID of the executable will be set to the new effective user id. * If either of the new IDs matches the saved set-user-ID, then the saved set-user-ID will be cleared and the set-user-ID bit in the process's set of file mode creation flags will be cleared.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t</code> - real user ID.</li> <li><code>euid</code>:<code>old_uid_t</code> - effective user ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#setreuid16_1","title":"setreuid16","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#purpose","title":"Purpose","text":"<p>In order to trace the setreuid16 system call execution for debugging purpose.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#example-use-case","title":"Example Use Case","text":"<p>setreuid16() can be used to switch the user id of the current process with the given real and effective user ids. This may be useful in situations where a process needs to gain extra privileges while still running under a different user.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#issues","title":"Issues","text":"<p>Changing the user id of the process is a powerful action, and care needs to be taken to make sure that the effective user id is the same as the real user id. This is because if the effective user id is different from the real user id, then the saved set-user-ID of the executable will also be set to the effective user id.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#related-events","title":"Related Events","text":"<p>setuid16(), seteuid16(), setfsuid16(), setreuid(), setuid(), seteuid(), setfsuid(), setresuid(), setresuid16(), chroot()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/","title":"setrlimit","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#intro","title":"Intro","text":"<p>setrlimit - setting resource limits for processes</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#description","title":"Description","text":"<p>The <code>setrlimit()</code> system call is used to set limits on the resources that can be consumed by a process. These limits can be used to limit the amount of memory, number of open files and processes, and other resources that a process can utilize. There are two types of limits which can be set with <code>setrlimit()</code>: soft limits and hard limits. The soft limit can be exceeded temporarily, while the hard limit can not be exceeded at all. The hard limit is typically much lower than the soft limit.</p> <p>One advantage of using <code>setrlimit()</code> is that it can help protect a process from consuming too many resources, which could lead to crashing. It also can help prevent situations where other processes suffer because one process is taking up too many resources.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code>[K] - the type of resource limit to be set. The value of this parameter must be one of the constants specified in <code>&lt;sys/resource.h&gt;</code>.</li> <li><code>rlim</code>:<code>const struct rlimit*</code>[K] - a pointer to a <code>struct rlimit</code> that contains the new limits to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setrlimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#sys_setrlimit","title":"sys_setrlimit","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#purpose","title":"Purpose","text":"<p>To track resource limits being set by processes.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#example-use-case","title":"Example Use Case","text":"<p>The <code>setrlimit()</code> system call can be used to limit the amount of memory used by a given process. This is useful for ensuring that processes do not consume too much memory, which can lead to instability.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#issues","title":"Issues","text":"<p>The <code>setrlimit()</code> system call is not well understood by many developers. Misuses can lead to instability and crashes.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#related-events","title":"Related Events","text":"<ul> <li>getrlimit - provides information about the resources used by the process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setsid/","title":"setsid","text":""},{"location":"docs/events/builtin/syscalls/setsid/#intro","title":"Intro","text":"<p>setsid - create a new session and set the process group ID.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#description","title":"Description","text":"<p>The <code>setsid()</code> system call is instrumental in creating a new session.</p> <p>A session is a collection of process groups, typically used in terminal job control. When a process calls <code>setsid()</code>, it becomes the leader of a new session, the leader of a new process group, and detaches from its controlling terminal.</p> <p>This mechanism is foundational for daemon processes in Unix-like systems, allowing them to dissociate from their parent shell and run in the background, independent of the user's session.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#arguments","title":"Arguments","text":"<p>This system call doesn't take any arguments.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setsid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setsid/#sys_setsid","title":"sys_setsid","text":""},{"location":"docs/events/builtin/syscalls/setsid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setsid/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>setsid()</code> system call is invoked, marking the creation of a new session and process group.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the creation of new sessions is vital in scenarios where tracking background processes, daemonizing processes, or job control is essential, such as in system initialization or process supervision.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#issues","title":"Issues","text":"<p>Misusing <code>setsid()</code> can cause processes to become orphaned unintentionally or detached from their expected sessions, leading to potential mismanagement of resources or processes running without supervision.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#related-events","title":"Related Events","text":"<ul> <li><code>setpgid()</code> - Set the process group ID for a process.</li> <li><code>getpgid()</code> - Retrieve the process group ID of a process.</li> <li><code>getpgrp()</code> - Get the process group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/","title":"setsockopt","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#intro","title":"Intro","text":"<p>setsockopt - call that sets options on sockets </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#description","title":"Description","text":"<p>The setsockopt() function sets options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level. When manipulating socket options, the level at which the option resides and the name of the option must be specified. </p> <p>The setsockopt() function sets the option specified by the option_name argument. Optval argument is a value that depends on the option being set. The optlen argument specifies the length of the option value, in bytes. </p> <p>Edge cases of this system call are when the optval argument points to an invalid pointer or the optlen argument contains an invalid length. In these cases, it will return an error. An advantage of this system call is that it allows users to manipulate socket options, enabling them to customize their socket for a variety of applications. </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Socket file descriptor.</li> <li><code>level</code>:<code>int</code>[K] - The protocol level which will be affected.</li> <li><code>optname</code>:<code>int</code>[K] - Socket option name. </li> <li><code>optval</code>:<code>const void *</code>[K] - Socket option value. </li> <li><code>optlen</code>:<code>int</code>[K] - Size of the option value, in bytes. </li> </ul>"},{"location":"docs/events/builtin/syscalls/setsockopt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#sys_setsockopt","title":"sys_setsockopt","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#purpose","title":"Purpose","text":"<p>Monitoring of socket operations.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#example-use-case","title":"Example Use Case","text":"<p>The setsockopt() can be used to set options on a socket such as the SO_RCVTIMEO flags. This will allow a read operation on a socket to timeout after the specified period of time. This can be utilized in situations where network streaming must be cut off a certain point in time. </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#issues","title":"Issues","text":"<p>Since setsockopt() is a privileged call, careless application developers could write code which grants more capabilities to processes than necessary, in some cases leading to privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#related-events","title":"Related Events","text":"<ul> <li>socket()</li> <li>connect()</li> <li>bind()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/","title":"settimeofday","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#intro","title":"Intro","text":"<p>settimeofday - sets the system's time and date, and optional timezone</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#description","title":"Description","text":"<p>The settimeofday() system call is used to set the system's time, and optionally also the timezone if the tz parameter is not NULL. This is usually used when synchronizing the system's time with an external time source. In order to set the timezone, there must also be an associated time value. When setting the time only, the tz parameter should be NULL.</p> <p>There are some caveats when it comes to setting the time or the timezone. The kernel will not accept values which are out of valid ranges, or are otherwise invalid. Additionally, there can be side effects depending on the system where settimeofday() is called. For example, on some systems setting the time may cause certain user tasks to be interrupted.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#arguments","title":"Arguments","text":"<ul> <li><code>tv</code>:<code>const struct timeval*</code>[K] - Pointer to const struct timeval. Should contain the desired time to be set.</li> <li><code>tz</code>:<code>const struct timezone*</code>[K] - Pointer to const struct timezone. Should contain the desired timezone to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/settimeofday/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/settimeofday/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#settimeofday_1","title":"settimeofday","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#purpose","title":"Purpose","text":"<p>Monitoring timezone changes and time changes</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#example-use-case","title":"Example Use Case","text":"<p>One can use settimeofday() to monitor changes in system time or timezone.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#issues","title":"Issues","text":"<p>settimeofday() is vulnerable to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#related-events","title":"Related Events","text":"<p>setitimer() - set interval timer</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setuid/","title":"setreuid","text":""},{"location":"docs/events/builtin/syscalls/setuid/#intro","title":"Intro","text":"<p>setreuid - set real and effective user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#description","title":"Description","text":"<p>The <code>setreuid()</code> system call allows a process to set both its real user ID and its effective user ID.</p> <p>This provides flexibility in managing user-based privileges, especially for processes that need to toggle between different levels of privileges temporarily. In Unix-like systems, the real user ID identifies the user who launched the process, whereas the effective user ID dictates the permissions for process operations.</p> <p>By modifying these IDs selectively, processes can execute specific tasks under one identity and then revert to another, thereby enhancing system security by minimizing the time a process runs with elevated privileges.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t</code>[K] - The real user ID to be set. If this argument is -1, the real UID is not changed.</li> <li><code>euid</code>:<code>uid_t</code>[K] - The effective user ID to be set. If this argument is -1, the effective UID is not changed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setuid/#sys_setreuid","title":"sys_setreuid","text":""},{"location":"docs/events/builtin/syscalls/setuid/#type","title":"Type","text":"<p>Tracepoint (through <code>sys_enter</code>).</p>"},{"location":"docs/events/builtin/syscalls/setuid/#purpose","title":"Purpose","text":"<p>To observe and trace when the <code>setreuid()</code> system call is executed, capturing information about the changes made to the real and effective user IDs.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring privilege transitions is crucial in environments that prioritize security, particularly when tracking potential privilege escalation scenarios or processes that are expected to change their operational context frequently.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#issues","title":"Issues","text":"<p>If misused or if programs leveraging <code>setreuid()</code> contain vulnerabilities, they can be exploited to gain unauthorized privileges, leading to potential security breaches.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#related-events","title":"Related Events","text":"<ul> <li><code>setuid()</code> - Set the effective user ID of the calling process.</li> <li><code>setresuid()</code> - Set real, effective, and saved user IDs.</li> <li><code>seteuid()</code> - Set effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and reviewed by a Human.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/","title":"setuid16","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#intro","title":"Intro","text":"<p>setuid16 - sets the effective user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#description","title":"Description","text":"<p>setuid16() sets the effective user ID of the calling process. The argument uid is used to set the  effective user ID of the caller.</p> <p>If the calling process is privileged (i.e., owns the superuser id), the effective user ID can be set to any value.</p> <p>Under normal conditions, an unprivileged process may change the real and saved user IDs to the value of uid only if they match its own real (or effective, if uid is not privileged) user ID. A privileged process (under Linux: one having the CAP_SETUID capability) may set the effective user ID to any value.</p> <p>The related seteuid16(), setreuid16() and setresuid16() provide more fine-grain control over processes' privilege.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#arguments","title":"Arguments","text":"<ul> <li><code>uid</code>:old_old_uid_t[KU] - user ID of the new set of the IDs.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#setuid16_1","title":"setuid16","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#purpose","title":"Purpose","text":"<p>Monitoring of user identity changes.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#example-use-case","title":"Example Use Case","text":"<p>One example of use case of setuid16 is to trace a malicious thread changing its user identity and running malicious code.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#issues","title":"Issues","text":"<p>There are no known issues with setuid16.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#related-events","title":"Related Events","text":"<p>setreuid16, setresuid16, seteuid16.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/","title":"setxattr","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#intro","title":"Intro","text":"<p>setxattr - Set extended attributes on regular, special, and symbolic link files</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#description","title":"Description","text":"<p>The setxattr() system call sets the extended attributes associated with the file path to the name, value and size pointed to by the arguments name, value and size, respectively. The flags argument is a bitwise-or of flags that let the application control how the extended attribute is created. </p> <p>If the name is except for existing attributes and the size of the attribute is larger than the existing attribute, the existing value is overwritten. If the attribute does not exist on the file and the size of the attribute is 0, a new attribute is created.</p> <p>The flags argument can be used to control how the extended attribute is created, or if it should fail if the extended attribute already exists. The flags value should be set to 0 to create a new attribute, or the value XATTR_CREATE to ensure that the attribute is newly created and will fail with an EEXIST error if it already exists.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - The full path to the file to set the extended attribute.</li> <li><code>name</code>:<code>const char*</code>[U] - The name of the extended attribute to set.</li> <li><code>value</code>:<code>const void*</code>[U] - The value to set the extended attribute to. </li> <li><code>size</code>:<code>size_t</code>[U] - The size in bytes of the value.</li> <li><code>flags</code>:<code>int</code>[U] - Bitwise-or of flags that let the application control how the extended attribute is created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#do_setxattr","title":"do_setxattr","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#purpose","title":"Purpose","text":"<p>Inspect execution of the setxattr system call.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#example-use-case","title":"Example Use Case","text":"<p>setxattr can be used to set extended attributes on a regular file, special file, or symbolic link. These attributes can be used to store arbitrary information associated with the file, such as data needed to validate a cryptographic signature or provide access control information. </p>"},{"location":"docs/events/builtin/syscalls/setxattr/#issues","title":"Issues","text":"<p>setxattr is vulnerable to TOCTOU (time of check, time of use) attack.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#related-events","title":"Related Events","text":"<ul> <li>getxattr - Get extended attributes associated with a file </li> <li>listxattr - Return lists of extended attributes for a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/","title":"sgetmask","text":""},{"location":"docs/events/builtin/syscalls/sgetmask/#intro","title":"Intro","text":"<p>sgetmask - Get the current signal mask of the calling thread</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#description","title":"Description","text":"<p>The sgetmask() syscall retrieves the current signal mask for the calling thread in the form of an integer. The signal mask consists of a set of bits, one for each signal, that specifies which signals are blocked from delivery to the thread. By default, signals will always be blocked when they are generated. This syscall allows processes to customize this behavior by blocking or unblocking specific signals. It is not possible to unblock signals that were not blocked in the first place.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#arguments","title":"Arguments","text":"<p>No arguments.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#hooks","title":"Hooks","text":"<p>No hooks configured.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#example-use-case","title":"Example Use Case","text":"<p>This syscall could be used in multi-threaded applications to discover which signals are blocked in each thread. This could be used to implement custom signal handling strategies on a per-thread basis.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#issues","title":"Issues","text":"<p>This syscall may be vulnerable to TOCTOU (time of check, time of use) race conditions. It is possible that a signal mask could be changed between the time the syscall is invoked and the time the updated signal mask value is returned.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask() - Used to set or retrieve the signal mask of a specified process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmat/","title":"shmat","text":""},{"location":"docs/events/builtin/syscalls/shmat/#intro","title":"Intro","text":"<p>shmat - Attach a shared memory segment.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#description","title":"Description","text":"<p>The <code>shmat</code> system call attaches the shared memory segment identified by <code>shmid</code> to the address space of the calling process. <code>shmaddr</code> specifies the address at which the shared memory segment is attached. If shmaddr is NULL, the system will choose an address at which to attach the segment. The <code>shmflg</code> parameter specifies characteristics of the attachment, including read/write permissions.</p> <p>A successful call to <code>shmat</code> returns the address of the attached shared memory segment. The segment is detached from the address space of the calling process with <code>shmdt</code>.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#arguments","title":"Arguments","text":"<ul> <li><code>shmid</code>:<code>int</code>[K] - Identifier of the shared memory segment to be attached.</li> <li><code>shmaddr</code>:<code>const void*</code>[U] - If not NULL, address the segment should                     be attached at.</li> <li><code>shmflg</code>:<code>int</code>[K] - Specifies various flags for the attachment:                     <pre><code>SHM_RDONLY = 0x001  - Segment attached read-only\nSHM_RND    = 0x002  - Round addr to SHMLBA boundary\nSHM_REMAP  = 0x004  - Map into current address space\nSHM_RXAREA = 0x008  - Force/allow read/execute\nSHM_EXEC   = 0x010  - Segment attached execute-only\n</code></pre></li> </ul>"},{"location":"docs/events/builtin/syscalls/shmat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmat/#shmat_common","title":"shmat_common","text":""},{"location":"docs/events/builtin/syscalls/shmat/#type","title":"Type","text":"<p>kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/shmat/#purpose","title":"Purpose","text":"<p>To measure the execution time of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#example-use-case","title":"Example Use Case","text":"<p>Event <code>shmat</code> could be used when an application needs to access a shared memory segment that is not mapped in the address space.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code> - Create or map a memory segment.</li> <li><code>shmdt</code> - Detach a shared memory segment.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/","title":"shmctl","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#intro","title":"Intro","text":"<p>shmctl - System V shared memory operations</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#description","title":"Description","text":"<p>The <code>shmctl</code> system call is used to control System V (SVIPC) shared memory segments. It operates on the shared memory segment identified by the given <code>shmid</code> value. The <code>cmd</code> argument is used to specify the specific operation that needs to be performed. The <code>buf</code> argument is used to tell the kernel additional information about the operation, such as the data structure of <code>struct shmid_ds</code> defining the permission and size of the shared memory segment.</p> <p>The <code>shmctl</code> system call is generally used to control the state of shared memory segments, like attach, detach, get the size of a segment, change permissions and so on.</p> <p>The main advantages of using <code>shmctl</code> are that it provides an interface which is generic, easy to use and allows a range of different operations on shared memory segments.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#arguments","title":"Arguments","text":"<ul> <li><code>shmid</code>:<code>int</code>[K] - The id of the shared memory segment as returned by   <code>shmget</code>.</li> <li><code>cmd</code>:<code>int</code>[K] - The command to be performed on the shared memory segment,   can range from <code>IPC_STAT</code> to <code>IPC_RMID</code>.</li> <li><code>buf</code>:<code>struct shmid_ds*</code>[K] - Pointer to the buffer containing the   information about the command to be performed on the shared memory segment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#sys_shmctl","title":"<code>sys_shmctl</code>","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#purpose","title":"Purpose","text":"<p>Hooked to get invoked whenever a <code>shmctl</code> system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>shmctl</code> system call can be useful for development in data structures, message passing and process scheduling for distributed computing systems. It can be used to create shared memory segments, update information about existing memory segments, remove shared memory segments and more.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#issues","title":"Issues","text":"<p>Since the <code>shmctl</code> system call is vulnerable to TOCTOU (time-of-check/time-of-use) attack, as some of its arguments can change between the time they are checked and used,  it is very important to be aware of the security implications.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#related-events","title":"Related Events","text":"<ul> <li><code>shmget</code></li> <li><code>shmat</code></li> <li><code>msgget</code></li> <li><code>msgsnd</code></li> <li><code>msgrcv</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/","title":"shmdt","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#intro","title":"Intro","text":"<p>shmdt - detach a shared memory segment from the caller's data segment</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#description","title":"Description","text":"<p>The <code>shmdt()</code> syscall detached a shared memory segment from the caller's data segment. It shall be used after a shared memory segment is no longer needed. When a shared memory segment is attached, it becomes part of the address space of the calling process, and the calling process must explicitly detach it. An <code>shmdt()</code> call destroys the association between the process and the shared memory segment. If a process has multiple shared memory attachments, each must be detached individually.</p> <p>When the last process detaches a segment, the segment is deleted and its resources are returned to the system. If a segment is detached while processes still have the segment attached, the state of the segment persists until all processes have detached it.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#arguments","title":"Arguments","text":"<ul> <li><code>shmaddr</code>:<code>const void*</code>[K] - pointer to the shared memory segment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmdt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmdt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#shmdt_1","title":"shmdt","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/shmdt/#purpose","title":"Purpose","text":"<p>The <code>shmdt()</code> syscall is used to detach a shared memory segment from the caller's data segment, so it is important to understand when this event is called.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#example-use-case","title":"Example Use Case","text":"<p>For example, you can monitor when shared memory is being detached and gather information such as the process PID and the address of the segment being detached.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#issues","title":"Issues","text":"<p>Currently, the shmdt() syscall is not able to detach more than one shared memory segment at a time.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#related-events","title":"Related Events","text":"<ul> <li>shmget - get a shared memory segment</li> <li>shmat - attach a shared memory segment</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmget/","title":"shmget","text":""},{"location":"docs/events/builtin/syscalls/shmget/#intro","title":"Intro","text":"<p>shmget - used to get a shared memory segment</p>"},{"location":"docs/events/builtin/syscalls/shmget/#description","title":"Description","text":"<p>shmget is a SystemV IPC system call that is used to get a shared memory segment. It requires the caller to provide a key, size and flag argument. If the key identified by the key argument exists, the call returns the identifier of the shared memory region associated with it. If the key does not exist, a new region is created and its identifier is returned, or the call fails according to the argument flags. Some of the possible flags include: IPC_CREAT, IPC_EXCL and SHM_HUGETLB.</p> <p>Caution should be used when using IPC_EXCL and IPC_CREAT flags together, as it is vulnerable to time of check/time of use (TOCTOU) race condition.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code>[U] - key for the shared memory segment. This should be generated using ftok and must be unique;</li> <li><code>size</code>:<code>size_t</code>[U] - size of the shared memory segment in bytes;</li> <li><code>shmflg</code>:<code>int</code>[U] - this argument's value mitght consists of various flags, like IPC_CREAT, IPC_EXCL, etc.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmget/#sys_ipc","title":"<code>sys_ipc</code>","text":""},{"location":"docs/events/builtin/syscalls/shmget/#type","title":"Type","text":"<p>bpf kprobe</p>"},{"location":"docs/events/builtin/syscalls/shmget/#purpose","title":"Purpose","text":"<p>This function is hooked to trace when the shmget syscall is called.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#example-use-case","title":"Example Use Case","text":"<p>shmget can be used to create a shared memory segment, for example, between two applications that need to communicate.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#issues","title":"Issues","text":"<p>Due to the TOCTOU sensitivity of using IPC_EXCL and IPC_CREAT flags together, caution is recommended when using those flags.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#related-events","title":"Related Events","text":"<p>shmat - used to attach the shared memory segment to the process address space  shmdt - used to detach the shared memory segment from the process address space</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/","title":"shutdown","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#intro","title":"Intro","text":"<p>shutdown - Request that a connection be shut down </p>"},{"location":"docs/events/builtin/syscalls/shutdown/#description","title":"Description","text":"<p>The <code>shutdown</code> call requests that a given connection be severed. The <code>how</code> argument specifies the way in which the connection should be shut down: * 0 - No more receives. * 1 - No more sends. Adding 2 to the above values (2 and 3) requests that the connection also be terminated and that the resources associated with the connection be released.</p> <p>This call can be used to perform a half-closed shutdown, in which one side of the connection is open for sending data and the other side is closed for receiving data.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor associated with the socket.</li> <li><code>how</code>:<code>int</code> - Defines how to shutdown connection.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shutdown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shutdown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#shutdown_1","title":"shutdown","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#purpose","title":"Purpose","text":"<p>Monitor the connection resources associated with a socket and detect anomalies.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#example-use-case","title":"Example Use Case","text":"<p>The shutdown event can be used to monitor socket connections and detect resource leaks at the same time. This is especially useful when debugging applications that create multiple network connections in order to verify that the required resources are released when the connection is severed.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#issues","title":"Issues","text":"<p>There are some issues with using the <code>shutdown</code> syscall due to the fact that it requires the application to have access to the socket associated with the connection. This means that any applications that do not have permission to access this socket will be unable to shut down the connection.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#related-events","title":"Related Events","text":"<ul> <li>connect</li> <li>close</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/","title":"sigaction","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#intro","title":"Intro","text":"<p>sigaction - manipulate signal actions</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#description","title":"Description","text":"<p>This event manipulates the action taken by a process on receipt of particular signal. These signals can be generated internally by the kernel, by user programs, or sourced externally from the hardware. The action parameter describes what is to be done when the signal arrives.</p> <p>The program specifies an action and a signal number, along with an optional set of flags which modify the behavior of the signal. The act argument points to a structure which specifies a signal handler and also includes a set of flags that modify the behavior of the sigaction call. The oact argument points to a location where a copy of the old signal action is stored.</p> <p>This syscall is used when user has to register multiple signal handlers and modify existing registered actions efficiently. Since different signals can be received, sigaction helps in implementing context-dependent behavior in the application, allowing it to react differently to different signals.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>sig</code>:<code>int</code> - the signal number</li> <li><code>act</code>:<code>const struct sigaction*</code>[K] - a pointer to a signal-handling function or a set of flags</li> <li><code>oact</code>:<code>struct sigaction*</code>[K-TOCTOU] - an optional pointer to a signal-handling function or a set of flags</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaction/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#do_sigaction","title":"do_sigaction","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/sigaction/#purpose","title":"Purpose","text":"<p>To trace the signal action taken when signal deliveres</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#purpose_1","title":"Purpose","text":"<p>To trace the signal action taken when signal occurs</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#example-use-case","title":"Example Use Case","text":"<p>This event is useful for system administrators monitoring applications. When an application fails, signals can be sent to the application to notify the administrator and/or take action. This event can be used to trace these signal actions and create an audit trail.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#issues","title":"Issues","text":"<p>The signal may arrive between the time when <code>sigaction</code> is called and when the signal handler is installed. This means that a signal the user didn't anticipate can still arrive, causing parts of the application to misbehave.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#related-events","title":"Related Events","text":"<ul> <li><code>sigprocmask</code> - Get and/or change the signal mask of a process (which signals are blocked)</li> <li><code>sigpending</code> - Get list of signals that are blocked and pending for delivery to the process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/","title":"sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#intro","title":"Intro","text":"<p>sigaltstack - Sets or gets the signal stack context</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#description","title":"Description","text":"<p>The <code>sigaltstack</code> syscall can be used to set or get the signal stack context of a process. It sets a new signal stack for the process (or retrieves the previously set one) and specifies a <code>sigaction</code> structure that determines what should be done when signals are delivered to that stack. This is useful for separating execution stacks for signal handlers and other asynchronous events, for example for dealing with asynchronous interrupts. The <code>sigaltstack</code> syscall can also be used to enable or disable the alternate stack which can improve the performance of the process in receiving signals.</p> <p>There are two main advantages of using <code>sigaltstack</code>. Firstly, it allows users to control the stack used during signals to limit the amount of data that must be copied around. Secondly, it allows users to create a dedicated signal stack, enabling them to have a separate memory space for signal handlers that is independent of the current stack frame.</p> <p>However, there are some drawbacks to consider when using sigaltstack:</p> <ul> <li>There is a limit on the size of the alternate stack. This means that some signals might not fit onto the stack and thus fail without their handler being executed.</li> <li>The <code>sigaltstack</code> syscall is potentially vulnerable to a TOCTOU attack. Furthermore, due to the alternate stack, access to certain parts of the program may be restricted while the signal is being processed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#arguments","title":"Arguments","text":"<ul> <li><code>ss</code>:<code>const stack_t*</code>[K,U] - Pointer to a stack_t structure containing the alternate stack data.</li> <li><code>old_ss</code>:<code>stack_t*</code>[U] - Pointer to a stack_t structure where the currently active stack will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#sys_sigaltstack","title":"sys_sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#purpose","title":"Purpose","text":"<p>To disable the alternate stack before the sigaltstack syscall is executed and to enable it afterwards. This allows us to ensure that any signal handler is only using the alternate stack and not a user space stack.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#user_sigaltstack","title":"user_sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#type_1","title":"Type","text":"<p>Uprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#purpose_1","title":"Purpose","text":"<p>To trace any sigaltstack syscalls happening in a user space context. This allows us to track any attempted signals that might be generated as a result of the sigaltstack syscall.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#example-use-case","title":"Example Use Case","text":"<p>sigaltstack can be used to handle certain signals that cause program execution flow interruption, such as SIGSEGV and SIGINT. By setting an alternate stack and catching the interrupt-based signals, the program can be protected from crashing due to a segmentation fault.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#issues","title":"Issues","text":"<p>The <code>sigaltstack</code> syscall is vulnerable to TOCTOU (Time Of Check, Time Of Use) attacks, meaning that a malicious actor could potentially corrupt the signal stack pointer between the time when it is checked and the time it is used to stage the signal handler.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#related-events","title":"Related Events","text":"<ul> <li>signal: Used to register signal handlers.</li> <li>sigaction: Used to define how a signal should be handled. </li> <li>sigsuspend: Used to pause the process until a signal is received.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signal/","title":"signal","text":""},{"location":"docs/events/builtin/syscalls/signal/#intro","title":"Intro","text":"<p>Signal - sends a signal specifying its number (<code>signum</code>), plus an optional <code>handler</code>, to the calling process or process group.</p>"},{"location":"docs/events/builtin/syscalls/signal/#description","title":"Description","text":"<p>The <code>signal</code> syscall is used to send a signal to one or more process, specify by its <code>signum</code> and with optional <code>handler</code> (the function being executed when the signal is delivered). It can be used to send signals like <code>SIGTERM</code> and <code>SIGKILL</code> to terminate processes, as well as custom signals to communicate information or initiate actions from other processes. </p> <p>Signals can be blocked depending on their type, so it is important to take that into account when sending a signal.</p>"},{"location":"docs/events/builtin/syscalls/signal/#arguments","title":"Arguments","text":"<ul> <li><code>signum</code>: <code>int</code> - the signal number to send. The list of available signals is described in the <code>signal(7)</code> manual page.</li> <li><code>handler</code>: <code>sighandler_t</code>[K] - optional pointer to the function to be executed upon arrival of the signal.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signal/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signal/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signal/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/signal/#type","title":"Type","text":"<p>Tracepoint + Kprobe</p>"},{"location":"docs/events/builtin/syscalls/signal/#purpose","title":"Purpose","text":"<p>Gather data and figure out what function is executed when the signal is received.</p>"},{"location":"docs/events/builtin/syscalls/signal/#example-use-case","title":"Example Use Case","text":"<p>One example of use of the <code>signal</code> event is to count how many signals of a particular kind (in this case, SIGTERM) were sent and received during a given period of time.</p>"},{"location":"docs/events/builtin/syscalls/signal/#issues","title":"Issues","text":"<p>Due to the asynchronous and unreliable nature of signals, in some cases signals may be lost or delivered late.</p>"},{"location":"docs/events/builtin/syscalls/signal/#related-events","title":"Related Events","text":"<ul> <li><code>kill</code> - similar to signal but with a more precise target.</li> <li><code>waitid</code> - used to wait for processes and identify the signal sent.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/","title":"signalfd","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#intro","title":"Intro","text":"<p>signalfd - creates a file descriptor that can be used to accept signals</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#description","title":"Description","text":"<p>signalfd() creates an object of type \u201csignalfd\u201d that can be used to accept signals. The signalfd file descriptor is returned. Once it is created, the signals specified in the set argument will be accepted by the file descriptor and handled according to the flags argument. If multiple threads are waiting for the same signal, their calls to signalfd() will all be queued; each call will receive the same signalfd. If the same signal is received though, the previous one will be packed into the structure until it is read by the user.</p> <p>The events signalled by a signalfd() call can be edge-triggered or level-triggered depending on the flags argument. The signalfd() call also allows for implementation of a signal queue. </p> <p>Advantages of using signalfd() instead of signal() include increased file descriptor limits, asynchronous notification and synchronization of signal delivery. Signalfd() calls are also generally more reliable than their signal() counterparts and more efficient in terms of CPU usage. </p>"},{"location":"docs/events/builtin/syscalls/signalfd/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor returned.</li> <li><code>mask</code>:<code>sigset_t*</code>[U, TOCTOU] - pointer to the signals that will be handled by the file descriptor.</li> <li><code>flags</code>:<code>int</code>[K] - flags that determine if the handled signals will be edge- or level-triggered.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#do_signalfd","title":"do_signalfd","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#purpose","title":"Purpose","text":"<p>Hook the return point from signalfd.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#do_signalfd4","title":"do_signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#purpose_1","title":"Purpose","text":"<p>Hook the sycall signalfd entry point.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#example-use-case","title":"Example Use Case","text":"<p>Signalfd can be used to provide asynchronous notification of pending signals. For instance, a multitasking daemons or services could be designed to respond quickly to events and signals received by certain file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#issues","title":"Issues","text":"<p>Signalfd is subject to the Time of check-time of use race condition, where the operation between a check on the validity of a resource and an operation on the same resource is visible or exploitable.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#related-events","title":"Related Events","text":"<ul> <li>select - Can be used to multiplexing I/O operations on multiple file descriptors in a single thread.</li> <li>pselect - Same as select but also sets a timeout argument to prevent blocking.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/","title":"signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#intro","title":"Intro","text":"<p>signalfd4 - create a file descriptor to receive signals</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#description","title":"Description","text":"<p>The signalfd4() system call is used to create an \"eventfd\" object which can be used to receive notifications of signals. It is similar to the signalfd() system call, but in addition it allows the user to specify an additional 'mask' parameter which can be used to limit which signals are monitored. The 'mask' parameter is a bitmask of the signals to monitor. The 'sizemask' parameter is the size of the 'mask' parameter in bytes. The 'flags' parameter can be used to fine-tune the behavior of the call.</p> <p>Signalfd4() allows for very precise signal handling and can be used to reduce the amount of signal handling work a process needs to do. It can also be used to throttle signal delivery or prevent signal flooding.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor.</li> <li><code>mask</code>:<code>const sigset_t*</code>[K] - a bitmask of signals to monitoring, 0 to only monitor SIGIO.</li> <li><code>sizemask</code>:<code>size_t</code> - size of the 'mask' parameter, in bytes.</li> <li><code>flags</code>:<code>int</code> - flags to fine-tune the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#signalfd4_1","title":"signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#type","title":"Type","text":"<p>Kprobe/Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#purpose","title":"Purpose","text":"<p>To add instrumentation to the signalfd4() syscall to retrieve arguments and return value from the syscall </p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#example-use-case","title":"Example Use Case","text":"<p>For example, an application may need to wait for a signal to arrive and then process the signal. Rather than having to check for the signal periodically and receive it synchronously, the application can use signalfd4() to create a file descriptor that will be notified whenever the signal arrives. </p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#issues","title":"Issues","text":"<p>This system call is not available in all systems, check for availability in the Linux manual page.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#related-events","title":"Related Events","text":"<p>The related event to this syscall are read(), write(), poll(), signalfd() and exit().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/","title":"sigpending","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#intro","title":"Intro","text":"<p>sigpending - Check the signals that are pending for the process.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#description","title":"Description","text":"<p>The sigpending() system call queries the pending signals for the calling  process  (check  which signals have been raised while blocked). It fills in the signal set pointed to by set, which  is  of type sigset_t, with the set of signals currently pending for the process.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The most useful edge-case is that it allows a process to find out signals that have been sent to it, but blocked by the process with <code>sigprocmask()</code>.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>sigset_t*</code>[U] - Pointer to a signal set which will be set to the set of pending signals for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigpending/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigpending/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#do_sigpending","title":"do_sigpending","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#purpose","title":"Purpose","text":"<p>Triggers every time the system call is made, allowing to analyze what was the source of the call.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#example-use-case","title":"Example Use Case","text":"<p>For example, this system call can be used to create a signal handler to check whether or not a particular signal is blocked.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#related-events","title":"Related Events","text":"<p>signal, sigprocmask, sigaction</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/","title":"sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#intro","title":"Intro","text":"<p>sigprocmask - using signal sets, this function is used to examine and change the signal mask of the calling thread.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#description","title":"Description","text":"<p>sigprocmask is used examine and / or alter the signal mask of the calling thread. Passing SIG_SETMASK as the how parameter will replace the entire mask with the set value, while passing SIG_SETMASK &amp; SIG_BLOCK adds the set value to the existing mask. SIG_SETMASK &amp; SIG_UNBLOCK removes the set value from the existing mask, while SIG_SETMASK &amp; SIG_UNBLOCK =0 returns the current mask without changing it. If a non-null oldset is passed, the existing mask will be stored in oldset.</p> <p>Using this function, it is possible to temporarily block certain signals or alter them to ignore them without actually modifying their disposition.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#arguments","title":"Arguments","text":"<ul> <li><code>how</code>:<code>int(SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK)</code> - specifies what action to take with the set parameter.</li> <li><code>set</code>:<code>const sigset_t *restrict</code>[K,TOCTOU] - a pointer to the signal set defining the signals which are to be blocked, unblocked or returned.</li> <li><code>oldset</code>:<code>sigset_t *restrict</code>[K,U] - a pointer (allocated by the caller) to a sigset_t structure in which the existing mask will be store (if non-null).</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#do_sigprocmask","title":"do_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#purpose","title":"Purpose","text":"<p>Analyzation of the use of the sigprocmask syscall and tracking the changes made to the signal mask.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#example-use-case","title":"Example Use Case","text":"<p>This function can be used in a process that needs to temporarily block certain signals.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#issues","title":"Issues","text":"<p>sigprocmask() is vulnerable to TOCTOU (Time of Check, Time of Use) attacks which could result in security issues.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#related-events","title":"Related Events","text":"<ul> <li>signal() - Used to send a signal to a process or thread.</li> <li>sigaddset() - Used to add an individual signal to a signal set.</li> <li>sigdelset() - Used to delete an individual signal from a signal set.</li> <li>sigemptyset() - Used to initialise or clear a signal set to the empty set.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/","title":"sigreturn","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#intro","title":"Intro","text":"<p>sigreturn - restore process state after receiving a signal</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#description","title":"Description","text":"<p>The <code>sigreturn()</code> system call restores the calling process' pre-signal state, and is usually used when the user wants to implement their own signal handlers. This can be done by setting the <code>SA_SIGINFO</code> flag when registering the signal handler, and then calling <code>sigreturn()</code> in order to restore the process state. One of the main advantages of using <code>sigreturn()</code> is that it is significantly faster than <code>sigaction()</code>.</p> <p>However, there are some drawbacks to using this system call. Most notably, any change that is made to the process state after calling <code>sigreturn()</code>, before the process is switched from the kernel to user space again, will be lost. This includes changes to any data structures, resources, or file descriptors, as well as any additional system calls that might be made.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#arguments","title":"Arguments","text":"<p>This system call takes no arguments.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#purpose","title":"Purpose","text":"<p>This function is hooked in order to catch the <code>sigreturn()</code> system call and perform any necessary cleanup tasks.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#example-use-case","title":"Example Use Case","text":"<p>One use case for <code>sigreturn()</code> might be a signal handler that can be used to safely shut down a process. Since <code>sigreturn()</code> restores the process's state to its state before the signal, it can be used in order to safely shut down the process without causing any errors or data inconsistencies.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#issues","title":"Issues","text":"<p>There are no known issues with the <code>sigreturn()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#related-events","title":"Related Events","text":"<ul> <li><code>sigaction()</code> - register a signal handler</li> <li><code>sigprocmask()</code> - manipulate a process's signal mask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/","title":"sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#intro","title":"Intro","text":"<p>sigsuspend - temporarily replaces the signal mask of the executing thread with the given set of signals.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#description","title":"Description","text":"<p>The sigsuspend() system call suspends the caller until a signal is received. It is equivalent to</p> <pre><code>sigprocmask(SIG_SETMASK, &amp;mask, NULL);\npause();\n</code></pre> <p>The mask given as argument is used as the signal mask of the process during the period of suspension; upon return from the call it is restored to the previous value. While sigsuspend() is being executed, any signal may be accepted, except SIGKILL and SIGSTOP.</p> <p>The sigsuspend() function shall not return if it is interrupted by a signal handler and the signal handler does not return.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:const sigset_t*[K] - pointer to a signal set specifying the new signal mask for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#sigsuspend_1","title":"sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#purpose","title":"Purpose","text":"<p>To monitor when the program defines a new signal mask and waits until a signal is received.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#example-use-case","title":"Example Use Case","text":"<p>When monitoring a program that handles signals and the need to know when a new signal mask is set and in which order the signals are handled. </p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#issues","title":"Issues","text":"<p>If a signal is sent with a higher priority than SIGKILL and SIGSTOP, it might be missed by the call to sigsuspend().</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask()</li> <li>sigsuspend()</li> <li>sigpending()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socket/","title":"socket","text":""},{"location":"docs/events/builtin/syscalls/socket/#intro","title":"Intro","text":"<p>socket - create an endpoint for communication</p>"},{"location":"docs/events/builtin/syscalls/socket/#description","title":"Description","text":"<p>The socket() system call creates an endpoint for communication and returns a file descriptor that refers to that endpoint. It takes three arguments: domain, type, and protocol. These arguments define the properties of the communication protocol.</p> <p>The domain argument specifies a communication domain within which communication will take place. This argument specifies the protocol of the socket created and the type of address to be used.</p> <p>The type argument specifies the communications style and is typically one of SOCK_STREAM, SOCK_DGRAM, or SOCK_SEQPACKET.</p> <p>The protocol argument ranges from 0 to 255 and specifies the particular protocol to be used with the socket. Common values are IPPROTO_TCP, IPPROTO_UDP, IPPROTO_ICMP, and IPPROTO_IGMP.</p> <p>Edge-cases, drawbacks or advantages of using socket() could include: * Socket connection-less datagrams are faster than connection-oriented messages. * Socket connections are reliable and do not incur the same signal latency as connection-less datagrams. * Socket connection-oriented streams can provide reliable transmission of data at a higher bandwidth than datagrams, but the signal latency is greater.</p>"},{"location":"docs/events/builtin/syscalls/socket/#arguments","title":"Arguments","text":"<ul> <li><code>domain</code>:<code>int</code>[K] - The domain argument specifies the communication domain within which communication will take place.</li> <li><code>type</code>:<code>int</code>[K] - The type argument specifies the communications style and is typically one of SOCK_STREAM, SOCK_DGRAM, or SOCK_SEQPACKET.</li> <li><code>protocol</code>:<code>int</code>[K] - The protocol argument specifies the particular protocol to be used with the socket between 0 and 255.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socket/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/socket/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socket/#sys_socket","title":"sys_socket","text":""},{"location":"docs/events/builtin/syscalls/socket/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/socket/#purpose","title":"Purpose","text":"<p>To monitor the usage of the socket system call.</p>"},{"location":"docs/events/builtin/syscalls/socket/#example-use-case","title":"Example Use Case","text":"<p>The socket() system call can be used when creating a network service. For example, a web server can be created by creating a socket, binding it to an address, and listening for connections.</p>"},{"location":"docs/events/builtin/syscalls/socket/#issues","title":"Issues","text":"<p>socket() system call can be vulnerable to TOCTOU (time of check, time of use) issues.</p>"},{"location":"docs/events/builtin/syscalls/socket/#related-events","title":"Related Events","text":"<ul> <li>socketpair() - create a pair of connected sockets</li> <li>accept() - accept a connection on a socket</li> <li>bind() - bind a name to a socket</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/","title":"socketcall","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#intro","title":"Intro","text":"<p>socketcall - System call used to pass arguments of other socket calls</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#description","title":"Description","text":"<p>The <code>socketcall()</code> system call is used to pass a set of arguments of other socket related system calls in a single system call. This is used in many architectures since it has the advantage of reducing the number of system calls made when performing multiple operations executing multiple syscalls. However, this can be a security concern.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#arguments","title":"Arguments","text":"<ul> <li><code>call</code>: <code>int</code> - Specifies the actual call to perform, which should be one of the SOCKET_CMD constants.</li> <li><code>args</code>: <code>unsigned long*</code> - Pointer to a vector of arguments for the call, described in detail here.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketcall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketcall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#do_socketcall","title":"do_socketcall","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#purpose","title":"Purpose","text":"<p>This function is hooked to monitor and trace socket calls being executed.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#example-use-case","title":"Example Use Case","text":"<p>socketcall can be used to batch together multiple socket related system calls. This is useful when a program needs to perform a series of socket operations, such as connecting to a server, sending data, and then receiving data.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#issues","title":"Issues","text":"<p>Due to the nature of this system call, it introduces a security concern as the parameters are not verified by the kernel and can lead to a TOCTOU vulnerability.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#related-events","title":"Related Events","text":"<ul> <li>accept4</li> <li>connect</li> <li>getsockopt</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/","title":"socketpair","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#intro","title":"Intro","text":"<p>socketpair - creates an unnamed pair of connected sockets</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#description","title":"Description","text":"<p>The socketpair() system call creates a pair of connected anonymous unix domain sockets, which can be used in place of a pipe(2) to handle data exchange between processes. It is similar to socket(2), but differs in that it creates two connected sockets, rather than just one. It is typically used by programs that need to pass a file descriptor over a unix domain socket. The domain argument specifies a communications domain in which the sockets are to be created. The sockets may be used to pass file descriptors referring to any type of file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#arguments","title":"Arguments","text":"<ul> <li><code>domain</code>:<code>int</code>[K] - the communications domain in which the sockets are to be created; currently supported domains are AF_UNIX, AF_INET, AF_INET6.</li> <li><code>type</code>:<code>int</code>[K] - specifies the type of sockets created to be either SOCK_STREAM or SOCK_DGRAM.</li> <li><code>protocol</code>:<code>int</code>[K] - specifies a particular protocol to be used with the sockets. Normally only a single protocol exists to support a particular socket type within a given domain.</li> <li><code>sv</code>:<code>int[2]</code>[K] - used to return two file descriptors referring to the newly created sockets.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketpair/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketpair/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#socketpair_1","title":"socketpair","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#purpose","title":"Purpose","text":"<p>Hooks the socketpair syscall in order to monitor its use in applications.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#example-use-case","title":"Example Use Case","text":"<p>socketpair() is commonly used to create communication between two processes. It can be used by shell commands such as pipe, which use socketpair to create a pipe between two processes, or by applications that need to pass a file descriptor over a unix domain socket.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#related-events","title":"Related Events","text":"<ul> <li>connect </li> <li>socket </li> <li>accept</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/splice/","title":"splice","text":""},{"location":"docs/events/builtin/syscalls/splice/#intro","title":"Intro","text":"<p>splice - combines two file descriptors into a single file</p>"},{"location":"docs/events/builtin/syscalls/splice/#description","title":"Description","text":"<p>The splice() system call first appeared in Linux 2.6.17; it moves data between two file descriptors without copying between kernel address space and user address space. It can relate any two file objects that support the splice file operation.  </p> <p>It is an ideal operation if an application needs to move data directly from one file descriptor to another, for example to write data directly to disk or to read data directly from disk within a single process.</p>"},{"location":"docs/events/builtin/syscalls/splice/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[K] - an input file descriptor from which data is read.  </li> <li><code>off_in</code>:<code>off_t*</code>[K] - a pointer to an offset into <code>fd_in</code>.  </li> <li><code>fd_out</code>:<code>int</code>[K] - an output file descriptor to which data is written.  </li> <li><code>off_out</code>:<code>off_t*</code>[K] - a pointer to an offset into <code>fd_out</code>.  </li> <li><code>len</code>:<code>size_t</code>[K] - the number of bytes to copy between file descriptors.  </li> <li><code>flags</code>:<code>unsigned int</code>[K] - one or more of the SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, and/or SPLICE_F_GIFT options can be specified in flags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/splice/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/splice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/splice/#vfs_splice_to_pipe","title":"<code>vfs_splice_to_pipe</code>","text":""},{"location":"docs/events/builtin/syscalls/splice/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/splice/#purpose","title":"Purpose","text":"<p>Detect when a splice is executed, regardless of parameters.</p>"},{"location":"docs/events/builtin/syscalls/splice/#example-use-case","title":"Example Use Case","text":"<p>An application that writes data directly to a file from another file in the same process can use the splice() system call.</p>"},{"location":"docs/events/builtin/syscalls/splice/#issues","title":"Issues","text":"<p>On Linux systems with SELinux, the splice() system call can fail due to SELinux policies restricting access to certain resources, such as network sockets.</p>"},{"location":"docs/events/builtin/syscalls/splice/#related-events","title":"Related Events","text":"<ul> <li><code>writev</code></li> <li><code>readv</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/","title":"ssetmask","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#intro","title":"Intro","text":"<p>ssetmask - Change calling thread signal mask</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#description","title":"Description","text":"<p>The ssetmask function sets the signal mask of the calling thread to the argument newmask, and returns the previous signal mask of the thread. The calls have no effect on signals that are ignored. The ssetmask() function is equivalent to sigprocmask(2).</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#arguments","title":"Arguments","text":"<ul> <li><code>newmask</code>:<code>long</code>[K] - The signal mask to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ssetmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ssetmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#ssetmask_1","title":"ssetmask","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#purpose","title":"Purpose","text":"<p>To detect when threads change their signal masks.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#example-use-case","title":"Example Use Case","text":"<p>ssetmask() can be used to detect if a thread is attempting to block certain signals. This is useful to detect certain malicious activities, as it can indicate the presence of signal handlers.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#related-events","title":"Related Events","text":"<ul> <li>signal(2) - Send signal.</li> <li>sigaction(2) - Change signal action.</li> <li>sigprocmask(2) - Examine and change blocked signals.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stat/","title":"stat","text":""},{"location":"docs/events/builtin/syscalls/stat/#intro","title":"Intro","text":"<p>stat - Obtains information about a file, given its pathname</p>"},{"location":"docs/events/builtin/syscalls/stat/#description","title":"Description","text":"<p>The <code>stat</code> syscall is used to obtain information about a file or directory,  given its pathname. The information is retrieved in the form of a <code>struct stat</code>  object, which contains information such as the file's size, last access and modification times, and owner. It is also used to detect if a file exists,  or why it does not exist, so that proper exception handling can be done.</p> <p>There is a potential Time of Check, Time of Use (TOCTOU) race condition when using <code>stat</code> to check the existence of a file. If used in the wrong context, it can lead to errors.</p>"},{"location":"docs/events/builtin/syscalls/stat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U] - Pathname of the file or directory being examined.   </li> <li><code>statbuf</code>:<code>struct stat*</code>[K] - Pointer to the location of the <code>stat</code> struct in memory, where all the results of the function call will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stat/#do_sys_stat","title":"do_sys_stat","text":""},{"location":"docs/events/builtin/syscalls/stat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/stat/#purpose","title":"Purpose","text":"<p>To detect stat syscalls and collect information about them.</p>"},{"location":"docs/events/builtin/syscalls/stat/#example-use-case","title":"Example Use Case","text":"<p>A user-space program might use <code>stat</code> to check the existence of a file, and then take some action based on the result.</p>"},{"location":"docs/events/builtin/syscalls/stat/#issues","title":"Issues","text":"<p>There is a potential TOCTOU race condition when using <code>stat</code> to check the existence of a file. </p>"},{"location":"docs/events/builtin/syscalls/stat/#related-events","title":"Related Events","text":"<ul> <li><code>lstat</code> - A related syscall which facilitates the acquisition of information about a file on a filesystem. It does not follow symbolic links.  </li> <li><code>fstat</code> - A related syscall which regards an already opened file for information instead of a pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stat64/","title":"stat64","text":""},{"location":"docs/events/builtin/syscalls/stat64/#intro","title":"Intro","text":"<p>stat64 - Get the status information of a file</p>"},{"location":"docs/events/builtin/syscalls/stat64/#description","title":"Description","text":"<p>The <code>stat64()</code> system call gets the status information of the file pointed to by <code>pathname</code>, and returns it in the <code>statbuf</code> structure, which includes information like file type, size, inode, etc. The <code>statbuf</code> structure needs to be allocated by the caller, as it will be filled in by the kernel. </p> <p>The <code>stat64()</code> system call is vulnerable to Time-of-Check Time-of-Use (TOCTOU) race conditions, as the <code>statbuf</code> argument contains the pointer to the status information of the file; if the file is changed between the checks, the information that is returned by <code>stat64()</code> could be wrong.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U] - Path to the file to be stat'ed</li> <li><code>statbuf</code>:<code>struct stat64*</code>[U] - Pointer to <code>struct stat64</code> in user-space, that will be filled in by the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stat64/#sys_stat64","title":"sys_stat64","text":""},{"location":"docs/events/builtin/syscalls/stat64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/stat64/#purpose","title":"Purpose","text":"<p>Observe where the <code>stat64()</code> system call is used in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#example-use-case","title":"Example Use Case","text":"<p>The <code>stat64()</code> system call can be used to get the status information of a file before executing it to check for permission, etc.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#issues","title":"Issues","text":"<p>The <code>stat64()</code> system call is vulnerable to TOCTOU race conditions, where the <code>statbuf</code> argument contains the pointer to the status information of the file; if the file is changed between the checks, the information that is returned by <code>stat64()</code> could be wrong.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#related-events","title":"Related Events","text":"<ul> <li>open64: Related as it is needed before executing a file to open it and get its information.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statfs/","title":"statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs/#intro","title":"Intro","text":"<p>statfs - copies information relating to mounted filesystems</p>"},{"location":"docs/events/builtin/syscalls/statfs/#description","title":"Description","text":"<p>The <code>statfs</code> system call obtains details of the mounted file system specified by the path. The information is stored in the struct <code>statfs</code>, which is returned to the user at <code>buf</code>. The <code>statfs</code> system call is commonly used for finding out the total size of the file system, the number of available blocks or the number of free blocks.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - path of the mounted file system</li> <li><code>buf</code>:<code>struct statfs*</code>[U] - pointer to a buffer where the statfs data will be stored</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statfs/#sys_statfs","title":"sys_statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/statfs/#purpose","title":"Purpose","text":"<p>To keep track of when and how often the <code>statfs</code> system call is used.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#example-use-case","title":"Example Use Case","text":"<p>The <code>statfs</code> system call could be used to gather file system statistics, such as the size and number of free blocks, for monitoring the health of the system.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#related-events","title":"Related Events","text":"<ul> <li>mount (from which relevant statfs information can be obtained)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/","title":"statfs64","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#intro","title":"Intro","text":"<p>statfs64 - obtain information about a mounted file system.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#description","title":"Description","text":"<p>The statfs64 system call obtains information about a mounted file system on the Linux operating system. It copies the file system parameters from the super block structure in the kernel memory to the user land structure <code>struct statfs64</code> provided in the <code>buf</code> argument. </p> <p>The <code>size_t</code> argument <code>sz</code> specifies the size of the provided <code>buf</code> structure, so that the kernel can decide which version of the struct will be used. No data will be copied in case the provided <code>sz</code> size doesn't match the size of the corresponding struct in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - path of the file system that should be queried.</li> <li><code>sz</code>:<code>size_t</code>[U] - this argument specifies the size of the <code>buf</code> argument, allowing the kernel to determine which version of the <code>struct statfs64</code> will be used.</li> <li><code>buf</code>:<code>struct statfs64*</code>[U] - pointer to a user-space buffer, where the information collected from the kernel will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#do_statfs","title":"do_statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#type","title":"Type","text":"<p>Kprobes + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#purpose","title":"Purpose","text":"<p>Monitors This syscall, to collect information about the mounted file systems.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#example-use-case","title":"Example Use Case","text":"<p>It can be used to collect information on mounted file systems, such as available disk space, block size and total number of blocks.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#issues","title":"Issues","text":"<p>The <code>size_t</code> parameter <code>sz</code> can cause issues if the user-space buffer size is not large enough for the corresponding struct size in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#related-events","title":"Related Events","text":"<ul> <li>mount()</li> <li>umount2()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statx/","title":"statx","text":""},{"location":"docs/events/builtin/syscalls/statx/#intro","title":"Intro","text":"<p>The <code>statx</code> syscall is used to get information about a filesystem object. It's similar to the <code>stat</code> syscall, but supports a more fine-grained mask argument which controls which fields are returned.</p>"},{"location":"docs/events/builtin/syscalls/statx/#description","title":"Description","text":"<p><code>statx</code> allows to get information about various filesystem objects (like regular files, directories, links). Its main advantage over the <code>stat</code> syscall is the ability to specify a mask argument which controls which fields are returned in the <code>struct statx</code> pointer argument. This reduces the amount of system calls to retrieve multiple bits of information about a filesystem object, and makes the call more efficient.</p> <p>In addition, <code>statx</code> supports some flags which modify the operation, like AT_NO_AUTOMOUNT which tell the system not to mount a filesystem automatically when necessary.</p> <p>The <code>statx</code> syscall is part of the new libpfc library which simplifies common filesystem operation.</p>"},{"location":"docs/events/builtin/syscalls/statx/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code> - File descriptor for a directory from which the relative path is evaluated, or <code>AT_FDCWD</code> for the current working directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - Null-terminated pathname relative to the <code>dirfd</code> argument.</li> <li><code>flags</code>:<code>int</code>[K] - Flags which modify the operation. See the <code>statx</code> manual page for the available set of flags.</li> <li><code>mask</code>:<code>unsigned int</code>[K] - Bitmask field which defines what fields of the <code>struct statx</code> pointer argument to populate. </li> <li><code>statxbuf</code>:<code>struct statx*</code>[U] - Pointer to a <code>struct statx</code> which will be populated with the information from the filesystem object, according to the <code>mask</code> argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/statx/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statx/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statx/#do_sys_stat","title":"do_sys_stat","text":""},{"location":"docs/events/builtin/syscalls/statx/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/statx/#purpose","title":"Purpose","text":"<p>To observe calls to the <code>statx</code> syscall, and get information about the arguments being passed.</p>"},{"location":"docs/events/builtin/syscalls/statx/#example-use-case","title":"Example Use Case","text":"<p>You can use <code>statx</code> to get information about a file in order to determine if it should be included in a tarball, like when making a backup or when creating an archive. By specifying the appropriate bitmask for the <code>mask</code> argument, you can retrieve only the necessary information. </p>"},{"location":"docs/events/builtin/syscalls/statx/#issues","title":"Issues","text":"<p>The kernel does not support the <code>FOLLOW</code> flag, which enables the syscall to follow symbolic links. This limits the usefulness of the syscall when dealing with links.</p>"},{"location":"docs/events/builtin/syscalls/statx/#related-events","title":"Related Events","text":"<ul> <li><code>stat</code> - Syscall to get information about a filesystem object, which does not support a bitmask argument. </li> <li><code>fstatat</code> - Syscall to get information about a filesystem object given a file descriptor and a relative path. </li> <li><code>openat</code> - Syscall to open a file given a file descriptor and a relative path.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stime/","title":"stime","text":""},{"location":"docs/events/builtin/syscalls/stime/#intro","title":"Intro","text":"<p>stime - set the system's date and time</p>"},{"location":"docs/events/builtin/syscalls/stime/#description","title":"Description","text":"<p>The stime system call sets the system's idea of the current calendar time and time of day. The time argument is the time in seconds since the epoch, and time should always be non-negative. The time argument is interpreted as UTC by the kernel. The syscall does not check whether any arguments are out of range, leading to a potential TOCTOU (time of check, time of use) vulnerability.</p>"},{"location":"docs/events/builtin/syscalls/stime/#arguments","title":"Arguments","text":"<ul> <li><code>t</code>:<code>const time_t*</code>[K] - timestamp of current time in seconds since the Epoch.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stime/#sys_stime","title":"sys_stime","text":""},{"location":"docs/events/builtin/syscalls/stime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/stime/#purpose","title":"Purpose","text":"<p>To log the invocation of the <code>stime()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/stime/#example-use-case","title":"Example Use Case","text":"<p>The <code>stime</code> system call can be used to manually adjust the system time. One example use case can be to periodically invoke this system call to keep the system time in sync with an NTP server.</p>"},{"location":"docs/events/builtin/syscalls/stime/#issues","title":"Issues","text":"<p>Due to the lack of input sanitation, this system call has been found vulnerable to TOCTOU (Time of Check / Time of Use) vulnerability in certain cases.</p>"},{"location":"docs/events/builtin/syscalls/stime/#related-events","title":"Related Events","text":"<ul> <li><code>nanosleep</code> - to suspend execution of the current thread.</li> <li><code>clock_settime</code> - to change the current time of a clock relative to an epoch</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stty/","title":"stty","text":""},{"location":"docs/events/builtin/syscalls/stty/#intro","title":"Intro","text":"<p>stty - sets the parameters associated with the terminal.</p>"},{"location":"docs/events/builtin/syscalls/stty/#description","title":"Description","text":"<p>The stty utility sets or reports terminal characteristics (POSIX termios style) for open terminals in the pseudo-terminal family. The terminal characteristics determine how input and output behave on the input and output streams of the terminal. All subsequent reads and writes on the terminal use these characteristics until the characteristics are re-set with stty.</p> <p>The POSIX terminal interface is derived from the Unix system and provides more comprehensive control of the terminal than the more traditional interface derived from System V and supplied as the ioctl function.</p>"},{"location":"docs/events/builtin/syscalls/stty/#arguments","title":"Arguments","text":"<ul> <li><code>command_string</code>:<code>string</code>[K] - A stty command string made of words, separators, and quote marks that contains one or more stty commands to be performed on the terminal output or input.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stty/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stty/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stty/#syscall","title":"Syscall","text":""},{"location":"docs/events/builtin/syscalls/stty/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/stty/#purpose","title":"Purpose","text":"<p>To detect calls to the stty syscall.</p>"},{"location":"docs/events/builtin/syscalls/stty/#example-use-case","title":"Example Use Case","text":"<p>stty can be used to change the baud rate and other aspects of the serial port operation, thus it is a common event used in debugging serial port issues.</p>"},{"location":"docs/events/builtin/syscalls/stty/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/stty/#related-events","title":"Related Events","text":"<ul> <li>tcgets</li> <li>tcsetattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/","title":"swapoff","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#intro","title":"Intro","text":"<p>swapoff - unregister a path from the list of used swap devices</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#description","title":"Description","text":"<p>The <code>swapoff()</code> function unregisters the path pointed to by the <code>path</code> parameter from the list of used swap devices. This call can be used to deactivate swap devices without reboot. Since the Linux kernel version 4.14, swap devices can also be limited to a specific range of physical memory pages. This allows creating swap devices out of unused physical memory. </p>"},{"location":"docs/events/builtin/syscalls/swapoff/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - path to the swap device.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/swapoff/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapoff/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#sys_swapoff","title":"sys_swapoff","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#purpose","title":"Purpose","text":"<p>Used to unregister the path pointed to by the path parameter from the list of used swap devices.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#example-use-case","title":"Example Use Case","text":"<p>When we want to unregister a swap device without rebooting the system.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#issues","title":"Issues","text":"<p>On some systems, swapoff() fails with an \"Operation not permitted\" error if called from a non-root process.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#related-events","title":"Related Events","text":"<p>The <code>swapon()</code> syscall can be used in combination with <code>swapoff()</code> to activate and deactivate swap devices.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/swapon/","title":"swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#intro","title":"Intro","text":"<p>swapon - allow a process to start using a designated swap area</p>"},{"location":"docs/events/builtin/syscalls/swapon/#description","title":"Description","text":"<p>The swapon() system call allows a process to start using a designated swap area on a file or a device that is setup for paging and/or swapping. Both regular files and block special files can be used for this purpose.</p> <p>When path is NULL, the kernel will use the first entry in the /etc/fstab as the default swap area. If the swap flag is passed as NULL, the kernel will default to 0. swapon() provides an easy way to enable swap on a single partition at a time.</p> <p>Some of the advantages of using swapon() are that the swap area can be easily re-enabled on reboot, the memory use can be easily monitored with the free command, and it can be used on freshly installed systems. However, one of the drawbacks is that the system will still be left with active memory pages until they are paged out. This could lead to excessive paging activity during bootup, leading to degraded system performance.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - Path to a block special device or a regular file that will be used for swapping. If set to NULL, then the first entry in the /etc/fstab will be used.</li> <li><code>swapflags</code>:<code>int</code>[K] - Flags which indicate what type of swap to use. The allowed flags are: </li> <li>SWAP_FLAG_PREFER - Only use the specified swap file if it's better than the existing one.</li> <li>SWAP_FLAG_DISCARD - Discard pages from the swap file as soon as they are used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapon/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapon/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/swapon/#do_swapon","title":"do_swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapon/#purpose","title":"Purpose","text":"<p>Hooking do_swapon allows tracing when the system starts using a designated swap area on a file or a device.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#sys_swapon","title":"sys_swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapon/#purpose_1","title":"Purpose","text":"<p>Hooking sys_swapon provides a way to monitor when a user process attempts to start using a designated swap area.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#example-use-case","title":"Example Use Case","text":"<p>Swapon may be used when a user needs to add a new swap area to an existing system. If the file or block special device is set up correctly, the user can call swapon to enable the swap area.  </p>"},{"location":"docs/events/builtin/syscalls/swapon/#issues","title":"Issues","text":"<p>Due to the way the kernel manages swap, it is possible that this system call may return an error (EINVAL) if the swap area specified is already in use.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#related-events","title":"Related Events","text":"<p>The swapon() system call is related to the swaponall() system call, which is used to enable all swap areas specified in the /etc/fstab. It is also related to the swapoff() system call, which is used to disable a swap area.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/symlink/","title":"symlink","text":""},{"location":"docs/events/builtin/syscalls/symlink/#intro","title":"Intro","text":"<p>symlink - creates a symbolic link to a file in the file system.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#description","title":"Description","text":"<p>The <code>symlink</code> event creates a symbolic link at the given path to the target file. This link is similar to a regular file, but it points to the actual file rather than containing a copy of the contents. This is useful for creating multiple references to the same file without taking up more space. The main drawback is that if the target file is changed, so are all the links pointing to it.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[K] - The path to the file that will be pointed to.</li> <li><code>linkpath</code>:<code>const char*</code>[K] - The path of the symbolic link that will be created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/symlink/#sys_symlink","title":"sys_symlink","text":""},{"location":"docs/events/builtin/syscalls/symlink/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/symlink/#purpose","title":"Purpose","text":"<p>Hooked to trace the execution of the <code>sys_symlink</code> kernel function, which is the entrypoint for the <code>symlink</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#example-use-case","title":"Example Use Case","text":"<p>A use case for the <code>symlink</code> event could be analyzing the behavior of different system processes when creating symbolic links. This could help identify potential malicious actors and vulnerabilities in the system, or analyze how processes interact with files and other processes.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#issues","title":"Issues","text":"<p>The main issue with the <code>symlink</code> event is that it is vulnerable to TOCTOU (time of check, time of use) attacks. This means that the target file could be changed before the <code>symlink</code> syscall is triggered, leading to a change of the reference for the symbolic link. </p>"},{"location":"docs/events/builtin/syscalls/symlink/#related-events","title":"Related Events","text":"<ul> <li><code>unlink</code> - deletes the file referenced by a given path.</li> <li><code>link</code> - creates a hard link to a file in the file system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/","title":"symlinkat","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#intro","title":"Intro","text":"<p>symlinkat - Creates a symbolic link named by linkpath to an object referenced by target. </p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#description","title":"Description","text":"<p>Symlinkat creates a symbolic link with the name specified in <code>linkpath</code> to the object referenced by <code>target</code>. It differs from <code>symlink</code> in that <code>linkpath</code> is relative to the directory file descriptor provided in <code>newdirfd</code>.</p> <p>Normally, symbolic links can only point to other files located in the same filesystem. However, when the <code>target</code> argument is prefixed with <code>/proc/self/fd/</code>, it can reference a file descriptor opened by the same process.</p> <p>There are a few possible edge-cases when using <code>symlinkat</code>. If <code>linkpath</code> already exists, the existing link will be overwritten, and if the directory referenced by <code>newdirfd</code> is not writable, a <code>EACCES</code> error will be returned.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[U] - The target to which the symbolic link points.</li> <li><code>newdirfd</code>:<code>int</code>[U] - The file descriptor for the target directory.</li> <li><code>linkpath</code>:<code>const char*</code>[U] - The name of the link to be created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#sys_symlinkat","title":"sys_symlinkat","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#purpose","title":"Purpose","text":"<p>Trace calls to symlinkat, including the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#example-use-case","title":"Example Use Case","text":"<p>Tracing the origin of symbolic links created in the system. This can be used to monitor privilege escalations and other malicious actions.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#issues","title":"Issues","text":"<p>The <code>target</code> argument can reference parts of the filesystem. This means that if <code>target</code> contains a relative path, its interpretation will depend on the current working directory of the process.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#related-events","title":"Related Events","text":"<p>The <code>lstat</code> event can be used to check if a file is a symbolic link, and if so, which file or directory it points to.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sync/","title":"sync","text":""},{"location":"docs/events/builtin/syscalls/sync/#intro","title":"Intro","text":"<p>sync - waits until all disk write operations have been completed</p>"},{"location":"docs/events/builtin/syscalls/sync/#description","title":"Description","text":"<p>The sync command causes all in-memory modified blocks to be written to disk. This is useful in order to ensure the full integrality and consistency of the data in the case of a system crash or power failure. However, it is not a full backup solution and it should be used in combination with other data safety measures. Moreover, regular synchronization of the disks is suggested in order to minimize the impact of unclean shutdown.</p>"},{"location":"docs/events/builtin/syscalls/sync/#arguments","title":"Arguments","text":"<ul> <li><code>None</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/sync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sync/#sync_file_range","title":"sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sync/#purpose","title":"Purpose","text":"<p>Detecting when a process is syncing files to create a superblock barrier.</p>"},{"location":"docs/events/builtin/syscalls/sync/#sys_sync","title":"sys_sync","text":""},{"location":"docs/events/builtin/syscalls/sync/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sync/#purpose_1","title":"Purpose","text":"<p>Detecting calls to the sys_sync function in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/sync/#example-use-case","title":"Example Use Case","text":"<p>For example, the sync command can be used to make sure that the in-memory modified blocks are written to disk before rebooting the system.</p>"},{"location":"docs/events/builtin/syscalls/sync/#issues","title":"Issues","text":"<p>Depending on the file system used, the sync command doesn't guarantee that the data is flushed completely. </p>"},{"location":"docs/events/builtin/syscalls/sync/#related-events","title":"Related Events","text":"<p>fsync - sync data and associated metadata for specified file</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/","title":"sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#intro","title":"Intro","text":"<p>sync_file_range - synchronizes a file range with the underlying hardware</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#description","title":"Description","text":"<p>The <code>sync_file_range</code> system call causes all modified data and metadata  stored in a file range of the provided file descriptor to be transferred  to the underlying hardware associated with the file descriptor. This  system call is capable of both flushing and fsyncing the given file range.  It allows for more precise control over which blocks of a file are flushed to the underlying hardware, allowing certain operations to be  asynchronous, without incurring the overhead of the <code>fdatasync</code> or  <code>fsync</code> system calls. It also allows operations to bypass the page cache  and touch a range of blocks directly.</p> <p>There are some drawbacks to taking advantage of this syscall, one of  which is the potential race conditions due to TOCTOU (time of check,  time of use). It is important for the caller to be aware of the  possibility of race conditions, and to properly use the <code>O_SYNC</code> flag  or the <code>SYNC_FILE_RANGE_WRITE</code> flag if they wish to mitigate race  conditions.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[U] - File descriptor of the file to synchronize.</li> <li><code>offset</code>:<code>off_t</code>[U] - Offset within the file to the start of the region to sync.</li> <li><code>nbytes</code>:<code>off_t</code>[U] - Number of bytes in the range to sync.</li> <li><code>flags</code>:<code>unsigned int</code>[U] - Bitmask indicating what action should be taken for the range.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user-space (for example, pointer to user-space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#vfs_sync_file_range","title":"vfs_sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#purpose","title":"Purpose","text":"<p>Hooks the <code>vfs_sync_file_range</code> function, which is the kernel entry point for the <code>sync_file_range</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#example-use-case","title":"Example Use Case","text":"<p><code>sync_file_range</code> can be used to synchronize certain parts of files without fsyncing the entire file. An example would be a database that updates small parts of a database file in a single operation. The database might use <code>sync_file_range</code> to synchronize the relevant blocks, rather than fsyncing the entire database file.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#issues","title":"Issues","text":"<p>Some filesystems may not support all options of the <code>flags</code> parameter, while others may support additional flags. This can lead to unexpected behaviour, and should be carefully considered by the caller. Additionally, <code>sync_file_range</code> is vulnerable to TOCTOU and race conditions, so be careful when using it.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#related-events","title":"Related Events","text":"<p>The <code>fdatasync</code> system call is similar to <code>sync_file_range</code>, in that it flushes modified data and metadata to the underlying hardware. However, <code>fdatasync</code> flushes the entire file, while <code>sync_file_range</code> only flushes a portion of the file. Additionally, <code>fsync</code> can be used to synchronize both the metadata and data of a file, while <code>sync_file_range</code> only synchronizes the data.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/","title":"syncfs","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#intro","title":"Intro","text":"<p>syncfs - synchronize all file system data on the device associated with a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#description","title":"Description","text":"<p>The syncfs() system call synchronizes all data associated with the device opened via the file descriptor fd. It calls the file system's sync() operation, which transfers all cached data to permanent storage, and then the fsync() call. This is typically used to ensure that everything written to a file by the application is really on permanent storage.</p> <p>syncfs() is similar to sync(), but applies only to the filesystem associated with the file descriptor fd.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor pointing to a filesystem device.</li> </ul>"},{"location":"docs/events/builtin/syscalls/syncfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/syncfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#syncfs_1","title":"syncfs","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#purpose","title":"Purpose","text":"<p>Used to synchronize all data associated with a filesystem device.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#example-use-case","title":"Example Use Case","text":"<p>Let's say you wanted to take a backup of a file system in a file descriptor. The syncfs() system call is the one to do this, as it transfers all cached data to permanent storage.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#related-events","title":"Related Events","text":"<ul> <li>sync - synchronize all file system data </li> <li>fsync - synchronize files or directories</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/","title":"sysctl","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#intro","title":"Intro","text":"<p>sysctl - enables privileged processes to examine and modify the kernel parameters.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#description","title":"Description","text":"<p>The sysctl() system call is used by privileged processes to examine and modify kernel parameters. It is primarily used by system daemons, such as syslogd(8) and sshd(8), as well as by programs such as top(1) and ps(1). </p> <p>The first argument of sysctl() is a structure of type __sysctl_args, which consists of a list of integers that identify a particular kernel variable, and a string (or more accurately, an array of binary bytes) that is used to set the value for that variable. All kernel variables accessible via sysctl() can be prefixed using a period delimited sequence of integers. </p> <p>The kernel variables are divided in to two classes; read only and read/write. Making sysctl() calls to read/write variables requires the caller to either possess the CAP_SYS_ADMIN capability or be running as root. Making sysctl() calls to read only variables requires the caller to either possess the CAP_SYS_RAWIO capability or be running as root. </p>"},{"location":"docs/events/builtin/syscalls/sysctl/#arguments","title":"Arguments","text":"<ul> <li><code>args</code>:<code>struct __sysctl_args*</code>[K] - pointer to a structure of type __sysctl_args which contains the kernel variable information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#sysctl_1","title":"sysctl","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#purpose","title":"Purpose","text":"<p>To hook the syscall to call a certain function (with certain args) on every call, with both entry and exit full stack.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#example-use-case","title":"Example Use Case","text":"<p>An example use case for sysctl would be to monitor changes to kernel settings. For example, an application might be developed to increase the security of the system by monitoring system settings and alerting administrators if settings are changed outside of the expected range.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#issues","title":"Issues","text":"<p>One of the issues with using sysctl is that it is vulnerable to time-of-check-time-of-use (TOCTOU) attacks. If a malicious user is able to cause a race condition between the check and set operations on a sysctl variable, they may be able to modify a system setting without authorization. </p>"},{"location":"docs/events/builtin/syscalls/sysctl/#related-events","title":"Related Events","text":"<ul> <li>getrlimit</li> <li>setrlimit</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/","title":"sysfs","text":""},{"location":"docs/events/builtin/syscalls/sysfs/#intro","title":"Intro","text":"<p>sysfs - a system call for managing and querying the Linux kernel's sysfs file system.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#description","title":"Description","text":"<p>sysfs is a filesystem used by the Linux kernel to export information about devices and driver configuration options. It is used by user space applications to read and write configuration and device-specific data. sysfs is read-only from user space and is used to query the kernel for system parameters such as CPU and memory size. It also provides access to shared kernel trace information and can be used to access procfs.</p> <p>The sysfs system call allows user space processes to read and write sysfs entries. It takes an option as an argument which specifies the action to be performed. The optional argument is of type <code>int</code> and is read-only.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - specifies the action to be performed by the sysfs system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysfs/#hooks","title":"Hooks","text":"<p>The <code>sysfs</code> system call is not hooked. </p>"},{"location":"docs/events/builtin/syscalls/sysfs/#example-use-case","title":"Example Use Case","text":"<p>The sysfs system call is typically used to query kernel parameters and device-specific data. This allows user-space programs to get information about the devices and drivers supported by the kernel without having to know any kernel-specific details.</p> <p>For instance, if a program needs to determine the size of the physical memory installed in a system, it can call sysfs with the <code>option</code> set to <code>MEM_SIZE</code> and the kernel will return the size of the memory in bytes.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#related-events","title":"Related Events","text":"<ul> <li><code>procfs</code> - system call for managing and querying the Linux kernel's procfs filesystem.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/","title":"sysinfo","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#intro","title":"Intro","text":"<p>sysinfo - reads various system information</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#description","title":"Description","text":"<p>The sysinfo() system call is used to retrieve various system information related to the system's current status. It returns, among other metrics, the amount of time in idle, system, user and iowait, as well as the number of running and total processes, and the total amount of free and available memory.</p> <p>This system call provides a highly efficient and convenient way to quickly access many system metrics, making it useful for the monitoring of system performance. However, it is subject to TOCTOU (time of check, time of use) vulnerabilities, so it is important to take appropriate precaution when using it.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#arguments","title":"Arguments","text":"<ul> <li><code>info</code>:<code>struct sysinfo*</code>[K] - A pointer to a struct sysinfo, which receives all the data accumulated by sysinfo.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#sys_newstat","title":"sys_newstat","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#type","title":"Type","text":"<p>kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#purpose","title":"Purpose","text":"<p>To measure the amount of time the system is in idle, user and system mode, as well as the amount of free and available system memory.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use this system call to measure and monitor the performance of their system in real-time.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#issues","title":"Issues","text":"<p>sysinfo() is subject to TOCTOU (time of check, time of use) vulnerabilities, so it is important to take appropriate precaution when using it.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#related-events","title":"Related Events","text":"<ul> <li>sys_exit - when this event is triggered, sysinfo can be used to provide a more accurate picture of the system's current performance.</li> <li>sys_fork - this event allows the user to measure the number of active processes in the system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/syslog/","title":"syslog","text":""},{"location":"docs/events/builtin/syscalls/syslog/#intro","title":"Intro","text":"<p>syslog - writes to system log.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#description","title":"Description","text":"<p>The syslog() function allows the calling process to make a system logging request. It passes the message pointed to by bufp, of length len, to the appropriate logging utility. type is a priority value as described in syslog(3). </p> <p>Syslog is a convenient API to report system events. It is used in kernel and user space. However, no authentication or encryption is used and any user can access syslog, so it is insecure for sensitive and critical information.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>int</code> - Type of message to log. </li> <li><code>bufp</code>:<code>char*</code>[U] - Pointer to the message to be written to syslog.</li> <li><code>len</code>:<code>int</code> - Length of message.</li> </ul>"},{"location":"docs/events/builtin/syscalls/syslog/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/syslog/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/syslog/#do_syslog","title":"do_syslog","text":""},{"location":"docs/events/builtin/syscalls/syslog/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#purpose","title":"Purpose","text":"<p>Monitors syscall execution and collects arguments given by the user.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#example-use-case","title":"Example Use Case","text":"<p>Syslog can be used to log errors and warnings in applications. For example, if an application experiences an error, it may log this error to syslog so that it can be monitored and tracked.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#issues","title":"Issues","text":"<p>User data can be easily accessed by any user since there is no authentication or encryption used, making it vulnerable to malicious users.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#related-events","title":"Related Events","text":"<ul> <li>syslog_imageinit - Linking an image in the kernel for log reporting. </li> <li>syslog_device - Linking a syslog device for log reporting.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tee/","title":"tee","text":""},{"location":"docs/events/builtin/syscalls/tee/#intro","title":"Intro","text":"<p>tee - duplicates data from one file descriptor to another</p>"},{"location":"docs/events/builtin/syscalls/tee/#description","title":"Description","text":"<p>The tee system call duplicates data from one file descriptor to another, useful for streaming data between different programs. Though the main operation is to copy a file descriptor to another, the flags argument allows different additional behavior in the write or read, like avoiding writes to blocking descriptors, or allocating new blocks for output. The len argument also allows control of the length of data to copy, instead of all data from input file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/tee/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[U] - file descriptor for input</li> <li><code>fd_out</code>:<code>int</code>[K,U] - file descriptor for output</li> <li><code>len</code>:<code>size_t</code>[U] - length of data to be copied</li> <li><code>flags</code>:<code>unsigned int</code>[U, opt] - flags specified additional behavior like avoid writes to blocking descriptors or allocating new blocks for output</li> </ul>"},{"location":"docs/events/builtin/syscalls/tee/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/tee/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tee/#sys_tee","title":"sys_tee","text":""},{"location":"docs/events/builtin/syscalls/tee/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/tee/#purpose","title":"Purpose","text":"<p>To capture data read and written to the kernel via tee.</p>"},{"location":"docs/events/builtin/syscalls/tee/#example-use-case","title":"Example Use Case","text":"<p>A network packet streaming application that needs to read from the network and write the same data to another program.</p>"},{"location":"docs/events/builtin/syscalls/tee/#issues","title":"Issues","text":"<p>On systems with non-uniform memory architecture, the write to user space may be unaligned and not fit on a page, leading to errors of EFAULT.</p>"},{"location":"docs/events/builtin/syscalls/tee/#related-events","title":"Related Events","text":"<ul> <li>write</li> <li>read</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/","title":"tgkill","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#intro","title":"Intro","text":"<p>tgkill - Sending a signal to a thread in another thread group.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#description","title":"Description","text":"<p>The tgkill syscall is used to send a signal to a thread in another thread group. It is the same as calling kill, but allows a thread to be targeted in another thread group, instead of needing to rely on a separate process. </p> <p>The tgkill syscall is useful for situations when thread-to-thread and thread-group-to-thread-group communications are needed, but when signaling would otherwise be too imprecise.</p> <p>The main disadvantage of tgkill is that it only works on two specific threads, not thread groups in general. This means it may be difficult to send a signal to all threads in another thread group.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>int</code> - The thread group identifier of the target process.</li> <li><code>tid</code>:<code>int</code> - The thread identifier of the target thread in the thread group.</li> <li><code>sig</code>:<code>int</code>[K] - The signal to be sent to the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tgkill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tgkill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#do_tgkill","title":"do_tgkill","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#purpose","title":"Purpose","text":"<p>Hooked to do_tgkill to monitor when tgkill is executed, and the arguments it is called with.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#example-use-case","title":"Example Use Case","text":"<p>tgkill can be useful in situations where two threads need to communicate, but are in different thread groups. For example, if one thread is in a daemon thread group and another is in a user process thread group, tgkill can be used to signal between the two.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#related-events","title":"Related Events","text":"<p>Signal events (such as kill) and thread management events (such as clone).</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/time/","title":"time","text":""},{"location":"docs/events/builtin/syscalls/time/#intro","title":"Intro","text":"<p>time - Get the current time in seconds since the Epoch</p>"},{"location":"docs/events/builtin/syscalls/time/#description","title":"Description","text":"<p>The <code>time</code> function is a system call which returns the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC ( known as the Epoch). The return value is stored in the timespec pointed to by the argument <code>tloc</code>, which must be non-null.</p> <p>The <code>time</code>function is often used for basic performance timing in programs, as the time value can easily be compared to other time values. It is also useful for seed generation for random number generators, since it provides a unique value which is difficult to predict.</p> <p>However, the time returned by <code>time</code> is not necessarily monotonic. It can vary due to a variety of factors, such as discrepancies in hardware clocks, manual updates to the date/time, and daylight saving time adjustments. Therefore, <code>time</code> is not suitable for applications which require consistent, monotonic timing.</p>"},{"location":"docs/events/builtin/syscalls/time/#arguments","title":"Arguments","text":"<ul> <li><code>tloc</code>:<code>time_t*</code>[K] - Pointer to timespec structure in which the time should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/time/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/time/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/time/#time_1","title":"time","text":""},{"location":"docs/events/builtin/syscalls/time/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/time/#purpose","title":"Purpose","text":"<p>The <code>time</code> function is used to get the current time since the Epoch. Hooking this function allows for monitoring of when the time is requested and may indicate a possible start of an attacker's activities.</p>"},{"location":"docs/events/builtin/syscalls/time/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor for suspicious timing in programs. For instance, if a program is consistently requesting the current time, this may indicate that the program is attempting to guess an unpredictable value, such as a seed for a random number generator.</p>"},{"location":"docs/events/builtin/syscalls/time/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/time/#related-events","title":"Related Events","text":"<ul> <li><code>gettimeofday</code> - Get the current time in milliseconds since the Epoch.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/","title":"timer_create","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#intro","title":"Intro","text":"<p>timer_create - creates a per-process timer </p>"},{"location":"docs/events/builtin/syscalls/timer_create/#description","title":"Description","text":"<p><code>timer_create()</code> is a system call used to create a per-process timer that sends a signal when it expires. It is a function that creates a timer with a specified clock (<code>CLOCK_REALTIME</code>, <code>CLOCK_MONOTONIC</code>, <code>CLOCK_PROCESS_CPUTIME_ID</code>, <code>CLOCK_THREAD_CPUTIME_ID</code>, <code>CLOCK_MONOTONIC_RAW</code>, <code>CLOCK_REALTIME_COARSE</code> and <code>CLOCK_MONOTONIC_COARSE</code>) and it accepts a <code>sigevent</code> structure that has information about the signal that will be sent when the timer is triggered. The timer ID is returned in the <code>timer_t</code> pointer that is one of the parameters of the syscall.</p> <p>The <code>timer_create()</code> syscall is useful for applications which need to be woken up at a particular time for a certain task. For example, a process can use <code>timer_create()</code> to cause a signal to be sent when a certain amount of time has passed.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code>[K] - identifier of the clock to be used (realtime, monotonic etc...)</li> <li><code>sevp</code>:<code>struct sigevent*</code>[KU] - pointer to sigevent structure which includes information about the signal that will be sent when the timer expires.</li> <li><code>timer_id</code>:<code>timer_t</code>[K] - pointer to the created timer\u00b4s ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#timer_create_1","title":"timer_create","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#purpose","title":"Purpose","text":"<p>Trigger events when timer_create is executed</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#example-use-case","title":"Example Use Case","text":"<p>For example, timer_create is used to set up asynchronous events to trigger a signal after a certain amount of time. This can be used in applications that need a certain action to be performed at a certain time, such as scheduling a task or sending an alert to the user after a certain amount of time.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#issues","title":"Issues","text":"<p>The main problem with timer_create is that it is susceptible to Time of Check to Time of Use (TOCTOU) attacks. This means that the timer can be triggered before the desired time, thus allowing malicious actors to do their deed before the timer has expired.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#related-events","title":"Related Events","text":"<ul> <li><code>timer_settime()</code> - used to arm the timer created with <code>timer_create()</code>.</li> <li><code>timer_delete()</code> - used to delete a timer created with <code>timer_create()</code>.</li> <li><code>timer_gettime()</code> - used to get the remaining time of a timer created with <code>timer_create()</code>.</li> <li><code>timer_getoverrun()</code> - used to get the number of missed occurrences of the timer created with <code>timer_create()</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/","title":"timer_delete","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#intro","title":"Intro","text":"<p>timer_delete - deletes previously created timer</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#description","title":"Description","text":"<p>timer_delete() deletes the specified timer, timer_id. The timer must have been  created by a previous call to timer_create(2) and must not have been already  deleted. The associated clock, allocated memory and timer overrun handlers are  all released. If a required underlying alarm request was issued to the real-time  clock, it is also canceled. After a successful timer_delete() call, the timer_t  value is invalid and should not be reused.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - ID of the timer to be deleted.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_delete/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_delete/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#timer_delete_1","title":"timer_delete","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#purpose","title":"Purpose","text":"<p>Investigate the performance of timer_delete system call.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#example-use-case","title":"Example Use Case","text":"<p>timer_delete can be used to delete a timer, which was created by a previous  call to timer_create(2), in order to prevent it from expiring.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#issues","title":"Issues","text":"<p>If a call to timer_delete() fails, the timer may be left in an undefined state,  which can cause the timer to be reused at a future point in time.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#related-events","title":"Related Events","text":"<p>timer_create(2) - creates a timer, which can later be deleted by timer_delete().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/","title":"timer_getoverrun","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#intro","title":"Intro","text":"<p>timer_getoverrun - returns an overrun count</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#description","title":"Description","text":"<p>The timer_getoverrun function returns the overrun count for a specified timer. The overrun count is equal to the number of times the expiration callback was invoked since the last time the timer expired.</p> <p>The timer_getoverrun function works by reading the timer's state and therefore the overrun count may be stale by the time it is returned. If the timer is in the process of expiring, the overrun count may not agree with the actual overrun count since the expiration callback started running.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>   : <code>timer_t</code> - identifier of the timer whose overrun count should be returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#sys_timer_getoverrun","title":"sys_timer_getoverrun","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#purpose","title":"Purpose","text":"<p>Used to log the timer identifier and the overrun count.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to track the behavior of a timer and its overrun count over time.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#related-events","title":"Related Events","text":"<ul> <li>timer_settime - used to set up the timer which will be tracked with timer_getoverrun.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/","title":"timer_gettime","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#intro","title":"Intro","text":"<p>timer_gettime - Get the current value of the timer specified by timerid.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#description","title":"Description","text":"<p>The timer_gettime() system call gets the current value of the timer specified by timerid. It stores the amount of time until the timer expires into the itimerspec pointed to by curr_value. Additional flags, like TIMER_ABSTIME may modify the behavior of this call by setting the reference from which the relative waiting time is calculated. If the timer is disarmed, the itimerspec is set to 0.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code> - ID of timer to query.</li> <li><code>curr_value</code>:<code>struct itimerspec*</code>K[TOCTOU] - Pointer to a preallocated itimerspec structure, to which the timer's current value will be written.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#sys_timer_gettime","title":"sys_timer_gettime","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#type","title":"Type","text":"<p>kprobe.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#purpose","title":"Purpose","text":"<p>To detect calls to timer_gettime() and to monitor the parameters passed to it.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to detect application calls to timer_gettime() and to gather additional data regarding the timer associated with this call. This data can be used for investigation or profiling purposes.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#issues","title":"Issues","text":"<p>No known issues at the moment.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#related-events","title":"Related Events","text":"<ul> <li>timer_create</li> <li>timer_settime</li> <li>timer_delete</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/","title":"timer_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#intro","title":"Intro","text":"<p>timer_gettime32 - Gets a timer expiration and interval for a 32-bit specific timer</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#description","title":"Description","text":"<p>The timer_gettime32() system call gets the expiration and interval for the timer specified by <code>timer_id</code>. If <code>setting</code> is not NULL, the structure pointed to by <code>setting</code> is used to return the expiration and interval of the timer. The structure used is the 32-bit version of <code>itimerspec</code>: <code>struct old_itimerspec32</code>.</p> <p>This system call is specific to 32-bit architectures, and should not be used on 64-bit architectures, where the <code>timer_gettime</code> system call should be used instead.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[KU] - The timer for which the expiration and interval should be retrieved.</li> <li><code>setting</code>:<code>struct old_itimerspec32*</code>[KU] - A pointer to a <code>struct old_itimerspec32</code> structure. The expiration and interval will be stored in this structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#timer_gettime32_1","title":"timer_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#purpose","title":"Purpose","text":"<p>The purpose of hooking this function is to gain visibility into the timer expiration and interval requested for a specific timer.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to observe what timers are being used in a system. This can be used in conjunction with other tracepoints and events to answer questions such as what timers are the longest running, or when something is timed out.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#issues","title":"Issues","text":"<p>This system call is specific to 32-bit Linux architectures and should not be used on 64-bit architectures.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#related-events","title":"Related Events","text":"<ul> <li><code>timer_settime32</code> - Used to set a timer expiration and interval for a 32-bit specific timer</li> <li><code>timer_create</code> - Creates a timer with a given expiration and interval</li> <li><code>timer_delete</code> - Deletes a timer</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/","title":"timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#intro","title":"Intro","text":"<p>timer_settime -  sets the timer referred to by timerid to the values specified in value</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#description","title":"Description","text":"<p>The timer_settime() function establishes the timer, timerid, to expire at the time specified by value. When the timer expires, the specific reasons for this expiration can be obtained by inspecting the value of the overrun argument. The timer can be one-shot or periodic. If a timer is re-established with timer_settime() while it is in a pending state, the time of the next expiration is reset.</p> <p>The flags argument is formed by ORing together one or more of the following flags: - TIMER_ABSTIME: use absolute value for setting timer. - TIMER_RELTIME: use relative value for setting timer.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - Identifier of the timer.</li> <li><code>flags</code>:<code>int</code>[K] - flags for setting timer.</li> <li><code>new_value</code>:<code>const struct itimerspec*</code>[K] - struct of new relative or absolute values for setting timer.</li> <li><code>old_value</code>:<code>struct itimerspec*</code>[K, TOCTOU] - struct of old values.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#sys_timer_settime","title":"sys_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#purpose","title":"Purpose","text":"<p>To monitor the arguments and parameters of the timer_settime syscall</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#__do_timer_settime","title":"__do_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#type_1","title":"Type","text":"<p>Jprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#purpose_1","title":"Purpose","text":"<p>To intercept completed syscalls and inspect the return value of the timer_settime syscall</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#example-use-case","title":"Example Use Case","text":"<p>timer_settime is typically used in applications to set a timer that will trigger a callback when it elapses. The callback can be used to execute periodic tasks or to perform timeouts.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#issues","title":"Issues","text":"<p>At the time of writing, timer_settime is vulnerable to a TOCTOU race condition. Since the argument <code>old_value</code> is passed as non-const, and the value of old_value might change between the time it is checked and the time it is used.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#related-events","title":"Related Events","text":"<ul> <li>timer_create</li> <li>timer_gettime</li> <li>timer_getoverrun</li> <li>timer_delete</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/","title":"timer_settime32","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#intro","title":"Intro","text":"<p>timer_settime32 - Sets the time of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#description","title":"Description","text":"<p>timer_settime32 is used to set the time of an interval timer, based on the <code>timer_id</code>, to a new value stored in the <code>new</code> argument. The timer will be reset to <code>new</code> after the timer expires. The <code>flags</code> argument can be passed to determine how the timer behaves when it expires. The previous timer value is stored in the <code>old</code> argument.</p> <p>Whenever the timer expires, the timer value is reset to <code>new</code> and the associated signal is sent to the process specified when the timer was set.</p> <p>One advantage of using this system call is that the interval timer is reset automatically each time it expires, which eliminates the cost of checking the timer value and resetting it each time.</p> <p>However, one disadvantage is that the timer does not halt when a signal is sent to the process, as the timer will still reset.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - Timer identifier</li> <li><code>flags</code>:<code>int</code>[K] - Flags to determine timer behavior</li> <li><code>new</code>:<code>struct old_itimerspec32*</code>[K, U] - Pointer to new timer value</li> <li><code>old</code>:<code>struct old_itimerspec32*</code>[K, U, TOCTOU, OPT] - Pointer to old timer value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#do_timer_settime","title":"do_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#purpose","title":"Purpose","text":"<p>Hooking this function can be used to gain information about the context in which a timer is being set.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#lock_timer_base","title":"lock_timer_base","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#purpose_1","title":"Purpose","text":"<p>Hooking this function can be used to gain information about the context in which a timer is being set or modified.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to track when a certain program takes longer than expected to execute, as well as track other events that may occur periodically.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#issues","title":"Issues","text":"<p>One issue with timer_settime32 is that the time may not be as accurate as desired, as the operating system may adjust times to conserve system resources.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#related-events","title":"Related Events","text":"<p>The related events to timer_settime32 are timer_gettime32, timer_delete and timer_create.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/","title":"timerfd_create","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#intro","title":"Intro","text":"<p>timerfd_create - creates a file descriptor for use with the timerfd routines.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#description","title":"Description","text":"<p>The timerfd_create() system call creates a new timer object and returns a file descriptor that refers to it. The clockid argument specifies the clock that is used to mark the progress of the timer. The flags argument specifies optional creation flags; currently only TFD_CLOEXEC is supported.</p> <p>Once created, the file descriptor can be used to wait for the expiration of the timer using read(), select(), or poll().</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>int</code> - specifies the clock that is used to mark the progress of the timer.</li> <li><code>flags</code>:<code>int</code>[OPT] - specifies optional creation flags; currently only TFD_CLOEXEC is supported.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#sys_timerfd_create","title":"sys_timerfd_create","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#purpose","title":"Purpose","text":"<p>To hook the kernel entry point for the timerfd_create system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#example-use-case","title":"Example Use Case","text":"<p>A process that needs to track time at the system level could use this event to create a file descriptor for a timer and use that to track time in the process.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#related-events","title":"Related Events","text":"<p>timerfd_settime, timerfd_gettime</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/","title":"timerfd_gettime","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#intro","title":"Intro","text":"<p>timerfd_gettime() - get the expiration(s) of a timer created with timerfd.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#description","title":"Description","text":"<p>The timerfd_gettime() system call retrieves the current value of a timer created by the timerfd_create() system call. It stores the expiration(s) in the given structure pointed to by the <code>curr_value</code> argument. The <code>fd</code> argument should be a file descriptor that refers to the timer.</p> <p>This event might be useful to retrieve the expiration values of a given timer in order to get insight into the state of the timer at any given time. One potential edge-case is that the given <code>fd</code> argument does not refer to a timer, in which case an error will be returned.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor crated by the timerfd_create() system call.</li> <li><code>curr_value</code>:<code>struct itimerspec*</code>[U] - pointer to the struct itimerspec which will hold the current and/or next expiration(s) of the timer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#timer_refresh","title":"timer_refresh()","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#type","title":"Type","text":"<p>Function probe.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#purpose","title":"Purpose","text":"<p>The timer_refresh() is hooked to check that the expiry times are up to date and to act accordingly, like set the next expiry time.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#timer_del","title":"timer_del()","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#type_1","title":"Type","text":"<p>Kretprobes - return probes.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#purpose_1","title":"Purpose","text":"<p>The timer_del() is hooked to detect when a timer has been deleted and to free the related data.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#example-use-case","title":"Example Use Case","text":"<p>The timerfd_gettime() system call can be used to retrieve the expiration values of a timer in order to, for example, display a progress indicator or monitor how close a timer is to expiring.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#issues","title":"Issues","text":"<p>Currently, no issues with this event have been identified.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#related-events","title":"Related Events","text":"<p>timerfd_create() - create a timer, timerfd_settime() - set expiration values for a timer, timerfd_gettime() - get the expiration(s) of a timer.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/","title":"timerfd_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#intro","title":"Intro","text":"<p>timerfd_gettime32 -  Return the current value of the timer referenced by the file descriptor ufd.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#description","title":"Description","text":"<p>The timerfd_gettime32() system call returns the current value of the timer referenced by the file descriptor ufd into the buffer pointed to by the otmr argument. It is intended to replace the use of the obsolete timer_gettime(2) system call.</p> <p>The timerfd_gettime32() system call supports both absolute (based on calendar time) and relative (based on process start time) timers and is unaffected by changes in the system time (see adjtime(2)).</p> <p>The buffer otmr argument used in timerfd_gettime32 is used to return an old-style itimerspec structure, that is:</p> <pre><code>struct old_itimerspec32 {\n  struct old_timespec32 it_interval;  /* Timer period */\n  struct old_timespec32 it_value;     /* Timer expiration */\n};\n</code></pre> <p>Advantages of using timerfd_gettime32() is that it provides a mechanism for atomically retrieving the timer's current value, as well as providing relative/absolute timers and being unaffected by changes in system time.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>ufd</code>:<code>int</code> - A file descriptor that refers to a timer created via timerfd_create(2).</li> <li><code>otmr</code>:<code>struct old_itimerspec32*</code> - Pointer to a struct old_itimerspec32 object which will be used to return the timer's current value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#sys_timerfd_gettime32","title":"sys_timerfd_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#type","title":"Type","text":"<p>probes</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#purpose","title":"Purpose","text":"<p>To measure the execution time of the timerfd_gettime32 system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#example-use-case","title":"Example Use Case","text":"<p>The timerfd_gettime32 system call might be used in an application to retrieve the current value of a timer that was created via the timerfd_create(2) system call for use with a signal handler.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#issues","title":"Issues","text":"<p>There is currently no known issue associated with the timerfd_gettime32 system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#related-events","title":"Related Events","text":"<ul> <li>timerfd_create(2)</li> <li>timerfd_settime32(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/","title":"timerfd_settime","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#intro","title":"Intro","text":"<p>timerfd_settime - set the expiration and interval of an installed timer</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#description","title":"Description","text":"<p>The timerfd_settime() system call arms (starts) or disarms (stops) the timer referred to by the file descriptor <code>fd</code>. It does this by setting the timer's expiration and interval according to the values specified in the <code>struct itimerspec</code> pointed to by the <code>new_value</code> argument. If the <code>old_value</code> argument is non-NULL, then the previous <code>struct itimerspec</code> is returned in this location. This syscall also allows the user to specify the <code>TFD_TIMER_ABSTIME</code> descriptor to indicate that <code>new_value-&gt;it_value</code> is evaluated relative to the CLOCK_REALTIME clock.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - file descriptor referring to the timer instance.</li> <li><code>flags</code>: <code>int</code> - flags specifying the behavior of the timer. Flags: <code>TFD_TIMER_ABSTIME</code></li> <li><code>new_value</code>: <code>const struct itimerspec*</code> [K] - pointer to the new timer value.</li> <li><code>old_value</code>: <code>struct itimerspec*</code> [K] - pointer to the previous timer value</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#sys_timerfd_settime","title":"<code>sys_timerfd_settime</code>","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#purpose","title":"Purpose","text":"<p>To monitor the duration of timerfd_settime system calls.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#example-use-case","title":"Example Use Case","text":"<p>This event can be used for monitoring a timer. For example, it can be used to record the time at which an application sets a timer.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#related-events","title":"Related Events","text":"<ul> <li><code>timerfd_gettime</code> - read the timer expiration and interval</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/","title":"timerfd_settime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#intro","title":"Intro","text":"<p>timerfd_settime32 - sets or reads the expiration and interval settings of a timer created by <code>timerfd_create3</code></p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#description","title":"Description","text":"<p>This syscall is used to set or read the expiration and interval settings of a timer created by <code>timerfd_create3</code>, a timer that is awoken when a time elapses until the timer is reset with a new expiration time. This syscall is called with two pointers to struct <code>old_itimerspec32</code> objects, <code>utmr</code> and <code>otmr</code>, which store the values of the timer both before and after it being set. A <code>ufd</code> and <code>flags</code> are also passed to the function, <code>ufd</code> corresponding to the file descriptor associated to the timer, and <code>flags</code>, an options field.</p> <p>One advantage of using this syscall is that it provides an easy (and fast) way of setting and managing a timer. It is particularly handy when used with a <code>CLOCK_MONOTONIC</code> clock, since it will neither gain nor lose time. On top of that, timers set with <code>timerfd_settime</code> will never expire earlier than its intended time, which can be quite useful when working with time-sensitive tasks.</p> <p>One drawback is that if Linux kernel is modified with a newer version of it, applications need to be recompiled against newer version in order for <code>timerfd_settime32</code> to be used properly.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>ufd</code>: <code>int</code> - The file descriptor associated with the timer.</li> <li><code>flags</code>: <code>int</code> - Option flags to indicate whether the new settings are affected at expiration or after current expiration.</li> <li><code>utmr</code>: <code>struct old_itimerspec32*</code> - Pointer to a <code>struct old_itimerspec32</code> object defining the new timer settings.</li> <li><code>otmr</code>: <code>struct old_itimerspec32*</code>[OPT] - Pointer to a <code>struct old_itimerspec32</code> object where the previous settings of the timer are stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#timerfd_settime32_1","title":"timerfd_settime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#type","title":"Type","text":"<p>kprobe + nop</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#purpose","title":"Purpose","text":"<p>To trace the syscall timerfd_settime32 with the intention of monitoring when the timer is set and gather information about the duration of time for which the user is expecting the timer to expire.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#example-use-case","title":"Example Use Case","text":"<p>One example use case for this syscall is when we need to keep track of time needed for certain tasks. This can be particularly useful when we are doing performance analysis, as we can use this to check which operations are taking more time.</p> <p>For example, we can measure how much time it takes to perform a certain task by setting a timer with this funciton and checking how much time it takes for the timer to expire.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#issues","title":"Issues","text":"<p>One common issue with using timerfd_settime32 is that we are relying on the accuracy of the system timer. In a system with an unstable clock, maybe due to scheduling, this could cause our timer to expire earlier or later than it is supposed to.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#related-events","title":"Related Events","text":"<ul> <li><code>timerfd_create3</code>: Used to create the timer associated with <code>timerfd_settime32</code>.</li> <li><code>epoll_wait</code>: Used to wait for timers to expire. </li> <li><code>timer_gettime</code>: Used to access or alter the timer's expiration settings.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/times/","title":"times","text":""},{"location":"docs/events/builtin/syscalls/times/#intro","title":"Intro","text":"<p>times - Get process and child process times</p>"},{"location":"docs/events/builtin/syscalls/times/#description","title":"Description","text":"<p>The <code>times()</code> syscall retrieves the running times of the current process and of given child processes. Upon successful completion, the <code>buf</code> argument, if it is not NULL, is filled with an array of <code>struct tms</code> values.</p> <p>A <code>struct tms</code> value has the following form:</p> <pre><code>struct tms {\n    clock_t tms_utime; // user time\n    clock_t tms_stime; // system time\n    clock_t tms_cutime; // user time of process and child processes\n    clock_t tms_cstime; // system time of process and child processes\n};\n</code></pre> <p>The <code>clock_t</code> type is an arithmetic type which is capable of representing times.</p> <p>This syscall is useful for profiling applications or to measure their running time. It can also be used to get an idea of the time a process and its children spent in user and system mode.</p>"},{"location":"docs/events/builtin/syscalls/times/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct tms*</code>[U] - Pointer to a <code>struct tms</code>, filled with an array of <code>struct tms</code> values upon successful completion.</li> </ul>"},{"location":"docs/events/builtin/syscalls/times/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (Pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/times/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/times/#sys_times","title":"sys_times","text":""},{"location":"docs/events/builtin/syscalls/times/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/times/#purpose","title":"Purpose","text":"<p>Hooked to record timing information for the <code>times()</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/times/#example-use-case","title":"Example Use Case","text":"<p>The <code>times()</code> syscall can be used in the following example to get more insight into a process and child processes running times:</p> <pre><code>struct tms t;\n\nif (times(&amp;t) != -1) {\n    printf(\"User time of this process: %lld ms\\n\", t.tms_utime * MSEC_PER_SEC);\n    printf(\"System time of this process: %lld ms\\n\", t.tms_stime * MSEC_PER_SEC);\n    printf(\"User time of this process and its childrens: %lld ms\\n\", t.tms_cutime * MSEC_PER_SEC);\n    printf(\"System time of this process and its childrens: %lld ms\\n\", t.tms_cstime * MSEC_PER_SEC);\n}\n</code></pre>"},{"location":"docs/events/builtin/syscalls/times/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/times/#related-events","title":"Related Events","text":"<ul> <li><code>execve()</code> - execute a program</li> <li><code>clone()</code> - create a child process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tkill/","title":"tkill","text":""},{"location":"docs/events/builtin/syscalls/tkill/#intro","title":"Intro","text":"<p>tkill - send a signal to a specified process or thread</p>"},{"location":"docs/events/builtin/syscalls/tkill/#description","title":"Description","text":"<p>The tkill() system call sends the signal <code>sig</code> to the thread <code>tid</code>. The thread <code>tid</code> has to be a thread of the calling process. The tkill() system call is a more specific alternative to kill(2).</p> <p>When the signal is delivered, it is as if signal() had been called with the signal number <code>sig</code> and the argument siginfo_t* set to NULL from within the thread <code>tid</code>. Note that software support for thread-directed signals has been removed from the kernel.</p> <p>The <code>tkill()</code> system call differs from tkill() in that <code>tkill()</code> behaves as <code>kill()</code> does, in that it does not set errno if the process or process group does not exist. Note that regardless of the signal number sent, no signals shall be generated when sending a signal to a nonexistent process or process group.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#arguments","title":"Arguments","text":"<ul> <li><code>tid</code>:<code>int</code>[K] - The thread ID of the thread to be signaled.</li> <li><code>sig</code>:<code>int</code>[K] - The signal number passed to the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tkill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tkill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tkill/#tkill_1","title":"tkill","text":""},{"location":"docs/events/builtin/syscalls/tkill/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/tkill/#purpose","title":"Purpose","text":"<p>To gather information on system calls called by the thread.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#example-use-case","title":"Example Use Case","text":"<p>tkill() is most commonly used to kill threads that are stuck or have gone into an unexpected state.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#issues","title":"Issues","text":"<p>The tkill() system call is not always successful in delivering the signal, so it is necessary to use a signal-safe system call such as rt_sigqueueinfo() to ensure that the signal is delivered.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#related-events","title":"Related Events","text":"<ul> <li>signal()</li> <li>kill()</li> <li>tkill()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/truncate/","title":"truncate","text":""},{"location":"docs/events/builtin/syscalls/truncate/#intro","title":"Intro","text":"<p>truncate - Change the size of a file to a specified length</p>"},{"location":"docs/events/builtin/syscalls/truncate/#description","title":"Description","text":"<p>The truncate() system call causes the regular file referenced by path or referenced by the file descriptor fd to have a size of exactly length bytes.</p> <p>If the file previously was larger than length, the extra data is discarded.  If the file was previously shorter, it is extended, and the extended part reads as null bytes (\u2018\\0\u2019).</p>"},{"location":"docs/events/builtin/syscalls/truncate/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - The path of the file to be truncated.</li> <li><code>length</code>:<code>off_t</code>[K] - The length of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/truncate/#sys_truncate","title":"sys_truncate","text":""},{"location":"docs/events/builtin/syscalls/truncate/#type","title":"Type","text":"<p>KPROBE</p>"},{"location":"docs/events/builtin/syscalls/truncate/#purpose","title":"Purpose","text":"<p>sys_truncate is hooked to gather information about a regular file being truncated.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#example-use-case","title":"Example Use Case","text":"<p>Truncate can be used to reduce the size of a file, with the extra data being discarded if it is longer than the specified length.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#issues","title":"Issues","text":"<p>If the length specified is longer than the actual size of the file, security issues may arise if the file is allocated and filled with data afterwards.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#related-events","title":"Related Events","text":"<p>fchmodat, creat, ftruncate</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/","title":"truncate64","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#intro","title":"Intro","text":"<p>truncate64() - truncate a file to a specified length</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#description","title":"Description","text":"<p>The truncate64() system call is used to truncate a file to a specified length.  If the file is larger than the length specified, the extra data is lost. If the file is shorter than the length specified, the file will be extended with NUL bytes (<code>\\0</code>). The truncate64() system call operates on files, not directories.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - pathname of the file whose length is to be changed</li> <li><code>length</code>:<code>off_t</code> - size to which the file should be truncated</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate64/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#sys_truncate64","title":"sys_truncate64","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#purpose","title":"Purpose","text":"<p>To detect when the <code>truncate64</code> system call is called</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#example-use-case","title":"Example Use Case","text":"<p>truncate64() can be used to ensure that a certain file does not exceed a certain size. For example, it can be used to ensure a log file does not exceed 1GB in size.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#issues","title":"Issues","text":"<p>The truncate64() system call does not check if the current user has the necessary permissions to truncate the file, this must be done manually.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#related-events","title":"Related Events","text":"<ul> <li>open() - to open a file handle before truncating it</li> <li>ftruncate64() - similar system call, but which operates on an open file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/","title":"tuxcall","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#intro","title":"Intro","text":"<p>tuxcall - handle requests from userspace, typically IOCTL calls</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#description","title":"Description","text":"<p>tuxcall is a way for programs running in userspace to make requests to the kernel. It is typically used to control devices and configure hardware. The kernel will check the associated data structures and privileges and then process the request and return a response to the user program. The drawbacks of using tuxcall are that it can be complex and time-consuming to debug and debug when using multiple threads and ioctls.</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>: <code>int</code>[K] - defines the command to be executed. </li> <li><code>arg</code>: <code>void *</code>[K] - a void pointer to a data structure associated with the command. </li> </ul>"},{"location":"docs/events/builtin/syscalls/tuxcall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/tuxcall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#syscall_entry_tuxcall","title":"syscall_entry_tuxcall","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#purpose","title":"Purpose","text":"<p>To trace tuxcall system calls</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#example-use-case","title":"Example Use Case","text":"<p>A program running in user space is using tuxcall to configure a device. It will pass the relevant data structures and arguments to the kernel via the tuxcall syscall and wait for a response. </p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#issues","title":"Issues","text":"<p>One of the major issues with tuxcall is that it can be difficult to debug when errors occur due to the complexity of the system. </p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#related-events","title":"Related Events","text":"<ul> <li>ioctl - performs io control operations </li> <li>read - read data from a file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/","title":"ulimit","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#intro","title":"Intro","text":"<p>ulimit - set or get the resource limit of the current process</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#description","title":"Description","text":"<p>ulimit is a command provides control over the resourcing of a process. The ulimit command can be used to set the limits on the system resources that can be used by the process. The limits can be set for any of the following that the system supports: files, memory, number of processes, maximum CPU time, and more. With some limits, ulimit also has the ability to query the current limit. </p> <p>Ulimit can be used to protect systems from resource abuse by allowing users to put an upper limit on the amount of certain resources they can allocate to their processes. This ensures that runaway processes or user abuse of resources is avoided. </p>"},{"location":"docs/events/builtin/syscalls/ulimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code>[K,U] - the resource to use.</li> <li><code>limit</code>:<code>string</code>[K,U] - the new resource limit. Can be a number, 'hard' or 'soft'.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ulimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ulimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#do_ulimit","title":"do_ulimit","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#purpose","title":"Purpose","text":"<p>to monitor the resource limit of the current process.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#example-use-case","title":"Example Use Case","text":"<p>Ulimit can be used to guard against an individual user or process from going wild and consuming too much resources by putting a limit on the resources that can be used.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#issues","title":"Issues","text":"<p>Ulimit might not be available in all systems, so it is important to check what the supported resources are before using it.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#related-events","title":"Related Events","text":"<p>setrlimit</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umask/","title":"umask","text":""},{"location":"docs/events/builtin/syscalls/umask/#intro","title":"Intro","text":"<p>umask - set file mode creation mask</p>"},{"location":"docs/events/builtin/syscalls/umask/#description","title":"Description","text":"<p>The umask system call sets the calling process's file mode creation mask (umask) to <code>mask</code> and returns the previous value of the mask. The umask is used to determine the file permission bits of newly created files. A process calls umask before creating new files and directories with the intention that files will be created with the specified mode. The mode argument is bitwise-ANDed with the complement of the file mode creation mask of the process (as returned by a call to umask) to turn off specified bits in the file permission, thus restricting the permissions of newly-created files.</p> <p>UMask is designed to be used in a secure way to ensure that no unintended consequences arise due to unexpected permissions. It should not be used to relax constraints. Allowing a process to execute arbitrary external code with arbitrary permissions is a security risk.</p>"},{"location":"docs/events/builtin/syscalls/umask/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:<code>mode_t</code>[K] - The new file mode creation mask, or 0 for no change. The bit pattern of the mask is CNMSFU, where S is the set-user-ID and F is the set-group-ID permission bit.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umask/#sys_umask","title":"sys_umask","text":""},{"location":"docs/events/builtin/syscalls/umask/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/umask/#purpose","title":"Purpose","text":"<p>Tracking the umask modifications of a process over time.</p>"},{"location":"docs/events/builtin/syscalls/umask/#example-use-case","title":"Example Use Case","text":"<p>Umask can be used to monitor changes to the file mode creation mask of a process. It can be used to ensure that the process is only setting the file mode creation mask to pre-defined values, and that no unintended consequences arise due to unexpected permissions.</p>"},{"location":"docs/events/builtin/syscalls/umask/#issues","title":"Issues","text":"<p>Using umask to relax constraints can be a security risk. Allowing a process to execute arbitrary external code with arbitrary permissions is a breach of security.</p>"},{"location":"docs/events/builtin/syscalls/umask/#related-events","title":"Related Events","text":"<ul> <li>chmod() - used to change the permission of a file or directory.</li> <li>stat() - used to get the file mode of a file or directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umount/","title":"umount","text":""},{"location":"docs/events/builtin/syscalls/umount/#intro","title":"Intro","text":"<p>umount - Unmount file systems on linux</p>"},{"location":"docs/events/builtin/syscalls/umount/#description","title":"Description","text":"<p>The umount function is used to unmount a given file system from the specified target on linux. This is done by issuing a request to the virtual file system to detach the file system as well as any associated mount points. Umount can also be used to unmount all mount points in a given target. Note that unmounting a filesystem removes the filesystem from both user and kernel spaces, so it is important to first ensure that nothing in user space is actively using the filesystem.</p> <p>There are some edge cases to consider when using umount. For example, the \"lazy unmount\" option can be used to prevent processes from being impacted by an unmount event by keeping them alive until the next time they try to access the filesystem. However, if the filesystem is mounted with a read-only flag, the lazy unmount will not be applied as the processes should be able to keep running despite the filesystem being unmounted.</p>"},{"location":"docs/events/builtin/syscalls/umount/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code> - Pathname of the block special device or directory to be unmounted.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umount/#sys_umount","title":"sys_umount","text":""},{"location":"docs/events/builtin/syscalls/umount/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/umount/#purpose","title":"Purpose","text":"<p>Hooking the sys_umount function is used to gather information about filesystem usage by monitoring both the entry and exit of any umount call.</p>"},{"location":"docs/events/builtin/syscalls/umount/#example-use-case","title":"Example Use Case","text":"<p>One common use case might be monitoring the usage of a given filesystem. When an unmount is requested, this event would be triggered with the corresponding arguments. Analysing this data could be helpful to track usage patterns, or troubleshoot issues with the unmount operation.</p>"},{"location":"docs/events/builtin/syscalls/umount/#issues","title":"Issues","text":"<p>If umount is issued with no target specified, it will try to unmount all mount points, which could have unintended effects on the system. It may be a good idea to have monitoring systems in place to detect in case it is used in this manner.</p>"},{"location":"docs/events/builtin/syscalls/umount/#related-events","title":"Related Events","text":"<ul> <li>mount</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umount2/","title":"umount2","text":""},{"location":"docs/events/builtin/syscalls/umount2/#intro","title":"Intro","text":"<p>umount2 - system call used to unmount a filesystem.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#description","title":"Description","text":"<p>The umount2() system call is used to unmount a filesystem from the target directory. It requires the mountpoint directory and an additional set of flags to indicate if the umount should be cascaded or not. The usefulness of this system call is that it allows for more control in the filesystem, allowing a more fine grain unmounting of a filesystem.</p> <p>There are, however, a few drawbacks associated with using the umount2() system call. Not all filesystems are supported, and some could fail due to different implementation. Additionally, there is no default action, requiring the user to provide the needed flags for an unmount operation.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[K] - the directory mountpoint from which the filesystem should be unmounted.</li> <li><code>flags</code>:<code>int</code>[K] - the flags used in the unmounting operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umount2/#sys_umount2","title":"sys_umount2","text":""},{"location":"docs/events/builtin/syscalls/umount2/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#purpose","title":"Purpose","text":"<p>To collect the arguments and return the unmounting operation results of the umount2() system call.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#example-use-case","title":"Example Use Case","text":"<p>A common use case for umount2() is when the user needs to unmount a filesystem and wants more control on the unmounting operation.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#issues","title":"Issues","text":"<p>One downside of umount2() is that no default action is taken. The user must specify the flags so that the operation is successful.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#related-events","title":"Related Events","text":"<ul> <li>mount2 - the system call used to mount a filesystem.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/uname/","title":"uname","text":""},{"location":"docs/events/builtin/syscalls/uname/#intro","title":"Intro","text":"<p>uname - get the system name</p>"},{"location":"docs/events/builtin/syscalls/uname/#description","title":"Description","text":"<p>The uname() system call wraps the get_utsname() kernel function and is used to get information about the current system, including the system name, version and the release. The struct utsname argument, buf, passes the system information to user space.</p>"},{"location":"docs/events/builtin/syscalls/uname/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct utsname*</code>[K, U] - pointer to a buffer to store the utsname struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/uname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/uname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/uname/#sys_uname","title":"sys_uname","text":""},{"location":"docs/events/builtin/syscalls/uname/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/uname/#purpose","title":"Purpose","text":"<p>To trace when the uname() syscall is called and get the arguments passed.</p>"},{"location":"docs/events/builtin/syscalls/uname/#example-use-case","title":"Example Use Case","text":"<p>In a security monitoring system, the uname() syscall can be used to identify if a system is undergoing changes to its core characteristics.</p>"},{"location":"docs/events/builtin/syscalls/uname/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/uname/#related-events","title":"Related Events","text":"<p>The get_utsname() kernel function, from which this syscall originates.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unlink/","title":"unlink","text":""},{"location":"docs/events/builtin/syscalls/unlink/#intro","title":"Intro","text":"<p>unlink - Removes a file name for the file system.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#description","title":"Description","text":"<p>unlink removes the specified pathname from the file system. If the specified pathname is the last link to a file and no processes have the file open, then the file is deleted and the space it was using is made available. This system call fails if the pathname specified is a directory or if the pathname has more than one link.</p> <p>unevent is used to unlink a file name and may also be used to remove directories, provided the directory is empty. However, unlink is not secure against race conditions and can be impacted by the TOCTOU (Time of Check, Time of Use) bug.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K, U] - Pathname of the file to unlink. Must be a file, and not a directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unlink/#do_unlinkat","title":"do_unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlink/#type","title":"Type","text":"<p>Kprobe + Kreteprobe</p>"},{"location":"docs/events/builtin/syscalls/unlink/#purpose","title":"Purpose","text":"<p>To log the syscall arguments and the syscall return value upon execution, as well as determine the origin of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#example-use-case","title":"Example Use Case","text":"<p>unlink is used to remove a file or directory from the file system, with one important caveat - in order to unlink a directory, the directory must be empty, otherwise, unlink fails. This system call is often used to clean up unused files that have been created during the course of running a program.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#issues","title":"Issues","text":"<p>The C language doesn\u2019t require the system calls to detect errors on their own, so the errors returned by unlink can be unpredictable. Additionally, it is vulnerable to TOCTOU bug, where a potential attacker might be able to exploit the race condition to the system's disadvantage.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#related-events","title":"Related Events","text":"<p>The unlink event is related to other system calls that can be used to manipulate files and directories, such as open, close, read, and write. It may also be used in combination with link and symlink to create, rename, and delete links to files in the system.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/","title":"unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#intro","title":"Intro","text":"<p>unlinkat - system call that deletes a file name, relative to an open directory</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#description","title":"Description","text":"<p>unlinkat is a system call that deletes a file name, relative to an open directory. The purpose of unlinkat is to provide a more secure and robust way to delete a file than the remove() syscall, as it allows users to avoid race conditions while deleting a file. </p> <p>Unlinkat also allows a user to delete links without traversing whole directory hierarchies, by providing the location of the file (directory) and its name as two separate arguments.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - an open file descriptor referring to a directory.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - a string containing the name of the file to be deleted, relative to the directory referred to by dirfd.</li> <li><code>flags</code>:<code>int</code>[K] - optional flags that can include AT_REMOVEDIR.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#sys_unlinkat","title":"sys_unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#purpose","title":"Purpose","text":"<p>To monitor file deletions.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#example-use-case","title":"Example Use Case","text":"<p>Finding malicious file deletions.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#issues","title":"Issues","text":"<p>unlinkat is vulnerable to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#related-events","title":"Related Events","text":"<p>unlink(), remove(), readlinkat(), openat()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unshare/","title":"unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#intro","title":"Intro","text":"<p>unshare - separate a process's execution context into its own process.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#description","title":"Description","text":"<p>The unshare system call allows a process to separate its execution context into its own process. This system call can be used to create a new process from an existing one, or to create a new \"lightweight\" process (LWP), which executes in a shared memory context with the creating process. The flags parameter specifies which parts of the execution context to unshare, with CLONE_NEW[CGROUP|IPC|NET|NS|PID|USER]. It returns 0 on success, or a negative error code on error.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - specifies the type of context to unshare. See flags section in man page for more details.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unshare/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unshare/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unshare/#sys_unshare","title":"sys_unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/unshare/#purpose","title":"Purpose","text":"<p>To detect the unshare syscall.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#task_unshare","title":"task_unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/unshare/#purpose_1","title":"Purpose","text":"<p>To detect the task_unshare function call.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#example-use-case","title":"Example Use Case","text":"<p>An example of using unshare is a container. By using this system call, a process can separate its execution context, thus creating a new process (or LWP) in a shared memory context with its parent while also allowing it to have its own environment variables and IPC namespaces, among others.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#issues","title":"Issues","text":"<p>When unsharing a process, all of its children must also be unshared or they will remain in the original process's context.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#related-events","title":"Related Events","text":"<ul> <li>fork - Create a child process.</li> <li>clone - Create a child process in a different memory address space. </li> <li>setns - Set namespace for process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/uselib/","title":"uselib","text":""},{"location":"docs/events/builtin/syscalls/uselib/#intro","title":"Intro","text":"<p>uselib - load library into the calling process address space.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#description","title":"Description","text":"<p>The uselib() system call loads a shared library into the calling process's virtual address space, typically at an address chosen by the kernel. After it has been called, the library routines can be used. The library is only loaded for the duration of the process; it is private to each process and other processes do not see the loaded library. Care must be taken when using uselib() because if the same library is loaded multiple times and then unloaded, calls by the process to routines in the libraries will fail and result in an segmentation violation.</p> <p>There are some edge-cases where uselib() might not work properly, such as when the calling program is not authorised to access the specified library, or if the library is not for the correct architecture.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#arguments","title":"Arguments","text":"<ul> <li><code>library</code>:<code>const char*</code>[K] - Path to the library to load.</li> </ul>"},{"location":"docs/events/builtin/syscalls/uselib/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/uselib/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/uselib/#do_uselib","title":"do_uselib","text":""},{"location":"docs/events/builtin/syscalls/uselib/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/uselib/#purpose","title":"Purpose","text":"<p>To trace the arguments of the uselib system call.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#example-use-case","title":"Example Use Case","text":"<p>Monitor the libraries being loaded by a process. This can be used to detect attempts to perform malicious behavior by loading malicious libraries, or to identify mistakes in program design.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#issues","title":"Issues","text":"<p>This system call is not supported on all architectures. Additionally, this system call is not available in the newest versions of the Linux kernel and has been replaced by other system calls.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#related-events","title":"Related Events","text":"<ul> <li>execve</li> <li>munmap</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/","title":"userfaultfd","text":"<p>```yaml</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#userfaultfd","title":"userfaultfd","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#intro","title":"Intro","text":"<p>userfaultfd - Used to handle page faults in user space.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#description","title":"Description","text":"<p>userfaultfd is a mechanism by which applications can handle page faults in user space. This syscall creates a file descriptor which can receive notification of page faults occurring in a designated memory region. The application can then handle page faults in its own context, allowing for a finer control over how to respond to page faults.</p> <p>The flags parameter indicates what type of faults can be handled. By setting certain flags the application can choose only certain types of page faults that it is interested in.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[U, OPT] - Indicates which page faults the application is interested in. Possible values include <code>O_NONBLOCK</code>, <code>O_CLOEXEC</code> and <code>UFFD_API_FEATURES_EVENT</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#kernel_userfaultfd","title":"kernel_userfaultfd","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#purpose","title":"Purpose","text":"<p>To track all calls to the kernel_userfaultfd entry point.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#example-use-case","title":"Example Use Case","text":"<p>A user space application that needs to be able to handle page faults occurring in a specific sections of its address space, such as when servicing page faults from a user space page cache.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#related-events","title":"Related Events","text":"<p>All related page fault events.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ustat/","title":"ustat","text":""},{"location":"docs/events/builtin/syscalls/ustat/#intro","title":"Intro","text":"<p>ustat - determine file system information associated with a mounted file system.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#description","title":"Description","text":"<p>The <code>ustat</code> system call is used to retrieve information about the mounted file system containing the directory whose file descriptor is passed in. This information describes the amount of blocks and file nodes associated with that file system, as well as the size of each. Depending on the flags passed, some of this information might be obtained from the filesystem itself, or from the system buffer cache.  </p> <p>When used in conjunction with the <code>parse-arguments</code> flag, the device argument is used to specify the exact file system from which to obtain the information. This is useful in cases where multiple file systems are present over the same device.  </p>"},{"location":"docs/events/builtin/syscalls/ustat/#arguments","title":"Arguments","text":"<ul> <li><code>dev</code>:<code>dev_t</code>[K] - device containing the file system  </li> <li><code>ubuf</code>:<code>struct ustat*</code>[U] - pointer to a buffer in user space used to write the information obtained  </li> </ul>"},{"location":"docs/events/builtin/syscalls/ustat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ustat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ustat/#sys_ustat","title":"sys_ustat","text":""},{"location":"docs/events/builtin/syscalls/ustat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/ustat/#purpose","title":"Purpose","text":"<p>The purpose of this hook is to evaluate the arguments associated with the <code>ustat</code> system call, before its execution.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#example-use-case","title":"Example Use Case","text":"<p>A file system event monitor application could use the <code>ustat</code> call to return the information related to a given file system, such as the blocks and file nodes associated with it.  </p>"},{"location":"docs/events/builtin/syscalls/ustat/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#related-events","title":"Related Events","text":"<ul> <li>statfs - get file system information.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utime/","title":"utime","text":""},{"location":"docs/events/builtin/syscalls/utime/#intro","title":"Intro","text":"<p>utime - changes file last access and modification times.</p>"},{"location":"docs/events/builtin/syscalls/utime/#description","title":"Description","text":"<p>The utime() system call changes the access and modification times of the inode specified by filename. The atime, mtime, and ctime arguments correspond to the values for the access, modification and inode change times respectively.  If times is NULL, the access and modification times of the file are set to the current time.</p> <p>When utime is called from userspace, two types of privileges can be exercised: * The owner of the file can call utime, and it will set the file's access and modification times to the current time.  * The process must have root privileges to be able to change the times to a specified value other than the current time. </p> <p>utime is vulnerable to the Time Of Check Time Of Use (TOCTOU) race condition, where an attacker could modify the file after it has been checked but before it has been modified.</p>"},{"location":"docs/events/builtin/syscalls/utime/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>const char*</code>[K] - Path name of the file whose access and modification times are being modified.</li> <li><code>times</code>:<code>const struct utimbuf*</code>[K] - Specifies new access and/or modification time. If NULL, the access and modification times of the file are set to the current time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utime/#do_utimes","title":"do_utimes","text":""},{"location":"docs/events/builtin/syscalls/utime/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/utime/#purpose","title":"Purpose","text":"<p>This kernel function is typically the entry point for the <code>utime</code> syscall, so it was hooked to capture request for this syscall.</p>"},{"location":"docs/events/builtin/syscalls/utime/#example-use-case","title":"Example Use Case","text":"<p>A system administrator may want to use utime to reset the modification and/or access times on a set of files in response to changing file access laws.</p>"},{"location":"docs/events/builtin/syscalls/utime/#issues","title":"Issues","text":"<p>A common TOCTOU race condition when using utime can be avoided by using the utimensat() syscall.</p>"},{"location":"docs/events/builtin/syscalls/utime/#related-events","title":"Related Events","text":"<p><code>utimensat</code>, <code>futimens</code>, <code>utimes</code>, <code>futimesat</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/","title":"utimensat","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#intro","title":"Intro","text":"<p>utimensat - Change file timestamps with nanosecond precision</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#description","title":"Description","text":"<p>The utimensat system call creates, checks, and/or modifies the timestamps of a file relative to a directory file descriptor. It provides nanosecond precision and some additional flags that the utime and utimes system calls do not provide.</p> <p>The 'times' argument is a pointer to a two-element array that specifies the access and modification times respectively. If either timestamp is set to the special value UTIME_OMIT, then that particular timestamp is not set. If 'times' is set to NULL, then the access and modification times of the 'pathname' are set to the current time.</p> <p>The flags argument is a bitfield that is used to indicate whether the times are relative to the directory referenced by the file descriptor 'dirfd' (AT_SYMLINK_NOFOLLOW), or whether the operation should be applied to the symlink itself (AT_SYMLINK_NOFOLLOW).</p> <p>The utimensat system call is similar to utime and utimes, but with more precise control over timestamp behavior.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - A file descriptor referring to a directory, or the special value AT_FDCWD, which can be used to indicate the current working directory.</li> <li><code>pathname</code>:<code>const char</code>* <code>[K]</code> - A pointer to a string containing the pathname of a file relative to the directory referred to by the file descriptor 'dirfd'.</li> <li><code>times</code>:<code>struct timespec</code>* <code>[K]</code> - A pointer to a two-element array specifying the access and modification times respectively. The values are measured as nanoseconds since the Epoch (Jan 1 1970). If either timestamp is set to the special value UTIME_OMIT, then that particular timestamp is not set. If 'times' is set to NULL, then the access and modification times of the 'pathname' are set to the current time.</li> <li><code>flags</code>:<code>int</code>[K] - A bit-field indicating whether the times are relative to the directory referred to by the file descriptor 'dirfd' (AT_SYMLINK_NOFOLLOW), or whether the operation should be applied to the symlink itself (AT_SYMLINK_NOFOLLOW).</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> <li>U - Originated from user space (for example, pointer to user space memory used to get it) </li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use) </li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#do_utimes","title":"do_utimes","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#purpose","title":"Purpose","text":"<p>To analyze the arguments and return values of the utimensat system call.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#example-use-case","title":"Example Use Case","text":"<p>Utimensat could be used to set timestamps to a target file while allowing a user to avoid issues with Time Of Check To Time Of Use (TOCTOU) race condition by therefore providing a more secure setting of timestamps.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#issues","title":"Issues","text":"<p>Utimensat system call may fail in certain situations due to filesystem type that do not support nanosecond timestamp updates.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#related-events","title":"Related Events","text":"<ul> <li><code>utime</code>,<code>utimes</code> - These related system calls can modify timestamps for files, but with less precision. </li> <li><code>futimesat</code> - Like utimensat, but operates on a file instead of a pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/","title":"utimensat_time32","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#intro","title":"Intro","text":"<p>utimensat_time32 - Change the timestamps of a file with nanosecond precision using a relative or an absolute 30-bit timestamp</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#description","title":"Description","text":"<p>The utimensat_time32 system call changes the timestamps of a file, similar to the utime system call. It is part of the Advanced Linux Programming Interface (ALP) and offers an improved timestamp range and higher precision of file time handling compared to its predecessor. It supports nanosecond resolution on 32-bit architectures inside the old_timespec32 structure which can be used to specify an absolute or relative timestamp.</p> <p>The flags parameter can be used to indicate if the t parameter should be used as an absolute (0) or relative (UTIME_NOW, UTIME_OMIT) timestamp for the file. If the AT_SYMLINK_NOFOLLOW flag is passed, the system call does not follow symbolic links, but fails when the specified file is a symbolic link.</p> <p>Are there any edge-cases, drawbacks or advantages of using it? Due to its use of the old_timespec32 structure, utimensat_time32 can only specify a time in a range of ~1902 to 2038. As such, it is not suitable for applications needing a more flexible timestamp range. </p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>unsigned int</code>[K] - The file descriptor of the directory containing the file whose timestamps should be changed. A value of AT_FDCWD can be used to indicate the current working directory.</li> <li><code>filename</code>:<code>char*</code>[U] - Pointer to the name of the file whose timestamps should be changed.</li> <li><code>t</code>:<code>struct old_timespec32*</code>[U] - Pointer to the timespec structure containing the desired new timestamp for last access and modification time.</li> <li><code>flags</code>:<code>int</code>[K] - Flags controlling the behavior of the system call. Can be used to indicate if timestamp should be set relatively (UTIME_NOW) or absolutely (0).</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#sys_utimensat_time32","title":"sys_utimensat_time32","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#purpose","title":"Purpose","text":"<p>Locate applications making syscalls to utimensat_time32 and analyze their parameters.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use this event to monitor writes to important files or directories and log whenever their timestamps are changed by any user or process.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#issues","title":"Issues","text":"<p>Due to the limited range of timespec values (1902-2038), utimensat_time32 is not suitable for applications needing more flexible timestamp handling.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#related-events","title":"Related Events","text":"<p>utimensat, utimensat_time64</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimes/","title":"utimes","text":""},{"location":"docs/events/builtin/syscalls/utimes/#intro","title":"Intro","text":"<p>utimes -  System call to change the access and modification times of a given file or file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#description","title":"Description","text":"<p><code>utimes</code> is a syscall used to set the access and or modification time of file <code>filename</code> or file descriptor <code>fd</code> to the user specified value(s) in the <code>times</code> argument. If the <code>times</code> argument is null, the access and modification time of the given file or file descriptor will be set to the current time. </p> <p>The <code>utimes</code> system call is especially useful when creating a backup of a file or when trying to reset the times of a file in order to keep it up to date with latest modifications. There are some caveats to using <code>utimes</code>, however. <code>utimes</code> will only work on files that are owned by the user, and it is vulnerable to TOCTOU (time of check, time of use) attacks, as the file or file descriptor may be changed between the time of checking and the time of updating.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>char*</code>[K, U, OPT] - Pointer to a null-terminated filename string.</li> <li><code>times</code>:<code>struct timeval*</code>[K, U] - Pointer to an array of two <code>struct timeval</code> objects. The first object contains the desired access time, and the second object contains the desired modification time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimes/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimes/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimes/#sys_utimes","title":"sys_utimes","text":""},{"location":"docs/events/builtin/syscalls/utimes/#type","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/utimes/#purpose","title":"Purpose","text":"<p>To monitor changes to the files access and modification times.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#open_exec","title":"open_exec","text":""},{"location":"docs/events/builtin/syscalls/utimes/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/utimes/#purpose_1","title":"Purpose","text":"<p>To monitor usage of the <code>utimes</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#example-use-case","title":"Example Use Case","text":"<p>A backup program that wishes to keep the creation and modification dates of the backed up files up to date without altering the content of the original file.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#issues","title":"Issues","text":"<p><code>utimes</code> is not supported on all platforms, including Linux on PowerPC and Solaris.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#related-events","title":"Related Events","text":"<ul> <li>open</li> <li>access</li> <li>stat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vfork/","title":"vfork","text":""},{"location":"docs/events/builtin/syscalls/vfork/#intro","title":"Intro","text":"<p>vfork - system call used to make a copy of the current process</p>"},{"location":"docs/events/builtin/syscalls/vfork/#description","title":"Description","text":"<p>The vfork() system call is used by a program to create a copy (child process) of itself. The child process runs in the same address space as the parent process until it either calls execve() or exits. This allows for faster process creation since the child process inherits many of the attributes of the parent process. However, if neither execve() or exit() is called, a deadlock can occur when the parent process attempts to execute code before the child process has terminated.</p> <p>The vfork() system call creates a child process that share the same memory space as the parent, but the parent process will not run until the child process either calls execve() or exits. This usage of memory allows for higher speed process creation, but can lead to problems if the child process does not call execve() or exit().</p>"},{"location":"docs/events/builtin/syscalls/vfork/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>: <code>pid_t</code>[K] - The pid of the child process created by the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vfork/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vfork/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vfork/#sys_vfork","title":"sys_vfork","text":""},{"location":"docs/events/builtin/syscalls/vfork/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vfork/#purpose","title":"Purpose","text":"<p>Hook sys_vfork to track the pid of the child process and the return values of the call.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#example-use-case","title":"Example Use Case","text":"<p>vfork() is often used to create simple command-line programs or shell scripts. For example, <code>man fork</code> is executed by calling <code>vfork()</code> to create a new process and execute the <code>man</code> command in it.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#issues","title":"Issues","text":"<p>The main issue regarding vfork() is the potential for deadlock, since the parent process can not continue executing until the child process calls exit() or execve(). Programs using vfork() should ensure that the child process does not run for too long or in an infinite loop.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#related-events","title":"Related Events","text":"<ul> <li>fork() - A system call to create a new process that does not share memory with the parent process.</li> <li>execve() - A system call to execute a new program in the child process created by vfork().</li> <li>clone() - A system call to create a new process that shares the memory space of the parent process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/","title":"vhangup","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#intro","title":"Intro","text":"<p>vhangup - Revoke access to all descriptors associated with the caller's tty</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#description","title":"Description","text":"<p>The vhangup() system call will cause all descriptors associated with the caller's tty to be revoked. On Mac OS X, and many other Unix-like operating systems, this system call has been made obsolete by the setsid() system call. On some Linux-based systems, using this system call may reset certain signal -&gt; PID mappings and socket connection state.</p> <p>Using vhangup may also cause some process wait states to be reset. Note that, using this system call may cause certain terminal state to be reset, such as terminal baud rate, size and control characters.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#arguments","title":"Arguments","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#vhangup_1","title":"vhangup","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#purpose","title":"Purpose","text":"<p>To monitor calls of vhangup system call.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#example-use-case","title":"Example Use Case","text":"<p>When debugging a program that utilizes terminal control, vhangup can be used to reset the state of the terminal.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#related-events","title":"Related Events","text":"<p>setsid</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vm86/","title":"vm86","text":""},{"location":"docs/events/builtin/syscalls/vm86/#intro","title":"Intro","text":"<p>vm86 - Allows a user space program to execute 8086-CPU instructions in virtual 8086 mode.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#description","title":"Description","text":"<p>The vm86() system call provides a program with a way to execute 8086 instructions in virtual 8086 mode, with access to the protected-mode resources of the kernel such as memory and I/O ports. It provides a program a safe and controlled way to enter the realm of protected mode code. It is useful when emulation a x86 instruction set which is normally executed in 16-bit mode.</p> <p>There are few drawbacks when using this system call. Notably, it cannot be used in a multithreaded environment, as the virtual 8086 mode facility is not thread-safe. It also requires full control over the current processes virtual address space, meaning that the process must be single-threaded, without shared memory.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#arguments","title":"Arguments","text":"<ul> <li><code>fn</code>:<code>unsigned long</code>[K] - A bitmask indicating the requested functions.</li> <li><code>v86</code>:<code>struct vm86plus_struct*</code>[K] - A pointer to a struct vm86plus_struct containing a state to be used when entering or leaving virtual 8086 mode.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vm86/#entry-point","title":"Entry point","text":""},{"location":"docs/events/builtin/syscalls/vm86/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/vm86/#purpose","title":"Purpose","text":"<p>To monitor the entry of system call vm86</p>"},{"location":"docs/events/builtin/syscalls/vm86/#example-use-case","title":"Example Use Case","text":"<p>A typical use case is when an emulator is running a 32-bit x86 instruction set in 16-bit mode. This can be done by using the vm86() system call, which switches the virtual address spaces for the process and loads up the registers and segments. The process can then execute the 16-bit code in the virtual 8086 mode environment.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#issues","title":"Issues","text":"<p>The virtual 8086 mode environment is not thread safe, so the vm86() system call cannot be used in a multithreaded environment. It also requires full control over the current processes virtual address space, meaning that the process must be single-threaded, without shared memory.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#related-events","title":"Related Events","text":"<ul> <li>execve() - Used to run ARM emulator</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/","title":"vm86old","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#intro","title":"Intro","text":"<p>vm86old - Invoke real-mode software on 80386 and above processors.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#description","title":"Description","text":"<p>vm86old is used to run real-mode programs, i.e. DOS programs, on 80386 and above processors. It provides the necessary information for invoking real-mode programs, along with the protection of the operating system and any other applications running in protected mode.</p> <p>Using this system call comes with certain advantages and drawbacks. On one hand it preserves the system integrity as it keeps DOS mode separate from protected mode; however, it also limits the program from performing certain tasks that would otherwise be possible if they ran in the same context.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#arguments","title":"Arguments","text":"<ul> <li><code>info</code>: <code>struct vm86_struct*</code>[K] - Pointer to a <code>vm86_struct</code> structure that describes the real-mode program that the system call should run.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#do_vm86_old","title":"do_vm86_old","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#purpose","title":"Purpose","text":"<p>To monitor calls to the vm86old system call.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#example-use-case","title":"Example Use Case","text":"<p>A driver could use this system call to run real-mode programs from kernel-space.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#issues","title":"Issues","text":"<p>Due to the nature of the system call, the security of the system is affected as it enables running code in unprotected mode, meaning that malicious code could be used to exploit the underlying system.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#related-events","title":"Related Events","text":"<ul> <li><code>sigreturn</code> - Returns the state of the calling thread the way it was at the time of the syscall.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/","title":"vmsplice","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#intro","title":"Intro","text":"<p>vmsplice - read data from a pipe into a user address space</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#description","title":"Description","text":"<p>The vmsplice() system call transfers a count of up to <code>nr_segs</code> elements from  a user address space, into the specified pipe. Any type of pipe can be used,  including anonymous pipes (created using the pipe() system call) and  directed pipes created using the openat() system call with the O_PATH flag.  The <code>flags</code> argument can be set to VMSPLICE_F_MOVE, to transfer ownership of  the pages containing the iovec elements. The <code>iov</code> argument points to an  array of <code>iovec</code> structures, each consisting of a pointer to a location in  the user address space <code>iov_base</code>, and its length <code>iov_len</code>.</p> <p>Vmsplice does not check for the validity of the memory area, nor for its read access rights. Passing of invalid addresses (such as kernel space addresses) can corrupt the system.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of pipe.</li> <li><code>iov</code>:<code>const struct iovec*</code>[K] - pointer to a user space buffer containing the iovec elements to copy into the pipe. </li> <li><code>nr_segs</code>:<code>unsigned long</code>[K] - number of elements in <code>iov</code>.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - indicate the type of action available with the <code>iov</code> buffer. Can be set to VMSPLICE_F_MOVE, to transfer ownership of the pages containing the <code>iov</code> elements.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vmsplice/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vmsplice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#vfs_splice_from_pipe","title":"vfs_splice_from_pipe","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#type","title":"Type","text":"<p>Kprobes + kretprobes</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#purpose","title":"Purpose","text":"<p>Monitor process activity in terms of manipulating pipes</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#example-use-case","title":"Example Use Case","text":"<p>One example use case of vmsplice() could be an application that copies data from the user's shared memory space to a pipe, which will then be read by another application. This method of inter-process communication is efficient and helps to ensure data integrity.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#issues","title":"Issues","text":"<p>The vmsplice() system call is vulnerable to TOCTOU (Time of Check, Time of Use) attacks. This is because the memory passed to it is not checked for validity or for read access rights. Passing kernel space addresses to it could corrupt the system.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#related-events","title":"Related Events","text":"<p>The splice system call can be used to send data from one pipe to another pipe, and can be combined with vmsplice() to pass data from user space memory to a pipe. The sendfile() system call can also be used to pass the contents of a file to a socket or pipe.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vserver/","title":"vserver","text":""},{"location":"docs/events/builtin/syscalls/vserver/#intro","title":"Intro","text":"<p>vserver - Allows to control an isolated context within the same Linux kernel.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#description","title":"Description","text":"<p>The vserver syscall is a way to create isolated execution contexts within the same Linux kernel. It provides mechanisms such as users, process groups, or network rules to separate processes and resources, allowing to conserve or maximize system resources depending on their use. Furthermore, each vserver context can have their own root directory and assign access rights to files and folders within it.</p> <p>The syscall allows to create and delete vserver contexts, modify their properties or enter them. It also has the capability to list all existing vserver contexts and show their properties. The level of isolation that it provides is comparable to virtualization, with the advantage that it allows context switching directly from the kernel and does not require extra overhead for running a virtual machine.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - Controls the action to perform on the vserver context, it could be for creating, deleting, entering or modifying.</li> <li><code>arg1</code>:<code>char *</code>[U,TOCTOU] - A pointer to a user page containing the data for the operation defined by the <code>cmd</code> argument.</li> <li><code>size</code>:<code>size_t</code>[K] - The size of the data pointed by <code>arg1</code> in bytes.</li> <li><code>flags</code>:<code>int</code>[OPT] - Optional flags related to the provided data, could affect the interaction and output of the command. </li> </ul>"},{"location":"docs/events/builtin/syscalls/vserver/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vserver/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vserver/#personality","title":"<code>personality()</code>","text":""},{"location":"docs/events/builtin/syscalls/vserver/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vserver/#purpose","title":"Purpose","text":"<p>Personality() is hooked when using the vserver syscall in order to identify when is called to change the process execution context.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#example-use-case","title":"Example Use Case","text":"<p>One of the most common use cases of the vserver syscall, and one of the reasons why it was designed, is to provide deployment scalability by creating resource-isolated execution contexts. This use case allows to minimize deployment times and maximize resources while running multiple applications on the same machine that require different configurations.</p> <p>In addition, due to the level of isolation that it provides and the direct interaction with the kernel, it can also be used for security purposes. An example could be an application running in an isolated vserver context for which access rights can be set and traffic monitored by the vserver context.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#issues","title":"Issues","text":"<p>Using this syscall is resource-intensive as it requires a lot of resource management that is not always necessary. This can lead to less efficient usage of the system resources.</p> <p>In addition, there are several security issues related to vserver, as it does not provide hardware-level isolation, which can make it vulnerable against attacks aiming to escape a sandboxed environment.</p> <p>Finally, the data passed in the <code>arg1</code> argument should be checked carefully as it is passed from user space and is vulnerable to TOCTOU (time-of-check-time-of-use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#related-events","title":"Related Events","text":"<ul> <li>clone() - Clones the process into another one, useful when entering a vserver context.</li> <li>setns() - Changes the process's execution context, used when entering a vserver context.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/wait4/","title":"wait4","text":""},{"location":"docs/events/builtin/syscalls/wait4/#intro","title":"Intro","text":"<p>wait4 - wait for a process to change state.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#description","title":"Description","text":"<p>The <code>wait4()</code> system call suspends execution of the calling process until a  specified process has changed state, or until a signal is received, or until the  delay, as specified by an argument, has passed. This syscall allows to retrieve  information about the child process which changed from the provided parameters.  The main purpose of this call is to allow the process to wait for the termination  of a child that it created using one of the <code>fork()</code> syscall family functions.</p> <p>The <code>wait4()</code> syscall attempts to return the exit status of the process  specified by <code>pid</code>. If <code>pid</code> is equal to -1, it matches any process whose  process group ID is equal to the process group ID of the caller, or any process  when it is not a member of a process group.</p> <p>When <code>options</code> is set to 0, the status is returned immediately. If <code>pid</code> is equal  to 0, <code>wait4()</code> matches any process with the same process group ID as the caller.</p> <p>If <code>rusage</code> is not NULL, the resource usage of the terminating process and its  children is returned as part of <code>rusage</code>.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - the process ID of a child process for which status is  requested.</li> <li><code>wstatus</code>:<code>int*</code>[K] - the address of a buffer where the status of the  terminated process is to be stored.</li> <li><code>options</code>:<code>int</code>[K] - the options argument can be used to change the behavior of  <code>wait4()</code>.</li> <li><code>rusage</code>:<code>struct rusage*</code>[K] - a pointer to a <code>struct rusage</code> where the resource  usage information of the terminated process (and its children) will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/wait4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/wait4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/wait4/#sys_wait4","title":"sys_wait4","text":""},{"location":"docs/events/builtin/syscalls/wait4/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/wait4/#purpose","title":"Purpose","text":"<p>Hooked to trace information about a process and collect the return code value of  <code>wait4()</code>.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#example-use-case","title":"Example Use Case","text":"<p>The <code>wait4()</code> syscall is useful whenever processes need to be monitored. It can  be used to track the execution of a child process and react accordingly if it  fails. For example, an Alert rule can be triggered if the child process leaves  the system in an unexpected state. </p>"},{"location":"docs/events/builtin/syscalls/wait4/#issues","title":"Issues","text":"<p>It should be noted that <code>wait4()</code>'s status value is the same as that of the  <code>wait()</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#related-events","title":"Related Events","text":"<ul> <li><code>exit()</code></li> <li><code>wait()</code></li> <li><code>fork()</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/waitid/","title":"waitid","text":""},{"location":"docs/events/builtin/syscalls/waitid/#intro","title":"Intro","text":"<p>waitid - Wait for processes or process groups to change state</p>"},{"location":"docs/events/builtin/syscalls/waitid/#description","title":"Description","text":"<p><code>waitid</code> allows the caller to block until one of the caller's child processes changes state, or until a signal being caught by the caller is triggered. The caller may request information about the child process on which it blocked, its status and its resource usage data. If a process group ID is given, instead of a process ID, <code>waitid</code> will wait for any member of the given process group to change state. </p> <p>Due to time of check, time of use (TOCTOU), race conditions and similar issues, <code>waitid</code> should be used carefully as the process changing state may not be the one expected and other issues may arise.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#arguments","title":"Arguments","text":"<ul> <li><code>idtype</code>:<code>int</code>[K] - Type of ID to wait for. It can be <code>P_PID</code>, <code>P_PGID</code> or <code>P_ALL</code>. </li> <li><code>id</code>:<code>pid_t</code>[K] - Process or process group ID. </li> <li><code>infop</code>:<code>struct siginfo*</code>[U] - Const pointer to a <code>siginfo_t</code> struct. If non NULL, the status of the child process will be stored there. </li> <li><code>options</code>:<code>int</code>[K] - Value can have the <code>WEXITED</code> or <code>WNOHANG</code> flag set, amongst others.</li> <li><code>rusage</code>:<code>struct rusage*</code>[U] - Pointer to a <code>rusage_t</code> structure. If non NULL the resource usage data of the process on which it blocked will be stored there. </li> </ul>"},{"location":"docs/events/builtin/syscalls/waitid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/waitid/#sys_wait4","title":"sys_wait4","text":""},{"location":"docs/events/builtin/syscalls/waitid/#type","title":"Type","text":"<p>Kprobes.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#purpose","title":"Purpose","text":"<p>Trace when a <code>waitid</code> syscall is executed.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#example-use-case","title":"Example Use Case","text":"<p><code>waitid</code> can be used when a child process must complete a certain task before continuing execution. The calling process can wait for the child to change its state using <code>waitid</code>, for example when the child terminates.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#issues","title":"Issues","text":"<p>Due to TOCTOU-like issues, <code>waitid</code> should be used with extra care as the process changing state may not be the one expected.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#related-events","title":"Related Events","text":"<ul> <li>waitpid</li> <li>wait4 </li> <li>wait</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/","title":"waitpid","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#intro","title":"Intro","text":"<p>waitpid - wait for a process to change its state</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#description","title":"Description","text":"<p>The waitpid() system call suspends execution of the calling process until a child process specified by pid argument has changed state. By giving the WNOHANG or WUNTRACED options to waitpid() call, the calling process can specify that it should return immediately if there is no process state change. The status pointer argument may be specified as NULL.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - Specifies a set of child processes for which to wait.</li> <li><code>status</code>:<code>int*</code>[U] - A pointer to an integer into which status information about the child process will be stored. This can be NULL if the calling process is not interested in this information.</li> <li><code>options</code>:<code>int</code> - May be specified to include WNOHANG or WUNTRACED, which modify the behavior of the waitpid() system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitpid/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitpid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#do_wait","title":"do_wait()","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#purpose","title":"Purpose","text":"<p>Used to monitor usage of waitpid in the system.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor and detect when a process with a specified pid has changed state. </p>"},{"location":"docs/events/builtin/syscalls/waitpid/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#related-events","title":"Related Events","text":"<ul> <li>fork()</li> <li>execve()</li> <li>signal()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/write/","title":"write","text":""},{"location":"docs/events/builtin/syscalls/write/#intro","title":"Intro","text":"<p>write - a syscall for writing data to a specified file descriptor</p>"},{"location":"docs/events/builtin/syscalls/write/#description","title":"Description","text":"<p>The write syscall is used to write data to a specified file descriptor. It takes three arguments: a file descriptor <code>fd</code>, a pointer to the data <code>buf</code> and its size <code>count</code>. It returns the number of bytes written, or -1 if there was an error. </p> <p>Writing more bytes than the buffer size may cause a buffer overflow and should be avoided. Data should also be checked before writing to make sure that it is valid. It is important to note that the write syscall is non-atomic and may be interrupted by signals.</p>"},{"location":"docs/events/builtin/syscalls/write/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor to write the data to</li> <li><code>buf</code>:<code>void*</code>[K, U] - pointer to the data to be written</li> <li><code>count</code>:<code>size_t</code>[K] - number of bytes to write from the buffer </li> </ul>"},{"location":"docs/events/builtin/syscalls/write/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/write/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/write/#sys_write","title":"sys_write","text":""},{"location":"docs/events/builtin/syscalls/write/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/write/#purpose","title":"Purpose","text":"<p>To collect data from all write syscall invocation.</p>"},{"location":"docs/events/builtin/syscalls/write/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use the write syscall to write data to a logfile.</p>"},{"location":"docs/events/builtin/syscalls/write/#issues","title":"Issues","text":"<p>If the buffer size is larger than the specified count, the write syscall may cause a buffer overflow.</p>"},{"location":"docs/events/builtin/syscalls/write/#related-events","title":"Related Events","text":"<ul> <li>read - allows a file descriptor to be read into a buffer</li> <li>open - allows a file to be opened and set a file descriptor </li> <li>close - closes a previously opened file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/writev/","title":"writev","text":""},{"location":"docs/events/builtin/syscalls/writev/#intro","title":"Intro","text":"<p>writev - atomically write data from multiple buffers to a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/writev/#description","title":"Description","text":"<p>The <code>writev()</code> system call writes data from multiple buffers, as specified by <code>iov</code> into a file descriptor <code>fd</code>. The number of buffers to write is given in <code>iovcnt</code>. The <code>iov</code> is a pointer to a list of <code>struct iovec</code>s, which define multiple non-contiguous buffers. Each <code>struct iovec</code> contains a starting address and length of a data buffer. <code>writev()</code> atomicly writes all of the data in the given buffers. If all the buffers are written then the <code>writev()</code> system call returns the total number of bytes written to the file descriptor <code>fd</code>. </p>"},{"location":"docs/events/builtin/syscalls/writev/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - A file descriptor that identifies the file into which <code>writev()</code> will write data.</li> <li><code>iov</code>:<code>const struct iovec*</code>[K,U] - A pointer to the <code>struct iovec</code> that defines  the multiple non-contiguous buffers.</li> <li><code>iovcnt</code>:<code>int</code>[OPT,K] - The number of buffers to write, as specified by <code>iov</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/writev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/writev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/writev/#sys_writev","title":"sys_writev","text":""},{"location":"docs/events/builtin/syscalls/writev/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/writev/#purpose","title":"Purpose","text":"<p>Hooked to trace the sys_writev syscall.</p>"},{"location":"docs/events/builtin/syscalls/writev/#example-use-case","title":"Example Use Case","text":"<p><code>writev()</code> is often used when writing to a socket. For example, when sending data to a web server the data is usually split into multiple chunks and <code>writev()</code> is used to write the data in a single operation, atomically.</p>"},{"location":"docs/events/builtin/syscalls/writev/#issues","title":"Issues","text":"<p>There are no known issues with the <code>writev()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/writev/#related-events","title":"Related Events","text":"<ul> <li>readv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/custom/golang/","title":"Golang Signatures","text":"<p>There are 2 ways you can get your own golang signatures working with tracee.</p> <ol> <li> <p>Built-In Golang signatures</p> <p>Tip</p> <p>This is the preferred way to get your own golang signatures integrated into Tracee, as you will find in the next part of this page, but it needs a better end-user experience (being worked).</p> <p>In order to get your golang signature compiled with tracee, you can create a file called <code>signatures/golang/signature_example.go</code> and place the following code in it:</p> <p>Signature</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/aquasecurity/tracee/signatures/helpers\"\n    \"github.com/aquasecurity/tracee/types/detect\"\n    \"github.com/aquasecurity/tracee/types/protocol\"\n    \"github.com/aquasecurity/tracee/types/trace\"\n)\n\ntype signatureExample struct {\n    cb detect.SignatureHandler\n}\n\nfunc (sig *signatureExample) Init(ctx detect.SignatureContext) error {\n    sig.cb = ctx.Callback\n\n    return nil\n}\n\nfunc (sig *signatureExample) GetMetadata() (\n    detect.SignatureMetadata,\n    error,\n) {\n    return detect.SignatureMetadata{\n        ID:          \"Mine-0.1.0\",\n        Version:     \"0.1.0\",\n        Name:        \"My Own Signature\",\n        EventName:   \"mine\",\n        Description: \"My Own Signature Detects Stuff\",\n    }, nil\n}\n\nfunc (sig *signatureExample) GetSelectedEvents() (\n    []detect.SignatureEventSelector,\n    error,\n) {\n\n    return []detect.SignatureEventSelector{\n        {Source: \"tracee\", Name: \"openat\"},\n        {Source: \"tracee\", Name: \"execve\"},\n    }, nil\n}\n\nfunc (sig *signatureExample) OnEvent(event protocol.Event) error {\n    switch e := event.Payload.(type) {\n    case trace.Event:\n        if e.ArgsNum == 0 {\n            return nil\n        }\n\n        switch e.EventName {\n        case \"openat\", \"execve\":\n            arg, err := helpers.GetTraceeArgumentByName(e, \"pathname\", helpers.GetArgOps{DefaultArgs: false})\n            if err != nil {\n                return err\n            }\n\n            if s, ok := arg.Value.(string); ok {\n                if strings.Contains(s, \"/etc/passwd\") {\n                    m, _ := sig.GetMetadata()\n\n                    found := detect.Finding{\n                        Event:       event,\n                        SigMetadata: m,\n                    }\n\n                    sig.cb(found)\n                }\n            }\n        }\n    default:\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    return nil\n}\n\nfunc (sig *signatureExample) OnSignal(s detect.Signal) error {\n    return nil\n}\n\nfunc (sig *signatureExample) Close() {}\n</code></pre> <p>Then, edit <code>signatures/golang/export.go</code> and place your new signature there:</p> <pre><code>var ExportedSignatures = []detect.Signature{\n    ...\n    &amp;signatureExample{},\n}\n</code></pre> <p>Follow instructions on how to build Tracee and you will get your new signature available to use. You may even select only the signatures you created:</p> <pre><code>sudo ./dist/tracee \\\n    --output json \\\n    --events mine\n</code></pre> <pre><code>{\"timestamp\":1680191445996958642,\"threadStartTime\":1680191445994222553,\"processorId\":4,\"processId\":329031,\"cgroupId\":10793,\"threadId\":329031,\"parentProcessId\":45580,\"hostProcessId\":329031,\"hostThreadId\":329031,\"hostParentProcessId\":45580,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"zsh\",\"hostName\":\"hb\",\"container\":{},\"kubernetes\":{},\"eventId\":\"6030\",\"eventName\":\"mine\",\"matchedPolicies\":[\"\"],\"argsNum\":0,\"returnValue\":11,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"0.1.0\",\"Description\":\"My Own Signature Detects Stuff\",\"Tags\":null,\"Properties\":{\"signatureID\":\"Mine-0.1.0\",\"signatureName\":\"My Own Signature\"}}}\n</code></pre> <p>Be creative! You can create signatures that would do pretty much anything! Examples of such signatures would: for every X event, connect to a cached external data-source and return a positive detection for cases A, B or C.</p> </li> <li> <p>Create a golang signature plugin and dynamically load it during runtime</p> <p>Attention</p> <p>Eventually you will find out that Golang Plugins aren't very useful if you consider all the problems that emerge from using it:</p> <ol> <li> <p>Can't use different go versions (need to compile the go plugin    with the exact same version that was used to build Tracee).</p> </li> <li> <p>Both Tracee and your golang plugin signature must be built with the    exact same GOPATH or you will get a \"plugin was built with a    different version of package XXX\" error.</p> </li> <li> <p>Any dependency you have in your plugin should be of the same    version with the dependencies of Tracee.</p> </li> <li> <p>Compiling tracee statically is sometimes useful to have a complete    portable eBPF tracing/detection solution. One good example when    statically compiling tracee is a good idea is to have a single    binary capable of running in GLIBC (most of them) and MUSL (Alpine)    powered Linux distros.</p> </li> </ol> <p>At the end, creating a golang signature plugin won't have the practical effects as a plugin mechanism should have, so it is preferred to have built-in golang signatures (re)distributed with newer binaries (when you need to add/remove signatures from your environment) FOR NOW.</p> </li> </ol>"},{"location":"docs/events/custom/overview/","title":"Custom Events","text":"<p>Tracee comes with lots of events, but you can extend it with events specific to your use case. There are two ways to extend Tracee with your own events:</p> <ol> <li>Go</li> <li>Rego</li> </ol> <p>Once you created your own event, you can load it using the <code>signatures-dir</code> flag. For example, if you created your event in the path <code>/tmp/myevents</code> to use it you would start tracee with:</p> <pre><code>tracee --signatures-dir=/tmp/myevents\n</code></pre> <p>Tip</p> <p>Tracee also uses the custom events to add a few events, if you pass your own directory for <code>signatures-dir</code> you will not load the tracee signatures, to avoid such problems, you can either place your own events under the same directory of the tracee custom events, or pass multiple directories for example: <pre><code>tracee --signatures-dir=/tmp/myevents --signatures-dir=./dist/signatures\n</code></pre></p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"docs/events/custom/rego/","title":"Rego Signatures","text":"<p>Tip</p> <p>Differently than golang built-in signatures, with Rego signatures you are able to add and/or remove signatures to Tracee without the need of recompiling it (or re-distributing the binary) BUT it may come with a performance price to pay.</p> <p>In order to create your own Rego signature you need to create a <code>.rego</code> file that has the following Rego Rules (now, in this context, rules are Rego's language constructs):</p> <p>rego_metadoc</p> <p>A document rule that defines the rule's metadata.</p> <p>Tracee_selected_events</p> <p>A set rule that defines the event selectors.</p> <p>Tracee_match</p> <p>A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\".</p> <p>Signature</p> <pre><code>package tracee.Mine\n\nimport data.tracee.helpers\n\n__rego_metadoc__ := {\n    \"id\": \"Mine-0.1.0\",\n    \"version\": \"0.1.0\",\n    \"name\": \"My Own Signature\",\n    \"eventName\": \"mine\",\n    \"description\": \"My Own Signature Detects Stuff\",\n}\n\neventSelectors := [\n    {\n        \"source\": \"tracee\",\n        \"name\": \"openat\",\n    },\n    {\n        \"source\": \"tracee\",\n        \"name\": \"execve\",\n    },\n]\n\ntracee_selected_events[eventSelector] {\n    eventSelector := eventSelectors[_]\n}\n\ntracee_match {\n    input.eventName == \"openat\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n\ntracee_match {\n    input.eventName == \"execve\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n</code></pre> <p>After placing your <code>signature_example.rego</code> inside <code>signatures/rego</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>sudo ./dist/tracee \\\n    --output json\n    --signatures-dir signatures/rego \\\n    --events mine\n</code></pre> <pre><code>{\"timestamp\":1680190419485136510,\"threadStartTime\":1680190419369780383,\"processorId\":4,\"processId\":320908,\"cgroupId\":16273,\"threadId\":320908,\"parentProcessId\":1635,\"hostProcessId\":320908,\"hostThreadId\":320908,\"hostParentProcessId\":1635,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"terminator\",\"hostName\":\"hb\",\"container\":{},\"kubernetes\":{},\"eventId\":\"6000\",\"eventName\":\"mine\",\"matchedPolicies\":[\"\"],\"argsNum\":0,\"returnValue\":10,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"0.1.0\",\"Description\":\"My Own Signature Detects Stuff\",\"Tags\":null,\"Properties\":{\"signatureID\":\"Mine-0.1.0\",\"signatureName\":\"My Own Signature\"}}}\n</code></pre> <p>See signatures/rego for example Rego signatures.</p>"},{"location":"docs/flags/cache.1/","title":"TRACEE-CACHE","text":""},{"location":"docs/flags/cache.1/#name","title":"NAME","text":"<p>tracee --cache - Select different cache types for the event pipeline queueing</p>"},{"location":"docs/flags/cache.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --cache [none|cache-type=&lt;type&gt;] [--cache mem-cache-size=&lt;size&gt;]</p>"},{"location":"docs/flags/cache.1/#description","title":"DESCRIPTION","text":"<p>The --cache flag allows you to select different cache types for the event pipeline queueing.</p> <p>Possible options for cache-type are:</p> <ul> <li>none: No event caching in the pipeline (default) - similar to --cache none.</li> <li>mem: Enables caching events in memory.</li> </ul> <p>If cache-type=mem is chosen, you can also set the memory cache size in megabytes (MB) using the mem-cache-size option. This option only works when cache-type=mem.</p>"},{"location":"docs/flags/cache.1/#examples","title":"EXAMPLES","text":"<ul> <li>To cache events in memory using the default values, use the following flag:</li> </ul> <pre><code>--cache cache-type=mem\n</code></pre> <ul> <li>To cache events in memory and set the memory cache size to 1024 MB, use the following flag:</li> </ul> <pre><code>--cache cache-type=mem --cache mem-cache-size=1024\n</code></pre> <ul> <li>To disable event caching in the pipeline, use the following flag:</li> </ul> <pre><code>--cache none\n</code></pre>"},{"location":"docs/flags/capabilities.1/","title":"TRACEE-CAPABILITIES","text":""},{"location":"docs/flags/capabilities.1/#name","title":"NAME","text":"<p>tracee --capabilities - Opt out from dropping capabilities by default or set specific ones</p>"},{"location":"docs/flags/capabilities.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --capabilities [&lt;bypass=[true|false]&gt; | &lt;add=cap1(,cap2...)&gt; | &lt;drop=cap1(,cap2...)&gt;] ... [--capabilities [&lt;add=cap1(,cap2...)&gt; | &lt;drop=cap1(,cap2...)&gt;] ...]</p>"},{"location":"docs/flags/capabilities.1/#description","title":"DESCRIPTION","text":"<p>The --capabilities flag allows you to control the dropping of capabilities during execution time or set specific capabilities.</p> <p>Possible options:</p> <ul> <li>bypass=[true|false]: Keep all capabilities during execution time. Setting bypass=true will opt out from dropping any capabilities.</li> <li>add=cap1(,cap2...): Add specific capabilities to the \"required\" capabilities ring. You can provide multiple capability names separated by commas.</li> <li>drop=cap1(,cap2...): Drop specific capabilities from the \"required\" capabilities ring. You can specify multiple capability names separated by commas.</li> </ul> <p>Please note that the available capabilities will depend on the running system. For the list of capabilities available on your system, see the list-caps command.</p>"},{"location":"docs/flags/capabilities.1/#examples","title":"EXAMPLES","text":"<ul> <li>To keep all capabilities during execution time, use the following flag:</li> </ul> <pre><code>--capabilities bypass=true\n</code></pre> <ul> <li>To add specific capabilities (e.g., cap_kill and cap_syslog) to the \"required\" capabilities ring, use the following flag:</li> </ul> <pre><code>--capabilities add=cap_kill,cap_syslog\n</code></pre> <ul> <li>To drop a specific capability (e.g., cap_chown) from the \"required\" capabilities ring, use the following flag:</li> </ul> <pre><code>--capabilities drop=cap_chown\n</code></pre> <p>Please refer to the documentation for more information on environment capabilities.</p>"},{"location":"docs/flags/capture.1/","title":"TRACEE-CAPTURE","text":""},{"location":"docs/flags/capture.1/#name","title":"NAME","text":"<p>tracee --capture - Capture artifacts that were written, executed, or found to be suspicious</p>"},{"location":"docs/flags/capture.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --capture &lt;[artifact:]capture-option[=value]&gt; ...</p> <p>tracee --capture &lt;network&gt; [--capture [pcap:option1(,option2...)|pcap-options:option|pcap-snaplen:size]] ...</p>"},{"location":"docs/flags/capture.1/#description","title":"DESCRIPTION","text":"<p>The --capture flag allows you to capture artifacts that were written, executed, or found to be suspicious during the execution of Tracee. The captured artifacts will appear in the 'output-path' directory.</p> <p>Possible capture options:</p> <ul> <li>[artifact:]write[=/path/prefix*]: Capture written files. You can provide a filter to only capture file writes whose path starts with a certain prefix (up to 50 characters). Up to 3 filters can be given.</li> <li>[artifact:]read[=/path/prefix*]: Capture read files. You can provide a filter to only capture file reads whose path starts with a certain prefix (up to 50 characters). Up to 3 filters can be given.</li> <li>[artifact:]exec: Capture executed files.</li> <li>[artifact:]module: Capture loaded kernel modules.</li> <li>[artifact:]bpf: Capture loaded BPF programs bytecode.</li> <li>[artifact:]mem: Capture memory regions that had write+execute (w+x) protection and then changed to execute (x) only.</li> <li>[artifact:]network: Capture network traffic. Only TCP/UDP/ICMP protocols are currently supported.</li> </ul>"},{"location":"docs/flags/capture.1/#file-capture-filters","title":"File Capture Filters","text":"<p>Files captured upon read/write can be filtered to catch only specific IO operations. The different filter types have a logical 'AND' between them but a logical 'OR' between filters of the same type. The filter format is as follows: &lt;read/write&gt;:&lt;filter-type&gt;=&lt;filter-value&gt;</p> <p>Filter types:</p> <ul> <li>path: A filter for the file path prefix (up to 50 characters). Up to 3 filters can be given. Identical to using '&lt;read/write&gt;=/path/prefix*'.</li> <li>type: A file type from the following options: 'regular', 'pipe', and 'socket'.</li> <li>fd: The file descriptor of the file. Can be one of the three standards: 'stdin', 'stdout', and 'stderr'.</li> </ul>"},{"location":"docs/flags/capture.1/#network-capture-notes","title":"Network Capture Notes","text":"<ul> <li>Pcap Files:</li> <li>If you only specify --capture network, you will have a single file with all network traffic.</li> <li> <p>You can use pcap:xxx,yyy to have more than one pcap file, split by different means.</p> </li> <li> <p>Pcap Options:</p> </li> <li>If you do not specify pcap-options (or set to none), you will capture ALL network traffic into your pcap files.</li> <li> <p>If you specify pcap-options:filtered, events being traced will define what network traffic will be captured.</p> </li> <li> <p>Snap Length:</p> </li> <li>If you do not specify a snaplen, the default is headers only (incomplete packets in tcpdump).</li> <li>If you specify max as snaplen, you will get the full contents of each packet (pcap files will be large).</li> <li>If you specify headers as snaplen, you will only get L2/L3 headers in captured packets.</li> <li>If you specify headers but trace for net_packet_dns events, the L4 DNS header will be captured.</li> <li>If you specify headers but trace for net_packet_http events, only L2/L3 headers will be captured.</li> </ul>"},{"location":"docs/flags/capture.1/#examples","title":"EXAMPLES","text":""},{"location":"docs/flags/capture.1/#file-capture","title":"File capture","text":"<ul> <li>To capture executed files into the default output directory, use the following flag:</li> </ul> <pre><code>--capture exec\n</code></pre> <ul> <li>To capture executed files into a specific directory, clear the directory before starting, use the following flags:</li> </ul> <pre><code>--capture exec --capture dir:/my/dir --capture clear-dir\n</code></pre> <ul> <li>To capture files that were written into anywhere under /usr/bin/ or /etc/, use the following flags:</li> </ul> <pre><code>--capture write=/usr/bin/* --capture write=/etc/*\n</code></pre> <ul> <li>To capture file writes to socket files that are the 'stdout' of the writing process, use the following flag:</li> </ul> <pre><code>--capture write:type=socket --capture write:fd=stdout\n</code></pre>"},{"location":"docs/flags/capture.1/#network-capture","title":"Network Capture","text":"<ul> <li>To capture network traffic, use the following flag:</li> </ul> <pre><code>--capture network\n</code></pre> <ul> <li>To capture network traffic and save separate pcap files for processes and commands, use the following flag:</li> </ul> <pre><code>--capture network --capture pcap:process,command\n</code></pre> <ul> <li>To capture network traffic and save pcap files containing only traced/filtered packets, use the following flag:</li> </ul> <pre><code>--capture network --capture pcap-options:filtered\n</code></pre> <ul> <li>To capture network traffic and set the captured payload from each packet to 1KB, use the following flag:</li> </ul> <pre><code>--capture network --capture pcap-snaplen:1kb\n</code></pre> <ul> <li>To capture network traffic and save pcap files for containers and commands, use the following flag:</li> </ul> <pre><code>--capture network --capture pcap:container,command\n</code></pre>"},{"location":"docs/flags/config.1/","title":"TRACEE-CONFIG","text":""},{"location":"docs/flags/config.1/#name","title":"NAME","text":"<p>tracee --config - Define global configuration options for tracee</p>"},{"location":"docs/flags/config.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --config &lt;file&gt;</p>"},{"location":"docs/flags/config.1/#description","title":"DESCRIPTION","text":"<p>The --config flag allows you to define global configuration options (flags) for tracee. It expects a file in YAML or JSON format, among others (see documentation).</p> <p>All flags can be set in the config file, except for the following, which are reserved only for the CLI:</p> <ul> <li>--config: This flag itself is reserved for the CLI and should not be set in the config file.</li> <li>--capture</li> <li>--policy</li> <li>--scope</li> <li>--event</li> </ul> <p>Please refer to the documentation for more information on the file format and available configuration options.</p>"},{"location":"docs/flags/containers.1/","title":"TRACEE-CRI","text":""},{"location":"docs/flags/containers.1/#name","title":"NAME","text":"<p>tracee --cri - Select container runtimes to connect to for container events enrichment</p>"},{"location":"docs/flags/containers.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --cri &lt;[crio|containerd|docker|podman]:socket&gt; [--cri ...] ...</p>"},{"location":"docs/flags/containers.1/#description","title":"DESCRIPTION","text":"<p>By default, if no flag is passed, Tracee will automatically detect installed runtimes by going through known runtime socket paths, looking for the following paths:</p> <ol> <li>Docker:     <code>/var/run/docker.sock</code></li> <li>Containerd: <code>/var/run/containerd/containerd.sock</code></li> <li>CRI-O:      <code>/var/run/crio/crio.sock</code></li> <li>Podman:     <code>/var/run/podman/podman.sock</code></li> </ol> <p>If runtimes are specified using the --cri flag, only the ones passed through the flags will be connected to through the provided socket file path.</p> <p>Supported runtimes are:</p> <ol> <li>CRI-O (crio, cri-o)</li> <li>Containerd (containerd)</li> <li>Docker (docker)</li> <li>Podman (podman)</li> </ol>"},{"location":"docs/flags/containers.1/#example","title":"EXAMPLE","text":"<ul> <li>To connect to CRI-O using the socket file path <code>/var/run/crio/crio.sock</code>, use the following flag:</li> </ul> <pre><code>--cri crio:/var/run/crio/crio.sock\n</code></pre> <p>Please refer to the documentation for more information on container events enrichment.</p>"},{"location":"docs/flags/events.1/","title":"TRACEE-EVENTS","text":""},{"location":"docs/flags/events.1/#name","title":"NAME","text":"<p>tracee --events - Select which events to trace</p>"},{"location":"docs/flags/events.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --events [&lt;event-name1(,[-]event-name2...)&gt; | &lt;[-]event-name1(,set1...)&gt; | &lt;set1(,[-]event-name1,[-]event-name2...)&gt; | &lt;event1.args.arg-field[=|!=]value&gt; | &lt;event1.retval[=|!=|&lt;|&gt;|&lt;=|&gt;=]value&gt; | &lt;event1.scope.field[=|!=|&lt;|&gt;|&lt;=|&gt;=]value&gt; | &lt;event.scope.container&gt;] ...</p>"},{"location":"docs/flags/events.1/#description","title":"DESCRIPTION","text":"<p>The --events flag allows you to select which events to trace by defining filters.</p>"},{"location":"docs/flags/events.1/#filters","title":"FILTERS","text":"<ul> <li> <p>Event or set name: Select specific events using 'event-name1,event-name2...' or predefined event sets using 'event_set_name1,event_set_name2...'. To exclude events, prepend the event name with a dash '-': '-event-name'.</p> </li> <li> <p>Event arguments: Filter events based on their arguments using 'event-name.args.event_arg'. The event argument expression follows the syntax of a string expression.</p> </li> <li> <p>Event return value: Filter events based on their return value using 'event-name.retval'. The event return value expression follows the syntax of a numerical expression.</p> </li> <li> <p>Event scope fields: Filter events based on the non-argument fields defined in the trace.Event struct using 'event-name.scope.field'. Refer to the json tags in the trace.Event struct located in the types/trace package for the correct field names, and the event filtering section in the documentation for a full list.</p> </li> </ul>"},{"location":"docs/flags/events.1/#filter-expression","title":"FILTER EXPRESSION","text":"<p>Filter expressions can be defined to operate on event options or process metadata. Only events that match all filter expressions will be traced.</p> <p>Multiple flags are combined with AND logic, while multiple values within a single flag are combined with OR logic when using the equals operator '='. Multiple values can be specified using ','.</p>"},{"location":"docs/flags/events.1/#numerical-expression-operators","title":"NUMERICAL EXPRESSION OPERATORS","text":"<p>'=', '!=', '&lt;', '&gt;', '&lt;=', '&gt;='</p> <p>Available for:</p> <ul> <li>return value</li> <li>scope fields</li> </ul> <p>NOTE: Expressions containing '&lt;' or '&gt;' tokens must be escaped!</p>"},{"location":"docs/flags/events.1/#string-expression-operators","title":"STRING EXPRESSION OPERATORS","text":"<p>'=', '!='</p> <p>Available for:</p> <ul> <li>event arguments</li> <li>return value</li> <li>scope fields</li> </ul> <p>Strings can be compared as a prefix if ending with '*', or as a suffix if starting with '*'.</p> <p>NOTE: Expressions containing '*' token must be escaped!</p>"},{"location":"docs/flags/events.1/#exclusion-operator-prepended","title":"EXCLUSION OPERATOR (PREPENDED)","text":"<p>'-'</p> <p>Available only for:</p> <ul> <li>event names</li> </ul>"},{"location":"docs/flags/events.1/#examples","title":"EXAMPLES","text":"<ul> <li>To trace only 'execve' and 'open' events, use the following flag:</li> </ul> <pre><code>--events execve,open\n</code></pre> <ul> <li>To trace only events prefixed by \"open\", use the following flag:</li> </ul> <pre><code>--events 'open*'\n</code></pre> <ul> <li>To exclude events prefixed by \"open\" or \"dup\", use the following flag:</li> </ul> <pre><code>--events '-open*,-dup*'\n</code></pre> <ul> <li>To trace all file-system related events, use the following flag:</li> </ul> <pre><code>--events fs\n</code></pre> <ul> <li>To trace all file-system related events, but not 'open' or 'openat', use the following flag:</li> </ul> <pre><code>--events fs --events '-open,-openat'\n</code></pre> <ul> <li>To trace only 'close' events that have 'fd' equal to 5, use the following flag:</li> </ul> <pre><code>--events close.args.fd=5\n</code></pre> <ul> <li>To trace only 'openat' events that have 'pathname' prefixed by '/tmp', use the following flag:</li> </ul> <pre><code>--events openat.args.pathname='/tmp*'\n</code></pre> <ul> <li>To trace only 'openat' events that have 'pathname' suffixed by 'shadow', use the following flag:</li> </ul> <pre><code>--events openat.args.pathname='*shadow'\n</code></pre> <ul> <li>To exclude 'openat' events that have 'pathname' equal to '/tmp/1' or '/bin/ls', use the following flag:</li> </ul> <pre><code>--events openat.args.pathname!=/tmp/1,/bin/ls\n</code></pre> <ul> <li>To trace only 'openat' events that have 'processName' equal to 'ls', use the following flag:</li> </ul> <pre><code>--events openat.scope.processName=ls\n</code></pre> <ul> <li>To trace only 'security_file_open' events coming from a container, use the following flag:</li> </ul> <pre><code>--events security_file_open.scope.container\n</code></pre>"},{"location":"docs/flags/log.1/","title":"TRACEE-LOG","text":""},{"location":"docs/flags/log.1/#name","title":"NAME","text":"<p>tracee --log - Control logger options - aggregation and level priority</p>"},{"location":"docs/flags/log.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --log aggregate[:flush-interval] | &lt;debug|info|warn|error|panic&gt; | file:/path/to/file | filter:[msg=&lt;value,...&gt;;regex=&lt;value,...&gt;;pkg=&lt;value,...&gt;;file=&lt;value,...&gt;;lvl=&lt;value,...&gt;;libbpf] | filter-out:[msg=&lt;value,...&gt;;regex=&lt;value,...&gt;;pkg=&lt;value,...&gt;;file=&lt;value,...&gt;;lvl=&lt;value,...&gt;;libbpf]</p>"},{"location":"docs/flags/log.1/#description","title":"DESCRIPTION","text":"<p>The --log flag allows you to control logger options for the tool.</p> <p>Possible log options:</p> <ul> <li> <p>aggregate[:flush-interval]: Turns log aggregation on, delaying output with an optional interval (default: 3s). The flush-interval can be specified in seconds (s) or minutes (m).</p> </li> <li> <p>&lt;debug|info|warn|error|panic&gt;: Sets the log level. The default log level is 'info'.</p> </li> <li> <p>file:/path/to/file: Writes the logs to the specified file. If the file exists, it will be created or trimmed.</p> </li> <li> <p>filter:&lt;option;...&gt;: Filters in logs that match the specified option values. Multiple filter options can be provided, separated by semicolons.</p> </li> <li> <p>filter-out:&lt;option;...&gt;: Filters out logs that match the specified option values. Multiple filter options can be provided, separated by semicolons.</p> </li> </ul> <p>Filter options:</p> <ul> <li> <p>msg=&lt;value,...&gt;: Filters logs that have the message containing any of the specified values.</p> </li> <li> <p>regex=&lt;value,...&gt;: Filters logs that match the specified regular expression in the message.</p> </li> <li> <p>pkg=&lt;value,...&gt;: Filters logs that originate from the specified package.</p> </li> <li> <p>file=&lt;value,...&gt;: Filters logs that originate from the specified file.</p> </li> <li> <p>lvl=&lt;value,...&gt;: Filters logs that are of the specified level.</p> </li> <li> <p>libbpf: Filters logs that originate from libbpf.</p> </li> </ul>"},{"location":"docs/flags/log.1/#examples","title":"EXAMPLES","text":"<ul> <li>To output debug level logs, use the following flag:</li> </ul> <pre><code>--log debug\n</code></pre> <ul> <li>To output aggregated debug level logs every 3 seconds (default), use the following flag:</li> </ul> <pre><code>--log debug --log aggregate\n</code></pre> <ul> <li>To output aggregated logs every 5 seconds, use the following flag:</li> </ul> <pre><code>--log aggregate:5s\n</code></pre> <ul> <li>To output debug level logs to <code>/tmp/tracee.log</code>, use the following flag:</li> </ul> <pre><code>--log debug --log file:/tmp/tracee.log\n</code></pre> <ul> <li>To filter in logs that have either 'foo' or 'bar' in the message, are from the 'core' package, and are of 'error' level, use the following flag:</li> </ul> <pre><code>--log filter:'msg=foo,bar;pkg=core;lvl=error'\n</code></pre> <ul> <li>To filter out logs that have either 'foo' or 'bar' in the message, are from the 'core' package, and are of 'error' level, use the following flag:</li> </ul> <pre><code>--log filter-out:'msg=foo,bar;pkg=core;lvl=error'\n</code></pre> <ul> <li>To filter in logs that have either 'foo' or 'bar' in the message and, based on that result, filter out logs that are from the 'core' package, use the following flag:</li> </ul> <pre><code>--log filter:msg=foo,bar --log filter-out:pkg=core\n</code></pre> <ul> <li>To filter out logs that originate from the '/pkg/cmd/flags/logger.go' file, use the following flag:</li> </ul> <pre><code>--log filter-out:file=/pkg/cmd/flags/logger.go\n</code></pre> <ul> <li>To filter in logs that have messages matching the regex '^foo', use the following flag:</li> </ul> <pre><code>--log filter:regex='^foo'\n</code></pre> <ul> <li>To filter in logs that originate from libbpf, use the following flag:</li> </ul> <pre><code>--log filter:libbpf\n</code></pre>"},{"location":"docs/flags/output.1/","title":"TRACEE-OUTPUT","text":""},{"location":"docs/flags/output.1/#name","title":"NAME","text":"<p>tracee --output - Control how and where output is printed</p>"},{"location":"docs/flags/output.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --output &lt;format[:file,...]&gt; | gotemplate=template[:file,...] | forward:url | webhook:url | option:{stack-addresses,exec-env,relative-time,exec-hash[={inode,dev-inode,digest-inode}],parse-arguments,parse-arguments-fds,sort-events} ...</p>"},{"location":"docs/flags/output.1/#description","title":"DESCRIPTION","text":"<p>The --output flag allows you to control how and where the output is printed.</p> <p>Format options:</p> <ul> <li> <p>table[:/path/to/file,...]: Output events in table format. The default path to the file is stdout. Multiple file paths can be specified, separated by commas.</p> </li> <li> <p>table-verbose[:/path/to/file,...]: Output events in table format with extra fields per event. The default path to the file is stdout. Multiple file paths can be specified, separated by commas.</p> </li> <li> <p>json[:/path/to/file,...]: Output events in JSON format. The default path to the file is stdout. Multiple file paths can be specified, separated by commas.</p> </li> <li> <p>gotemplate=/path/to/template[:/path/to/file,...]: Output events formatted using a given Go template file. The default path to the file is stdout. Multiple file paths can be specified, separated by commas.</p> </li> <li> <p>none: Ignore the stream of events output. This is usually used with the --capture flag.</p> </li> </ul> <p>Fluent Forward options:</p> <ul> <li>forward:url: Send events in JSON format using the Forward protocol to a Fluent receiver. Specify the URL of the Fluent receiver.</li> </ul> <p>Webhook options:</p> <ul> <li>webhook:url: Send events in JSON format to the specified webhook URL.</li> </ul> <p>Other options:</p> <ul> <li> <p>option:{stack-addresses,exec-env,relative-time,exec-hash,parse-arguments,sort-events}: Augment output according to the given options. The default is none. Multiple options can be specified, separated by commas.</p> </li> <li> <p>stack-addresses: Include stack memory addresses for each event.</p> </li> <li>exec-env: When tracing execve/execveat, show the environment variables that were used for execution.</li> <li>relative-time: Use relative timestamp instead of wall timestamp for events.</li> <li>exec-hash: When tracing some file related events, show the file hash (sha256).<ul> <li>Affected events: sched_process_exec, shared_object_loaded</li> <li>inode option recalculates the file hash if the inode's creation time (ctime) differs, which can occur in different namespaces even for identical inode. This option is performant, but not recommended and should only be used if container enrichment can't be enabled for digest-inode, and if performance is preferred over correctness.</li> <li>dev-inode (default) option generally offers better performance compared to the inode option, as it bypasses the need for recalculation by associating the creation time (ctime) with the device (dev) and inode pair. It's recommended if correctness is preferred over performance without container enrichment.</li> <li>digest-inode\" option is the most efficient, as it keys the hash to a pair consisting of the container image digest and inode. This approach, however, necessitates container enrichment.</li> </ul> </li> <li>parse-arguments: Do not show raw machine-readable values for event arguments. Instead, parse them into human-readable strings.</li> <li>parse-arguments-fds: Enable parse-arguments and enrich file descriptors (fds) with their file path translation. This can cause pipeline slowdowns.</li> <li>sort-events: Enable sorting events before passing them to the output. This may decrease the overall program efficiency.</li> </ul>"},{"location":"docs/flags/output.1/#examples","title":"EXAMPLES","text":"<ul> <li>To output events as JSON to stdout, use the following flag:</li> </ul> <pre><code>--output json\n</code></pre> <ul> <li>To output events as JSON to <code>/my/out</code>, use the following flag:</li> </ul> <pre><code>--output json:/my/out\n</code></pre> <ul> <li>To output events as the provided Go template to stdout, use the following flag:</li> </ul> <pre><code>--output gotemplate=/path/to/my.tmpl\n</code></pre> <ul> <li>To output events as JSON to both <code>/my/out</code> and <code>/my/out2</code>, use the following flag:</li> </ul> <pre><code>--output json:/my/out1,/my/out2\n</code></pre> <ul> <li>To ignore events output, use the following flag:</li> </ul> <pre><code>--output none\n</code></pre> <ul> <li>To output events as a table with stack addresses, use the following flag:</li> </ul> <pre><code>--output table --output option:stack-addresses\n</code></pre> <ul> <li>To output events via the Forward protocol to <code>127.0.0.1</code> on port <code>24224</code> with the tag 'tracee' using TCP, use the following flag:</li> </ul> <pre><code>--output forward:tcp://user:pass@127.0.0.1:24224?tag=tracee\n</code></pre> <ul> <li>To output events to the webhook endpoint <code>http://webhook:8080</code>, use the following flag:</li> </ul> <pre><code>--output webhook:http://webhook:8080\n</code></pre> <ul> <li>To output events to the webhook endpoint <code>http://webhook:8080</code> with a timeout of 5 seconds, use the following flag:</li> </ul> <pre><code>--output webhook:http://webhook:8080?timeout=5s\n</code></pre>"},{"location":"docs/flags/rego.1/","title":"TRACEE-REGO","text":""},{"location":"docs/flags/rego.1/#name","title":"NAME","text":"<p>tracee --rego - Rego configurations</p>"},{"location":"docs/flags/rego.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --rego &lt;config-option&gt;</p>"},{"location":"docs/flags/rego.1/#description","title":"DESCRIPTION","text":"<p>The --rego flag allows you to configure rego settings for Tracee.</p> <p>Possible configuration options:</p> <ul> <li>partial-eval: Enable partial evaluation of rego signatures.</li> <li>aio: Compile rego signatures altogether as an aggregate policy. By default, each signature is compiled separately.</li> </ul>"},{"location":"docs/flags/rego.1/#examples","title":"EXAMPLES","text":"<ul> <li>To enable partial evaluation, use the following flag:</li> </ul> <pre><code>--rego partial-eval\n</code></pre> <ul> <li>To enable partial evaluation and aggregate policy compilation, use the following flags:</li> </ul> <pre><code>--rego partial-eval --rego aio\n</code></pre> <p>Please refer to the documentation for more information on rego signatures.</p>"},{"location":"docs/flags/scope.1/","title":"TRACEE-SCOPE","text":""},{"location":"docs/flags/scope.1/#name","title":"NAME","text":"<p>tracee --scope - Select the scope for tracing events</p>"},{"location":"docs/flags/scope.1/#synopsis","title":"SYNOPSIS","text":"<p>tracee --scope [&lt;[uid|pid][=|!=|&lt;|&gt;|&lt;=|&gt;=]value1(,value2...)&gt; | &lt;[mntns|pidns|tree][=|!=]value1(,value2...)&gt; | &lt;[uts|comm|container|[executable|exec|binary|bin]][=|!=]value1(,value2...)&gt;] | &lt;not-container&gt; | &lt;container[=|!=]value&gt; | &lt;[container|pid]=new&gt; | &lt;follow&gt;]  ...</p>"},{"location":"docs/flags/scope.1/#description","title":"DESCRIPTION","text":"<p>The --scope flag allows you to select the scope for tracing events by defining filters.</p>"},{"location":"docs/flags/scope.1/#filter-expression","title":"FILTER EXPRESSION","text":"<p>Filter expressions can be defined to operate on scope options or process metadata. Only events that match all filter expressions will be traced.</p> <p>Multiple flags are combined with AND logic, while multiple values within a single flag are combined with OR logic when using the equals operator '='. Multiple values can be specified using ','.</p>"},{"location":"docs/flags/scope.1/#numerical-expression-operators","title":"NUMERICAL EXPRESSION OPERATORS","text":"<p>The following numerical fields support the operators '=', '!=', '&lt;', '&gt;', '&lt;=', '&gt;=':</p> <ul> <li>uid: Select events from specific user IDs.</li> <li>pid: Select events from specific process IDs.</li> </ul> <p>The following numerical fields only support the operators '=' and '!=':</p> <ul> <li>mntns: Select events from specific mount namespace IDs.</li> <li>pidns: Select events from specific process namespace IDs.</li> <li>tree: Select events that descend from specific process IDs.</li> </ul> <p>NOTE: Expressions containing '&lt;' or '&gt;' tokens must be escaped!</p>"},{"location":"docs/flags/scope.1/#string-expression-operators","title":"STRING EXPRESSION OPERATORS","text":"<p>'=', '!='</p> <p>Available for the following string fields:</p> <ul> <li>uts: Select events based on UTS (Unix Timesharing System) names.</li> <li>comm: Select events based on process command names.</li> <li>container: Select events from specific container IDs.</li> <li>executable: Select events based on the executable path.</li> </ul> <p>Strings can be compared as a prefix if ending with '*', or as a suffix if starting with '*'.</p> <p>NOTE: Expressions containing '*' token must be escaped!</p>"},{"location":"docs/flags/scope.1/#boolean-operator-prepended","title":"BOOLEAN OPERATOR (PREPENDED)","text":"<p>'!'</p> <p>Available for the following boolean field:</p> <ul> <li>container: Select events based on whether they originate from a container or not.</li> </ul>"},{"location":"docs/flags/scope.1/#special-filters","title":"SPECIAL FILTERS","text":"<p>The following special filters can be used within the scope filter expressions:</p> <ul> <li>new: Select newly created containers or process IDs.</li> <li>follow: Select events from the processes that match the criteria and their descendants.</li> </ul>"},{"location":"docs/flags/scope.1/#examples","title":"EXAMPLES","text":"<ul> <li>To trace only events from new processes, use the following flag:</li> </ul> <pre><code>--scope pid=new\n</code></pre> <ul> <li>To trace only events from pid 510 or pid 1709, use the following flag:</li> </ul> <pre><code>--scope pid=510,1709\n</code></pre> <ul> <li>To trace only events from pid 510 or pid 1709 (same as above), use the following flag:</li> </ul> <pre><code>--scope p=510 --scope p=1709\n</code></pre> <ul> <li>To trace only events from newly created containers, use the following flag:</li> </ul> <pre><code>--scope container=new\n</code></pre> <ul> <li>To trace only events from the container with ID 'ab356bc4dd554', use the following flag:</li> </ul> <pre><code>--scope container=ab356bc4dd554\n</code></pre> <ul> <li>To trace only events from containers, use the following flag:</li> </ul> <pre><code>--scope container\n</code></pre> <ul> <li>To only trace events from containers (same as above), use the following flag:</li> </ul> <pre><code>--scope c\n</code></pre> <ul> <li>To trace only events from the host, use the following flag:</li> </ul> <pre><code>--scope not-container\n</code></pre> <ul> <li>To trace only events from uid 0, use the following flag:</li> </ul> <pre><code>--scope uid=0\n</code></pre> <ul> <li>To trace only events from mntns id 4026531840, use the following flag:</li> </ul> <pre><code>--scope mntns=4026531840\n</code></pre> <ul> <li>To trace only events from pidns id not equal to 4026531836, use the following flag:</li> </ul> <pre><code>--scope pidns!=4026531836\n</code></pre> <ul> <li>To trace only events that descend from the process with pid 476165, use the following flag:</li> </ul> <pre><code>--scope tree=476165\n</code></pre> <ul> <li>To trace only events if they do not descend from the process with pid 5023, use the following flag:</li> </ul> <pre><code>--scope tree!=5023\n</code></pre> <ul> <li>To trace only events if they descend from 3213 or 5200, but not 3215, use the following flag:</li> </ul> <pre><code>--scope tree=3213,5200 --scope tree!=3215\n</code></pre> <ul> <li>To trace only events from uids greater than 0, use the following flag:</li> </ul> <pre><code>--scope 'uid&gt;0'\n</code></pre> <ul> <li>To trace only events from pids between 0 and 1000, use the following flag:</li> </ul> <pre><code>--scope 'pid&gt;0' --scope 'pid&lt;1000'\n</code></pre> <ul> <li>To trace only events from uids greater than 0 but not 1000, use the following flag:</li> </ul> <pre><code>--scope 'u&gt;0' --scope u!=1000\n</code></pre> <ul> <li>To exclude events from uts name 'ab356bc4dd554', use the following flag:</li> </ul> <pre><code>--scope uts!=ab356bc4dd554\n</code></pre> <ul> <li>To trace only events from the 'ls' command, use the following flag:</li> </ul> <pre><code>--scope comm=ls\n</code></pre> <ul> <li>To trace only events from the '/usr/bin/ls' executable, use the executable flag (or the binary alias):</li> </ul> <pre><code>--scope executable=/usr/bin/ls\n</code></pre> <pre><code>--scope binary=/usr/bin/ls\n</code></pre> <ul> <li>To trace only events from the '/usr/bin/ls' executable in the host mount namespace, use the following flag:</li> </ul> <pre><code>--scope executable=host:/usr/bin/ls\n</code></pre> <ul> <li>To trace only events from the '/usr/bin/ls' executable in the 4026532448 mount namespace, use the following flag:</li> </ul> <pre><code>--scope executable=4026532448:/usr/bin/ls\n</code></pre> <ul> <li>To trace all events that originated from 'bash' or from one of the processes spawned by 'bash', use the following flag:</li> </ul> <pre><code>--scope comm=bash --scope follow\n</code></pre>"},{"location":"docs/install/","title":"Installing Tracee","text":"<ol> <li>Tracee executable binary is available in under releases.</li> <li>Tracee container image is available in Docker Hub as aquasec/tracee.</li> <li>Tracee Helm chart is available in Aqua Security's registry: <code>https://aquasecurity.github.io/helm-charts/</code> as <code>tracee</code>.</li> </ol> <p>It might also be available in various package managers managed by the community.</p> <p>Before continuing, please make sure Tracee is supported on your environment by reading the Prerequisites.</p> <p>To get started with Docker, please read the Docker guide. To get started on Kubernetes, please read the Kubernetes guide.</p>"},{"location":"docs/install/container-engines/","title":"Tracee Events Container Enrichment","text":"<p>Tracee events provide context about where the collected events originated from, including information about the originating container if available. To gather this information, Tracee needs to communicate with the relevant container runtime.</p>"},{"location":"docs/install/container-engines/#detecting-container-runtime","title":"Detecting container runtime","text":"<p>Tracee will automatically search for known supported runtimes by looking for their socket files in known locations. You may track if Tracee was able to find the container runtime socket by running Tracee with <code>debug</code> log level. There will be a line to each known runtime engine socket and a message sharing it's status.</p> <p>When running Tracee in a container, the runtime sockets must be mounted to be available for Tracee.</p> <p>For example, if running Tracee using Docker, and ContainerD runtime:</p> <pre><code>docker run --name tracee -it --rm \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  -v /var/run/containerd:/var/run/containerd:ro \\\n  aquasec/tracee:latest\n</code></pre> <p>Most container runtimes have their sockets installed by default in <code>/var/run</code>, so mounting this path can also be a good option.</p>"},{"location":"docs/install/container-engines/#supported-container-runtime-engines","title":"Supported Container Runtime Engines","text":"<p>Tracee supports the following container runtimes and will look in the following paths for their socket files:</p> <ol> <li>Docker: <code>/var/run/docker.sock</code></li> <li>Containerd: <code>/var/run/containerd/containerd.sock</code></li> <li>CRI-O: <code>/var/run/crio/crio.sock</code></li> <li>Podman: <code>/var/run/podman/podman.sock</code></li> </ol>"},{"location":"docs/install/docker/","title":"Running Tracee with Docker","text":"<p>This guide will help you get started with running Tracee as a container.</p>"},{"location":"docs/install/docker/#prerequisites","title":"Prerequisites","text":"<ul> <li>Review the prerequisites for running Tracee</li> <li>If you are an Apple Mac user, please read the Mac FAQ</li> <li>Ensure that you have Docker or a compatible container runtime</li> </ul>"},{"location":"docs/install/docker/#tracee-container-image","title":"Tracee container image","text":"<p>Tracee container image is available in Docker Hub as aquasec/tracee.</p> <ul> <li>You can use the <code>latest</code> tag or a named version version e.g <code>aquasec/tracee:v0.21.0-rc-32-gc858afa7d</code>.</li> <li>If you are trying the most cutting edge features, there is also a <code>dev</code> tag which is built nightly from source.</li> <li>The Tracee image is a Multi-platform image that includes a x86 and arm64 flavors. You can also access the platform-specific images directly with the <code>aarch64</code> and <code>x86_64</code> tags for the latest version or <code>aarch64-&lt;version&gt;</code> and <code>x86_64-&lt;version&gt;</code> for a specific version.  </li> <li>For most first time users, just use <code>aquasec/tracee</code>!</li> </ul>"},{"location":"docs/install/docker/#running-tracee-container","title":"Running Tracee container","text":"<p>Here is the docker run command, we will analyze it next:</p> <pre><code>docker run --name tracee -it --rm \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  -v /var/run:/var/run:ro \\\n  aquasec/tracee:latest\n</code></pre> <ol> <li>Docker general flags:<ul> <li><code>--name</code> - name our container so that we can interact with it easily.</li> <li><code>--rm</code> - remove the container one it exits, assuming this is an interactive trial of Tracee.</li> <li><code>-it</code> - allow the container to interact with your terminal.</li> </ul> </li> <li>Since Tracee runs in a container but is instrumenting the host, it will need access to some resources from the host:<ul> <li><code>--pid=host</code> - share the host's process namespace with Tracee's container.</li> <li><code>--cgroupns-host</code> - share the host's cgroup namespace with Tracee's container.</li> <li><code>--privileged</code> - run the Tracee container as root so it has all the required capabilities.</li> <li><code>-v /etc/os-release:/etc/os-release-host:ro</code> - share the host's OS information file with the Tracee container.</li> <li><code>-v /var/run:/var/run</code> - share the host's container runtime socket for container enrichment</li> </ul> </li> </ol> <p>After running this command, you should start seeing a stream of events that Tracee is emitting.</p> <p>For next steps, please read about Tracee Policies</p>"},{"location":"docs/install/docker/#installing-tracee","title":"Installing Tracee","text":"<p>If you are looking to permanently install Tracee, you would probably do the following:</p> <ol> <li>Remove interactive flags <code>-it</code> and replace with daemon flag <code>-d</code></li> <li>Consider how to collect events from the container.</li> </ol> <p>Or you can follow the Kubernetes guide which addresses these concerns.</p>"},{"location":"docs/install/healthz/","title":"Health Monitoring","text":"<p>Tracee can expose a <code>/healthz</code> endpoint that returns <code>OK</code> if the everything is healthy. This is a common pattern in Cloud Native and Kubernetes applications.  </p> <p>Health monitoring endpoint is disabled by default, and can be enabled with the configuration:</p> <pre><code>healthz: true\n</code></pre> <p>By default port <code>3366</code> is used. It can be customized with the configuration:</p> <pre><code>listen-addr: 1234\n</code></pre>"},{"location":"docs/install/kubernetes/","title":"Installing Tracee in Kubernetes","text":"<p>This guide will help you get started with Tracee by installing it in a Kubernetes cluster.  </p>"},{"location":"docs/install/kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Supported environment - please refer to the Prerequisites</li> <li>Kubernetes - this was tested on minikube, but should work the same with most other Kubernetes distributions</li> <li>Helm</li> </ul> Verify step <pre><code>kubectl get po -A\n</code></pre> <pre><code>NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE \nkube-system   coredns-565d847f94-kd9xx           1/1     Running   0          15s \nkube-system   etcd-minikube                      1/1     Running   0          26s \nkube-system   kube-apiserver-minikube            1/1     Running   0          26s \nkube-system   kube-controller-manager-minikube   1/1     Running   0          26s \nkube-system   kube-proxy-cvqjm                   1/1     Running   0          15s \nkube-system   kube-scheduler-minikube            1/1     Running   0          26s \nkube-system   storage-provisioner                1/1     Running   0          15s \n</code></pre>"},{"location":"docs/install/kubernetes/#install-tracee","title":"Install Tracee","text":"<p>The provided Helm chart will install Tracee as a DaemonSet so that it's tracing all the nodes in the cluster.</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\nhelm repo update\nhelm install tracee aqua/tracee --namespace tracee --create-namespace\n</code></pre> Verify step <pre><code>kubectl get pods -n tracee\n</code></pre> <pre><code>NAME           READY   STATUS    RESTARTS   AGE \ntracee-fcjmp   1/1     Running   0          4m11s\n</code></pre> <p>Once installed, Tracee immediately starts producing events. Since Tracee is deployed as a DaemonSet, a Tracee Pod is running on every node in the cluster. Every Tracee Pod is monitoring the node it is running on.</p>"},{"location":"docs/install/kubernetes/#viewing-events","title":"Viewing Events","text":"<p>The easiest way to tap into the log stream of all Tracee Pods is with the <code>kubectl logs</code> command:</p> <pre><code>kubectl logs -f daemonset/tracee -n tracee\n</code></pre> <p>Note</p> <p>Tracee can produce a very high volume of events which could overwhelm kubectl's log collection command. If run in a busy cluster or with a verbose policy, this command might be slow or unresponsive.</p> <p>In production scenario you would probably want to collect and ship events logs into a persistent storage that you can query.  You can use any log collection solution of your choosing. We have a tutorial on how to do this using the open source Grafana Stack here.</p>"},{"location":"docs/install/kubernetes/#applying-policies","title":"Applying Policies","text":"<p>By default, Tracee collects a basic set of events that gives you a general overview of the cluster. If you're looking to do more with Tracee, You might want to create a new Policy. A policy lets you capture specific set of events from a specific set of workloads. For example, if you have an application that you want to monitor more closely, or in a specialized way, you can create a policy scoped to that application, with a different set of events and filters applied. To learn more, please refer to the Events and Policies sections.</p> <p>When you are ready to apply a policy, it's as easy as <code>kubectl apply -f your-policy.yaml</code>. More details here.</p>"},{"location":"docs/install/kubernetes/#configuring-tracee","title":"Configuring Tracee","text":"<p>In some cases you will need to configure Tracee to your preferences. For example, to change the output event format, or to set a different log level. To learn more about available configuration options please see the configuration section.</p> <p>Tracee's configuration is accessible as a ConfigMap in Kubernetes. Since we installed Tracee with Helm, you can also configure Tracee with it, for example: <code>helm upgrade tracee --set config.cache.size=1024</code>. More details here.</p>"},{"location":"docs/install/kubernetes/#optional-exercising-a-security-event","title":"Optional: Exercising a security event","text":"<p>To see Tracee in action, let's simulate a security event. We'll do a \"file-less\" execution, which is a common evasion technique used by some malware, and is flagged by Tracee as suspicious activity. To simulate this, we'll use the tracee-tester example image it will simulate the suspicious activity without harming your environment.</p> <pre><code>kubectl run tracee-tester --image=aquasec/tracee-tester -- TRC-105\n</code></pre> <p>You can see the event in the logs:</p> <pre><code>kubectl logs -f ds/tracee -n tracee | grep fileless_execution \n</code></pre>"},{"location":"docs/install/kubernetes/#next-steps","title":"Next steps","text":"<p>Familiarize with the different events, filters, and configuration options in the documentation.</p> <p>Read other tutorials.</p> <p>For help and support, feel free to use GitHub Discussions.</p>"},{"location":"docs/install/kubernetes/#video-content","title":"Video Content","text":"<p>If you prefer a video version of the Kubernetes installation guide, have a look at the following video:</p> <p>Getting started with eBPF in Kubernetes - Tracee Installation Guide </p> <p></p>"},{"location":"docs/install/prerequisites/","title":"Prerequisites for running Tracee","text":"<p>Tracee is heavily dependent on Linux and does not support any other operating system.</p>"},{"location":"docs/install/prerequisites/#distributions-and-linux-flavors","title":"Distributions and Linux Flavors","text":"<ul> <li>List of supported environments:</li> <li>With BTFHUB (check BTF session below):<ul> <li>Centos 8 (kernel &lt; 4.18.0-193.el8)</li> <li>Debian 10 (buster) with v5.10 kernels</li> <li>Oracle Linux 7 and 8 with v5.4 kernels</li> <li>Red Hat 8 (kernel &lt;= 4.18.0-147.57.1)</li> <li>SuSe 15.3 (kernel &lt; 5.3.18-150300.59.90)</li> </ul> </li> <li>Regular Build:<ul> <li>Amazon Linux 2</li> <li>Centos 8 and newer</li> <li>Debian 11 (bullseye) and newer</li> <li>Fedora 38 and newer</li> <li>Oracle Linux 7, 8 (v5.4 kernels, some might need btfhub) and newer</li> <li>Red Hat 8 (newer v4.18 kernels) and newer</li> <li>SuSe 15.3 (newer kernels) and newer</li> <li>Possibly other distributions with recent kernels.</li> </ul> </li> <li>Cloud Environments:<ul> <li>Amazon EKS</li> <li>Azure AKS</li> <li>GKE (Google Kubernetes Engine): 5.4, 5.10, 5.15 and newer</li> <li>Minikube, Microk8s and other development environments</li> </ul> </li> </ul> <p>This list is based on capabilities those versions provide and not necessarily in tracee having all its features tested on each of them. Please provide feedback if you face any issues in one of those environments.</p>"},{"location":"docs/install/prerequisites/#kernel-version","title":"Kernel version","text":"<p>To run Tracee a modern longterm supported kernel is needed: 5.4, 5.10, 5.15, 6.2, 6.5  </p> <p>You can check kernel.org for current supported kernels. In addition to upstream kernels, most distributions long-term supported kernels are supported as well, including CentOS8 4.18 kernel.</p>"},{"location":"docs/install/prerequisites/#btf","title":"BTF","text":"<p>Tracee needs low-level type information about the running kernel. Most modern Linux distributions ship with the BTF feature that exposes this information.  </p> <p>To test if this feature is enabled in your environment, check if <code>/sys/kernel/btf/vmlinux</code> exists. If absent, you might need to upgrade to a newer OS version, or contact your OS provider.</p>"},{"location":"docs/install/prerequisites/#kernel-symbols","title":"Kernel symbols","text":"<p>Certain Tracee events require access to the Kernel Symbols Table, a feature present in many Linux distributions.</p> <p>To test if this feature is enabled in your environment, check if <code>/proc/kallsyms</code> exists. If absent, contact your OS provider.</p> <p>Alternatively, you can disable the following events which depends on kallsyms:</p> <ul> <li><code>dirty_pipe_splice</code> (detects dirty pipe vulnerability - CVE-2022-0847)</li> <li><code>hooked_syscall</code> (detects system call interception technique)</li> <li><code>hidden_kernel_module</code> (detects hidden kernel modules technique)</li> <li><code>hooked_proc_fops</code> (detects procfs file operations interception technique)</li> <li><code>print_net_seq_ops</code> (related hooked_seq_ops event)</li> <li><code>hooked_seq_ops</code> (detects network packets interception technique)</li> <li><code>print_mem_dump</code> (allows memory dumping from symbols to signatures can use)</li> </ul> <p>For more information and help about kernel symbols, please see here.</p>"},{"location":"docs/install/prerequisites/#os-information","title":"OS information","text":"<p>Tracee will try to probe the running OS and kernel to detect available capabilities. For this, it needs access to some standard informative files:</p> <ul> <li>For OS information please make sure the file <code>/etc/os-release</code> is available.</li> <li>For Kernel information please make sure on of the files <code>/boot/config-$(uname-r)</code> OR <code>/proc/config.gz</code> is available.</li> </ul> <p>For more information and help about OS info files, please see here.</p>"},{"location":"docs/install/prerequisites/#process-capabilities","title":"Process capabilities","text":"<p>Tracee needs non-trivial capabilities to instrument the kernel. The easiest way is run Tracee as \"privileged\" or \"root\".  </p> <p>If you want to run Tracee with \"least privileges\", here are the required capabilities and justifications:</p> <ul> <li>Manage eBPF maps limits (<code>CAP_SYS_RESOURCE</code>)</li> <li>Load and Attach eBPF programs:<ul> <li><code>CAP_BPF</code>+<code>CAP_PERFMON</code> for recent kernels (&gt;=5.8) where the kernel perf paranoid value in <code>/proc/sys/kernel/perf_event_paranoid</code> is equal to 2 or less</li> <li>or <code>CAP_SYS_ADMIN</code> otherwise</li> </ul> </li> <li><code>CAP_SYS_PTRACE</code> (to collect information about processes)</li> <li><code>CAP_NET_ADMIN</code> (to use tc for packets capture)</li> <li><code>CAP_SETPCAP</code> (if given - used to reduce bounding set capabilities)</li> <li><code>CAP_SYSLOG</code> (to access kernel symbols through /proc/kallsyms)</li> <li>On some environments (e.g. Ubuntu) <code>CAP_IPC_LOCK</code> might be required as well.</li> <li>On cgroup v1 environments, <code>CAP_SYS_ADMIN</code> is recommended if running from a container in order to allow tracee to mount the cpuset cgroup controller.</li> </ul> <p>For more information and help about process capabilities, please see here.</p>"},{"location":"docs/install/prerequisites/#processor-architecture","title":"Processor architecture","text":"<p>Tracee supports x86 and arm64 processors.</p>"},{"location":"docs/install/prometheus/","title":"Prometheus","text":"<p>Integrating with Prometheus</p> <p>Performance</p> <p>Current Prometheus integration targets performance numbers for event production, consumption and detection. It does not target the detections themselves.</p> <p>Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:</p> <p>tracee can be scraped through <code>:3366/metrics</code></p> <p>Metrics addresses can be changed through tracee command line arguments <code>metrics</code> and <code>listen-addr</code>, check <code>--help</code> for more information.</p> <p>Tip</p> <p>Check this tutorial for more information as well.</p>"},{"location":"docs/install/config/","title":"Configuring Tracee","text":"<p>Tracee has many different options and settings that control how Tracee operates.  This section presents available configuration options. To learn about how to apply configuration to Tracee, please refer to the CLI or Kubernetes specific guides.</p> <p>A complete config file with all available options can be found here. Most of the options are documented in different sections in the documentation.</p> <pre><code>blob-perf-buffer-size: 1024\ncache:\n    type: none\n    size: 1024\n\nproctree:\n    source: none\n    cache:\n        process: 8192\n        thread: 4096\n\ncapabilities:\n    bypass: false\n    add:\n        - cap_sys_admin\n        - cap_syslog\n    drop:\n        - cap_chown\n\ncri:\n    - runtime:\n        name: containerd\n        socket: /var/run/containerd/containerd.sock\n    - runtime:\n        name: docker\n        socket: /var/run/docker.sock\n\nhealthz: false\ninstall-path: /tmp/tracee\nlisten-addr: :3366\nlog:\n    level: info\n    file: \"/path/to/log/file.log\"\n    aggregate:\n        enabled: true\n        flush-interval: \"5s\"\n    filters:\n        libbpf: false\n        in:\n        msg:\n            - SampleMessage1\n            - SampleMessage2\n        pkg:\n            - package1\n            - package2\n        file:\n            - file1.go\n            - file2.go\n        level:\n            - warn\n            - error\n        regex:\n            - ^pattern1\n            - ^pattern2\n        out:\n        msg:\n            - ExcludedMessage1\n        pkg:\n            - excludedPackage\n        file:\n            - excludedFile.go\n        level:\n            - debug\n        regex:\n            - ^excludedPattern\n\nmetrics: false\noutput:\n    json:\n        files:\n            - stdout\n\n    table:\n        files:\n            - /path/to/table1.out\n            - /path/to/table2.out\n\n    table-verbose:\n        files:\n            - stdout\n\n    gotemplate:\n        template: /path/to/my_template1.tmpl\n        files:\n            - /path/to/output1.out\n            - /path/to/output2.out\n\n    forward:\n        - forward1:\n            protocol: tcp\n            user: user\n            password: pass\n            host: 127.0.0.1\n            port: 24224\n            tag: tracee1\n        - forward2:\n            protocol: udp\n            user: user\n            password: pass\n            host: 127.0.0.1\n            port: 24225\n            tag: tracee2\n\n    webhook:\n        - webhook1:\n            protocol: http\n            host: localhost\n            port: 8000\n            timeout: 5s\n            gotemplate: /path/to/template/test.tmpl\n            content-type: application/json\n        - webhook2:\n            protocol: http\n            host: localhost\n            port: 9000\n            timeout: 3s\n            gotemplate: /path/to/template/test.tmpl\n            content-type: application/json\n\n    options:\n        none: false\n        stack-addresses: true\n        exec-env: false\n        relative-time: true\n        exec-hash: dev-inode\n        parse-arguments: true\n        sort-events: false\n\nperf-buffer-size: 1024\npprof: false\npyroscope: false\nrego:\n    partial-eval: true\n    aio: true\nsignatures-dir: \"\"\n</code></pre>"},{"location":"docs/install/config/cli/","title":"Configuring Tracee with CLI","text":"<p>The <code>--config</code> flag allows you to specify global configuration options for Tracee by providing a configuration file in YAML or JSON format, among other supported formats. The <code>--config</code> flag can be used to set any flag that is available through the command line interface (CLI), except for a few reserved flags.</p>"},{"location":"docs/install/config/cli/#usage","title":"Usage","text":"<p>To use the <code>--config</code> flag, you need to provide the path to the configuration file. For example, if you have a YAML configuration file located at /path/to/tracee-config.yaml, you can load it with the following command:</p> <pre><code>tracee --config /path/to/tracee-config.yaml\n</code></pre>"},{"location":"docs/install/config/kubernetes/","title":"Configuring Tracee in Kubernetes","text":"<p>In Kubernetes, Tracee uses a ConfigMap, called <code>tracee</code> to make Tracee configuration accessible. The ConfigMap includes a data file called <code>config.yaml</code> with the desired configuration. For example:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app.kubernetes.io/name: tracee\n    app.kubernetes.io/component: tracee\n    app.kubernetes.io/part-of: tracee\n  name: tracee\ndata:\n  config.yaml: |-\n    cache:\n      - cache-type=mem\n      - mem-cache-size=512\n</code></pre>"},{"location":"docs/install/config/kubernetes/#kubectl","title":"Kubectl","text":"<p>You can use <code>kubectl</code> to interact with it:</p> <p>View:</p> <pre><code>kubectl get cm tracee-config -n tracee\n</code></pre> <p>Edit:</p> <pre><code>kubectl edit cm tracee-config -n tracee\n</code></pre>"},{"location":"docs/install/config/kubernetes/#helm","title":"Helm","text":"<p>You can customize specific options with the helm installation:</p> <pre><code>helm install tracee aqua/tracee \\\n        --namespace tracee --create-namespace \\\n        --set config.blobPerfBufferSize=1024\n</code></pre> <p>or after installation:</p> <pre><code>helm install tracee aqua/tracee \\\n        --namespace tracee --create-namespace \\\n        --set config.output.format=table\n</code></pre> <p>or to provide a complete config file:</p> <pre><code> helm install tracee aqua/tracee \\\n        --namespace tracee --create-namespace \\\n        --set-file configFile=myconfig.yaml\n</code></pre>"},{"location":"docs/outputs/","title":"Tracee Outputs","text":"<p>Depending on the system, tracee might collect thousands of logs per day. To improve access and filtering of those logs, it is possible to modify the way logs are displayed and stored. This is done through the <code>output</code> and <code>log</code> section of the Tracee configuration file. </p> <p>For examples on each configuration, please refer to: * Documentation on configuring Tracee logs * Documentation on configuring output options * Documentation on configuring output formats</p> <p>Note that example configuration for each can be found in the Tracee root directory within the examples folder &lt; examples/config/global_config.yaml</p>"},{"location":"docs/outputs/logging/","title":"Tracee Logs","text":"<p>This section showcases how to configure diagnostics log. The information provided can then be used to troubleshoot Tracee. This is done through the Tracee configuration file. For more information, have a look at the respective section in the installation guide.</p>"},{"location":"docs/outputs/logging/#log-options","title":"Log options","text":"<p>Configure the log severity:</p> <pre><code>log:\n    level: debug\n</code></pre> <p>Note that the other log level are <code>info</code>, <code>warn</code>, <code>error</code> and <code>panic</code>.</p> <p>Redirect logs to a file if needed:</p> <pre><code>log:\n    level: debug\n    file: \"/tmp/tracee.log\"\n</code></pre> <p>Logs can be aggregated for a given interval (default: 3s) to delay its output:</p> <pre><code>log:\n    level: debug\n    aggregate:\n        enabled: true\n        flush-interval: \"10s\"\n</code></pre> <p>The flush-interval defines how often the Tracee logs will be forwarded.</p> <p>Filter logs which message contains specified words:</p> <pre><code>log:\n    filters: \n        msg: \n            - foo\n            - bar\n</code></pre> <p>Filter logs using regular expressions against messages:</p> <pre><code>log:\n    filters: \n        regex: \n            - ^pattern-one\n</code></pre> <p>Filter logs originating from a specific package:</p> <pre><code>log:\n    filters: \n        pkg:\n            - core\n</code></pre> <p>Filter logs originating from a specific file:</p> <pre><code>log:\n    filter: \n        file: \n            - /pkg/cmd/flags/logger.go\n</code></pre> <p>Filter logs based on their severity level:</p> <pre><code>log:\n    filters: \n        level: \n            - error\n</code></pre> <p>Filter logs originating from libbpf:</p> <pre><code>log:\n    filters: \n        libbpf: true\n</code></pre>"},{"location":"docs/outputs/logging/#additional-configuration","title":"Additional Configuration","text":"<p>All <code>filters</code> options can also be used with <code>filter-out</code> to achieve the opposite behavior. </p> <p>For instance, the following configuration would exclude all logs with the severity level <code>error</code>:</p> <pre><code>log:\n    filter-out: \n        level: \n            - error\n</code></pre>"},{"location":"docs/outputs/output-formats/","title":"Tracing Output Formats","text":"<p>It is possible to define how the events that Tracee collects should be displayed. This is done through the Tracee configuration. You can read more on configuration in the Tracee installation guide.</p> <p>Note that only one output format can be used in the Tracee configuration.</p>"},{"location":"docs/outputs/output-formats/#available-formats","title":"Available Formats","text":"<p>The following examples will have to be added into a Tracee configuration file.</p>"},{"location":"docs/outputs/output-formats/#json","title":"JSON","text":"<p>Displays output events in json format. The default path to a file is stdout.</p> <pre><code>output:\n    json:\n        files:\n            - stdout\n</code></pre> <p>Note: the <code>files: key</code> must also be defined, even if it's just for stdout. This is mandatory for the parser.</p> <p>Tip</p> <p>A good tip is to pipe tracee json output to jq tool, this way you can select fields, rename them, filter values, and much more!</p>"},{"location":"docs/outputs/output-formats/#webhook","title":"Webhook","text":"<p>This sends events in json format to the webhook url</p> <p>Below is an example for configuring webhooks in the Tracee output section:</p> <pre><code>output:\n    # webhook:\n    #     - webhook1:\n    #         protocol: http\n    #         host: localhost\n    #         port: 8000\n    #         timeout: 5s\n    #         gotemplate: /path/to/template/test.tmpl\n    #         content-type: application/json\n    #     - webhook2:\n    #         protocol: http\n    #         host: localhost\n    #         port: 9000\n    #         timeout: 3s\n    #         gotemplate: /path/to/template/test.tmpl\n    #         content-type: application/json\n</code></pre> <p>Note: Please ensure that the respective fields will have to be uncommented.</p>"},{"location":"docs/outputs/output-formats/#forward","title":"Forward","text":"<p>This sends events to a FluentBit receiver. More information on FluentBit can be found in the official documentation.</p> <p>Below is an example for forwarding Tracee output: </p> <pre><code>output:\n    # forward:\n    #     - forward1:\n    #         protocol: tcp\n    #         user: user\n    #         password: pass\n    #         host: 127.0.0.1\n    #         port: 24224\n    #         tag: tracee1\n    #     - forward2:\n    #         protocol: udp\n    #         user: user\n    #         password: pass\n    #         host: 127.0.0.1\n    #         port: 24225\n    #         tag: tracee2\n</code></pre> <p>Note: Please ensure that the respective fields will have to be uncommented.</p>"},{"location":"docs/outputs/output-formats/#table","title":"Table","text":"<p>Displays output events in table format. The default path to a file is stdout.</p> <pre><code>output:\n    table:\n        files:\n            - /path/to/table1.out\n            - /path/to/table2.out\n</code></pre> <p>Note: the <code>files: key</code> must also be defined, even if it's just for stdout. This is mandatory for the parser.</p>"},{"location":"docs/outputs/output-formats/#table-verbose","title":"Table (Verbose)","text":"<p>Displays the output events in table format with extra fields per event. The default path to a file is stdout.</p> <pre><code>output:\n    table-verbose:\n        files:\n            - stdout\n</code></pre> <p>Note: the <code>files: key</code> must also be defined, even if it's just for stdout. This is mandatory for the parser.</p>"},{"location":"docs/outputs/output-formats/#gotemplate","title":"GOTEMPLATE","text":"<p>When authoring a Go template the data source is Tracee's <code>trace.Event</code> struct, which is defined in <code>https://github.com/aquasecurity/tracee/blob/main/types/trace/trace.go#L15</code>.</p> <p>Go template can utilize helper functions from Sprig.</p> <p>For example templates, see tracee/cmd/tracee-rules/templates.</p> <p>The following sections can be specified as part of go templates:</p> <pre><code>output:\n    # gotemplate:\n    #     template: /path/to/my_template1.tmpl\n    #     files:\n    #         - /path/to/output1.out\n    #         - /path/to/output2.out\n</code></pre>"},{"location":"docs/outputs/output-options/","title":"Output Options","text":"<p>Tracee supports different output options for customizing the way events are printed. For a complete list of available options.</p> <p>Available options:</p> <ol> <li> <p>stack-addresses </p> <p>Makes it possible to pick stack memory addresses from each event.</p> <pre><code>output:\n    options:\n        stack-addresses: true\n</code></pre> </li> <li> <p>parse-arguments</p> <p>In order to have a better experience with the output provided by tracee, you may opt to parse event arguments to a human *readable format.</p> <pre><code>output:\n    options:\n        parse-arguments: true\n</code></pre> </li> <li> <p>exec-env</p> <p>Sometimes it is also important to know the execution environment variables whenever an event is detected, specially when detecting execve event.</p> <pre><code>output:\n    options:\n        exec-env: true\n</code></pre> </li> <li> <p>exec-hash</p> <p>This is a special output option for sched_process_exec so user can get the file hash and process ctime (particularly interesting if you would like to compare executed binaries from a list of known hashes, for example).</p> <pre><code>output:\n    options:\n        exec-hash: dev-inode\n</code></pre> </li> <li> <p>relative-time</p> <p>The <code>relative-time</code> output option enables relative timestamp instead of wall timestamp for events.</p> <pre><code>output:\n    options:\n        relative-time: true\n</code></pre> </li> <li> <p>sort-events</p> <p>This makes it possible to sort the events as they happened. Especially in systems where Tracee tracks lots of events, it can happen that they are received unordered. More information is provided in the deep-dive section of the documentation.</p> <pre><code>output:\n    options:\n            sort-events: true\n</code></pre> </li> </ol>"},{"location":"docs/policies/","title":"Policies","text":"<p>Policies allow users to specify which events to trace in which workloads. The policy <code>scope</code> defines which workloads this policy is limited to. The policy can define multiple <code>rules</code> that specify the events to trace. Policies are used both for the Tracee CLI and for the Tracee Kubernetes installation. This makes it easier to share policies across use cases and environments.</p> <p>It is possible to load up to 64 policies into Tracee.</p> <p>Here is an example policy:</p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: overview-policy\n    annotations:\n        description: sample overview policy\nspec:\n    scope:\n      - global\n    rules:\n      - event: dropped_executable\n      - event: security_file_open\n        filters:\n        - args.pathname=/tmp/*\n</code></pre> <p>This policy applies to any workload (<code>global</code>) and will log the <code>dropped_executable</code>, and <code>security_file_open</code> events. An argument filter (<code>args.pathname</code>) is set on the <code>security_file_open</code> event to log only files which were opened from the <code>/tmp</code> directory.</p> <p>Note</p> <p>Note that currently each event type can only be defined once in a policy</p> <p>There are many ways to fine tune the scope and filters. For further information on the details, have a look at the respective sections: </p> <ul> <li>Specify the Policy scope</li> <li>Filter events in the rules section</li> </ul> <p>While specifying event filters is optional, policies must have the <code>name</code>, <code>description</code>, <code>scope</code> and <code>rules</code> fields.</p>"},{"location":"docs/policies/rules/","title":"Rules","text":"<p>Rules are part of the Tracee Policy, which defines which events to trace. The events that are part of a specific policy are recorded in the <code>rules</code> section of the Tracee Policy. It is possible to define multiple events within each policy. The events section provides further information on the type of events that Tracee can track.</p> <p>Below are several examples on configuring events in the Tracee Policy.</p>"},{"location":"docs/policies/rules/#events","title":"Events","text":"<p>Every event that is specified within the <code>rules</code> section supports three types of filters: <code>scope</code>, <code>arguments</code> and <code>return value</code>. </p>"},{"location":"docs/policies/rules/#type-of-events","title":"Type of Events","text":"<p>A syscall</p> <p>Example Scope Section referencing the <code>open</code> syscall:</p> <pre><code>spec:\n    scope:\n        - global\n    rules:\n        event: open\n</code></pre> <p>The name of the syscall is going to be the name of the event.</p> <p>Network Events</p> <p>Network Events can be specified from the list of <code>Available network events</code>.</p> <p>For example:</p> <pre><code>spec:\n    scope:\n        - global\n    rules:\n        event: net_packet_ipv4\n</code></pre> <p>A behavioural Signature</p> <p>To specify one of the behavioral signatures as an event, use the name of the signature from the table in the documentation as the event name:</p> <pre><code>spec:\n    scope:\n        - global\n    rules:\n        event: anti_debugging\n</code></pre> <p>Any of our extra events</p> <p>Any of the extra events listed in the Tracee documentation can be listed in the Tracee Policy.</p> <p>For instance, to specify the do_sigaction event, provide the name in the YAML manifest:</p> <pre><code>spec:\n    scope:\n        - global\n    rules:\n        event: do_sigaction\n</code></pre>"},{"location":"docs/policies/rules/#scope-filters","title":"Scope filters","text":"<p>Further refinement of the policy's scope is achievable through the application of scope filters:</p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: sample-scope-filter\n    annotations:\n        description: sample scope filter\nspec:\n    scope:\n        - global\n    rules:\n        event: sched_process_exec\n        filters:\n        - pid=1000\n</code></pre> <p>The scope filters supported are:</p>"},{"location":"docs/policies/rules/#p-pid-processid","title":"p, pid, processId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - pid=1000\n</code></pre>"},{"location":"docs/policies/rules/#tid-threadid","title":"tid, threadId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - tid=13819\n</code></pre>"},{"location":"docs/policies/rules/#ppid-parentprocessid","title":"ppid, parentProcessId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - ppid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hosttid-hostthreadid","title":"hostTid, hostThreadId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - hostTid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hostpid","title":"hostPid","text":"<pre><code>event: sched_process_exec\nfilters:\n    - hostPid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hostparentprocessid","title":"hostParentProcessId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - hostParentProcessId=1\n</code></pre>"},{"location":"docs/policies/rules/#uid-userid","title":"uid, userId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - uid=0\n</code></pre>"},{"location":"docs/policies/rules/#mntns-mountnamespace","title":"mntns, mountNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n    - mntns=4026531840\n</code></pre>"},{"location":"docs/policies/rules/#pidns-pidnamespace","title":"pidns, pidNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n    - pidns=4026531836\n</code></pre>"},{"location":"docs/policies/rules/#comm-processname","title":"comm, processName","text":"<pre><code>event: sched_process_exec\nfilters:\n    - comm=uname\n</code></pre>"},{"location":"docs/policies/rules/#hostname","title":"hostName","text":"<pre><code>event: sched_process_exec\nfilters:\n    - hostName=hostname\n</code></pre>"},{"location":"docs/policies/rules/#cgroupid","title":"cgroupId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - cgroupId=5247\n</code></pre>"},{"location":"docs/policies/rules/#container","title":"container","text":"<pre><code>event: sched_process_exec\nfilters:\n    - container=66c2778945e29dfd36532d63c38c2ce4ed1\n</code></pre>"},{"location":"docs/policies/rules/#containerid","title":"containerId","text":"<pre><code>event: sched_process_exec\nfilters:\n    - containerId=66c2778945e29dfd36532d63c38c2ce4ed1\n</code></pre>"},{"location":"docs/policies/rules/#containerimage","title":"containerImage","text":"<pre><code>event: sched_process_exec\nfilters:\n    - containerImage=ubuntu:latest\n</code></pre>"},{"location":"docs/policies/rules/#containername","title":"containerName","text":"<pre><code>event: sched_process_exec\nfilters:\n    - containerName=test\n</code></pre>"},{"location":"docs/policies/rules/#podname","title":"podName","text":"<pre><code>event: sched_process_exec\nfilters:\n    - podName=daemonset/test\n</code></pre>"},{"location":"docs/policies/rules/#podnamespace","title":"podNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n    - podNamespace=production\n</code></pre>"},{"location":"docs/policies/rules/#poduid","title":"podUid","text":"<pre><code>event: sched_process_exec\nfilters:\n    - podUid=66c2778945e29dfd36532d63c38c2ce4ed16a002c44cb254b8e\n</code></pre>"},{"location":"docs/policies/rules/#argument-filter","title":"Argument filter","text":"<p>Events have arguments, which can be filtered. </p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: sample-argument-filter\n    annotations:\n        description: sample argument filter\nspec:\n    scope:\n        - global\n    rules:\n        event: security_file_open\n        filters:\n        - args.pathname=/tmp*\n</code></pre> <p>Arguments can be found on the respective event definition, in this case security_file_open, or the user can test the event output in CLI before defining a policy, e.g:</p> <pre><code>tracee -e security_file_open --output json\n</code></pre> <pre><code>{\"timestamp\":1680182976364916505,\"threadStartTime\":1680179107675006774,\"processorId\":0,\"processId\":676,\"cgroupId\":5247,\"threadId\":676,\"parentProcessId\":1,\"hostProcessId\":676,\"hostThreadId\":676,\"hostParentProcessId\":1,\"userId\":131,\"mountNamespace\":4026532574,\"pidNamespace\":4026531836,\"processName\":\"systemd-oomd\",\"hostName\":\"josedonizetti-x\",\"container\":{},\"kubernetes\":{},\"eventId\":\"730\",\"eventName\":\"security_file_open\",\"matchedPolicies\":[\"\"],\"argsNum\":6,\"returnValue\":0,\"syscall\":\"openat\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/proc/meminfo\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":45},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":4026532041},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1680179108391999988},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/proc/meminfo\"}]}\n</code></pre>"},{"location":"docs/policies/rules/#return-value-filter","title":"Return value filter","text":"<p>Return values can also be filtered.</p> <pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: sample-return-value\n    annotations:\n        description: sample return value\nspec:\n    scope:\n        - global\n    rules:\n        event: close\n        filters:\n        - retval!=0\n</code></pre>"},{"location":"docs/policies/scopes/","title":"Scopes","text":"<p>Scope defines the workload a policy will be observing. </p> <p>The supported scopes are listed below.</p>"},{"location":"docs/policies/scopes/#global","title":"global","text":"<p>Events are collected from the whole host: <pre><code>scope:\n    - global\n</code></pre></p>"},{"location":"docs/policies/scopes/#uid","title":"uid","text":"<p>Events are collected from the specific user id:</p> <pre><code>scope:\n    - uid=0\n</code></pre>"},{"location":"docs/policies/scopes/#pid","title":"pid","text":"<p>Events are collected from the specific pid:</p> <pre><code>scope:\n    - pid=1000\n</code></pre>"},{"location":"docs/policies/scopes/#mntns","title":"mntns","text":"<p>Events are collected from the mount namespace:</p> <pre><code>scope:\n    - mntns=4026531840\n</code></pre>"},{"location":"docs/policies/scopes/#pidns","title":"pidns","text":"<p>Events are collected from the pid namespace:</p> <pre><code>scope:\n    - pidns=4026531836\n</code></pre>"},{"location":"docs/policies/scopes/#uts","title":"uts","text":"<p>Events are collected from uts namespace:</p> <pre><code>scope:\n    - uts=ab356bc4dd554\n</code></pre>"},{"location":"docs/policies/scopes/#comm","title":"comm","text":"<p>Events are collected from process named <code>uname</code>:</p> <pre><code>scope:\n    - comm=uname\n</code></pre>"},{"location":"docs/policies/scopes/#container","title":"container","text":"<p>Events are collected only from containers:</p> <pre><code>scope:\n    - container\n</code></pre>"},{"location":"docs/policies/scopes/#not-container","title":"not-container","text":"<p>Events are collected from everything but containers:</p> <pre><code>scope:\n    - not-container\n</code></pre>"},{"location":"docs/policies/scopes/#tree","title":"tree","text":"<p>Events are collected from process tree:</p> <pre><code>scope:\n    - tree=1000\n</code></pre>"},{"location":"docs/policies/scopes/#executable-exec","title":"executable, exec","text":"<p>Events are collected from executable:</p> <pre><code>scope:\n    - executable=/usr/bin/dig\n</code></pre>"},{"location":"docs/policies/scopes/#follow","title":"follow","text":"<p>Events collected follow process children:</p> <pre><code>scope:\n    - follow\n</code></pre>"},{"location":"docs/policies/usage/cli/","title":"CLI Policy Usage","text":"<p>This section details how to use the flags in the Tracee CLI.</p>"},{"location":"docs/policies/usage/cli/#applying-tracee-polcies","title":"Applying Tracee Polcies","text":"<p>A policy file can be applied in the Tracee command using the <code>--policy</code> flag and providing a path to the location of the policy file.</p> <pre><code>tracee --policy ./policy.yml\n</code></pre>"},{"location":"docs/policies/usage/cli/#using-multiple-policies","title":"Using multiple policies","text":"<p>To specify multiple policies, users can either specify the directory, which contains all of the policies that they would like to load into Tracee, or by specifying the policies one by one.</p> <p>Through a directory:</p> <pre><code>tracee --policy ./policy-directory\n</code></pre> <p>By specifying individual policies:</p> <pre><code>tracee --policy ./policy-one.yaml --policy ./policy-two.yaml \n</code></pre>"},{"location":"docs/policies/usage/cli/#example","title":"EXAMPLE","text":"<pre><code>tracee --config ./config.yaml --policy ./policy.yaml &amp;&amp; cat /tmp/debug.json\n</code></pre>"},{"location":"docs/policies/usage/cli/#configyaml-example","title":"config.yaml (example)","text":"<pre><code>install-path: /tmp/tracee\n\n# debugging\n\nhealthz: true\nmetrics: false\npprof: false\npyroscope: false\nlisten-addr: :3366\n\n# feature flags\n\nno-containers: false\nblob-perf-buffer-size: 1024\n\n# signatures\n\nrego: []\nsignatures-dir: \"\"\n\n# features setup\n\ncapabilities:\n    bypass: false\ncache:\n    type: mem\n    size: 512\nproctree:\n    source: both\n    cache:\n        process: 8192\n        thread: 8192\n# cri:\n#     - runtime:\n#         name: docker\n#         socket: /var/run/docker.sock\n\n# logging\n\nlog:\n    level: debug\n    file: /tmp/debug.json\n    # aggregate:\n    #     enabled: true\n    #     flush-interval: 5s\n    filters:\n        out:\n            pkg:\n                - capabilities\n# output\n\noutput:\n    options:\n        none: false\n        stack-addresses: false\n        exec-env: true\n        relative-time: true\n        exec-hash: dev-inode\n        parse-arguments: true\n        parse-arguments-fds: true\n        sort-events: true\n    json:\n        files:\n            - stdout\n    forward: []\n    webhook: []\n</code></pre>"},{"location":"docs/policies/usage/cli/#policyyaml","title":"policy.yaml","text":"<pre><code>apiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n  name: signatures\n  annotations:\n    description: traces all signatures\nspec:\n  scope:\n    - global\n  rules:\n    # display security events\n    - event: stdio_over_socket\n    - event: k8s_api_connection\n    - event: aslr_inspection\n    - event: proc_mem_code_injection\n    - event: docker_abuse\n    - event: scheduled_task_mod\n    - event: ld_preload\n    - event: cgroup_notify_on_release\n    - event: default_loader_mod\n    - event: sudoers_modification\n    - event: sched_debug_recon\n    - event: system_request_key_mod\n    - event: cgroup_release_agent\n    - event: rcd_modification\n    - event: core_pattern_modification\n    - event: proc_kcore_read\n    - event: proc_mem_access\n    - event: hidden_file_created\n    - event: anti_debugging\n    - event: ptrace_code_injection\n    - event: process_vm_write_inject\n    - event: disk_mount\n    - event: dynamic_code_loading\n    - event: fileless_execution\n    - event: illegitimate_shell\n    - event: kernel_module_loading\n    - event: k8s_cert_theft\n    - event: proc_fops_hooking\n    - event: syscall_hooking\n    - event: dropped_executable\n    # tracee open by cat in /tmp/* files\n    - event: openat\n      filters:\n        - comm=cat\n        - args.pathname=/tmp*\n    # trace all container creations and removals\n    - event: container_create\n    - event: container_remove\n</code></pre>"},{"location":"docs/policies/usage/kubernetes/","title":"Kubernetes Policy Usage","text":""},{"location":"docs/policies/usage/kubernetes/#custom-resource-definition","title":"Custom Resource Definition","text":"<p>Tracee policies can be seamlessly integrated into Kubernetes using Custom Resource Definitions (CRDs). When Tracee is installed, the CRD is automatically applied, including a default policy. One can interact with Tracee policies as follows:</p> <p>To view existing Tracee policies, use the following command:</p> <pre><code>kubectl get policies.tracee.aquasec.com\n</code></pre> <p>One can manage policies using standard kubectl commands. For example, to create, update, or delete a policy:</p> <p>Create: Apply a new policy using the kubectl apply command.</p> <pre><code>kubectl apply -f your-policy.yaml\n</code></pre> <p>Update: Modify an existing policy using the kubectl edit command.</p> <pre><code>kubectl edit policies.tracee.aquasec.com &lt;policy-name&gt;\n</code></pre> <p>Delete: Remove a policy using the kubectl delete command.</p> <pre><code>kubectl delete policies.tracee.aquasec.com &lt;policy-name&gt;\n</code></pre>"},{"location":"docs/policies/usage/kubernetes/#operator","title":"Operator","text":"<p>The Tracee Kubernetes Operator is a custom controller designed to manage Tracee policies as Custom Resource Definitions (CRDs) within a Kubernetes cluster. The Tracee Kubernetes Operator continually monitors changes to Tracee policies within the cluster. When a new policy is created, modified, or deleted, the operator automatically triggers a rolling restart of the Tracee DaemonSet. This ensures that Tracee is always running with the most up-to-date policies, providing enhanced security and compliance for your applications.</p>"},{"location":"docs/policies/usage/kubernetes/#video-content","title":"Video Content","text":"<p>Tracking Kubernetes activity with eBPF and Tracee Policies </p> <p></p>"},{"location":"tutorials/additional-resources/","title":"Additional Resources","text":"<p>This page links to external resources, created by Aqua Security and the community. If you create content on Tracee, we would highly appreciate if you would contribute the link to this page.</p>"},{"location":"tutorials/additional-resources/#blog-post","title":"Blog Post","text":"<ul> <li>The Story of Tracee: The Path to Runtime Security Tool</li> <li>Detecting eBPF Malware with Tracee</li> </ul>"},{"location":"tutorials/additional-resources/#useful-videos","title":"Useful Videos","text":"<ul> <li>Tracee Livestream: Everything is an Event in Tracee</li> <li>Tracee Video Series on the Aqua Open Source YouTube channel</li> </ul> <p>Have a look at the recordings on the Aqua Open Source YouTube channel.</p>"},{"location":"tutorials/additional-resources/#conference-recording","title":"Conference recording","text":"<ul> <li>eBPF Warfare - Detecting Kernel &amp; eBPF Rootkits with Tracee</li> <li>Verifiable GitHub Actions with eBPF - Jose Donizetti, Aqua </li> <li>Tracee Features and Internals: High Throughput of eBPF Events for Execution Patterns Detections</li> <li>BlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee</li> <li>Tracee presentation at BlackHat USA 2021</li> </ul>"},{"location":"tutorials/deploy-grafana-dashboard/","title":"Access Tracee Metrics in Prometheus and Grafana","text":"<p>Tracee exposes a metrics endpoint.  This makes it possible to monitor Tracee like other cloud native workloads.</p> <p>In this tutorial, we will showcase how to access Tracee metrics through Prometheus and Grafana running through docker containers. The tutorial can easily adapted to Kubernetes workloads with the configuration provided.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#tutorial-overview","title":"Tutorial Overview","text":"<p>Grafana is a visualization tools for exported metrics and logs, most commonly used alongside Prometheus.</p> <p>Since version 0.7.0, tracee exports useful runtime metrics to Prometheus.</p> <p>By using Grafana and the new metrics from tracee, we can deploy a simple dashboard which tracks the tracee instance performance and outputs.</p> <p>There are two options for accessing Tracee metrics:</p> <ul> <li>Running the Tracee Docker Container Image -- Shown in this tutorial</li> <li>Running the Tracee Helm Chart -- Detailed as part of the Promtail-Tracee tutorial</li> </ul> <p></p>"},{"location":"tutorials/deploy-grafana-dashboard/#tracee-docker-container-image","title":"Tracee Docker Container Image","text":"<p>These metrics exports are enabled by default in all docker images and can be enabled using the <code>--metrics</code> flag.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#prerequisites","title":"Prerequisites","text":"<p>The following tools must be available for use, they can all be installed either through docker or installed/built on your machine. Note that you need to be on a Linux machine to follow the Docker tutorial. Alternative, on a MacBook it is possible to use Vagrant with Parallels as detailed in the following tutorial: Running Tracee on Mac with Parallels and Vagrant</p> <ul> <li>Tracee</li> <li>Prometheus</li> <li>Grafana</li> </ul>"},{"location":"tutorials/deploy-grafana-dashboard/#run-tracee-with-metrics-enabled-the-docker-command","title":"Run Tracee with Metrics Enabled -- The Docker Command","text":"<p>Tracee can be most easily deployed with metrics enabled by default and port forwarded through the following commands:</p> <pre><code>docker run --name tracee -it --rm \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  -v /var/run:/var/run:ro \\\n  -p 3366:3366 \\\n  aquasec/tracee:latest \\\n  --metrics \n</code></pre> <p>Of course, the forwarded metrics ports can be changed, but you should note that some of the later instructions depend on these ports.</p> <p>If running Tracee locally through built binaries, the metrics address may be overrides with the <code>--listen-addr</code> flag.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-prometheus-and-configure-it-to-scrape-tracee","title":"Run Prometheus and Configure it to Scrape Tracee","text":"<p>Install Prometheus or pull it's Docker image. Then create the following configuration file, call it <code>prometheus.yml</code> to scrape Tracee:</p> <pre><code># A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Tracee.\nscrape_configs:\n  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.\n  - job_name: 'tracee'\n\n    # Override the global default and scrape targets from this job every 5 seconds.\n    scrape_interval: 5s\n    metrics_path: /metrics\n\n    #Scrape tracee's default metrics hosts.\n    #If forwarding different ports make sure to change these addresses.\n    static_configs:\n      - targets: ['localhost:3366']\n</code></pre> <p>Note that the localhost:3366 might have to be replaced with your IP address. The IP address can be found with the following command: <pre><code>/sbin/ifconfig\n</code></pre></p> <p>We can then start Prometheus with the following command:</p> <pre><code>prometheus --config.file=/path/to/prometheus.yml\n</code></pre> <p>Or alternatively with docker:</p> <pre><code>docker run \\\n    -p 9090:9090 \\\n    -v ./prometheus.yml:/etc/prometheus/prometheus.yml \\\n    prom/prometheus\n</code></pre> <p>Ensure that prometheus can scrape the Tracee target: Open the Prometheus UI at <code>http://localhost:9090</code> Under Status &lt; Targets will be the scrape targets listed.</p> <p>If successful, move to the next step, otherwise consult with the Prometheus documentation.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-grafana-to-display-tracees-prometheus-metrics","title":"Run Grafana to display Tracee's Prometheus Metrics","text":"<p>After successfully deploying Tracee and Prometheus we may now run Grafana to visualize it's metrics.</p> <p>Install Grafana using the Grafana container image:</p> <pre><code>docker run -d -p 3000:3000 --name=grafana grafana/grafana-enterprise\n</code></pre> <p>Next, you should be able to access the Grafana UI throug: <code>http://localhost:3000</code>.</p> <p>After entering the website, logging in with username and password <code>admin</code> (and changing your password if you wish), you should see the homepage:</p> <p></p> <p>Add your data source by hovering the configuration tab (the gear icon), selecting \"Data Sources\" and pressing \"Add Data Source\" at the top left. Create a Prometheus Data Source and point it's URL to the relevant location (usually http://localhost:9090)</p> <p>Note that you might have to use your local IP address again instead of <code>localhost</code>.</p> <p>You may now either create your own Dashboard or import our default dashboard.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#import-tracees-default-dashboard","title":"Import Tracee's Default Dashboard","text":"<p>First download our Grafana Dashboard's json here.</p> <p>After adding the data source hover on the plus icon in the sidebar and select \"Import\". Press \"Upload JSON File\" at the top of the page and select the downloaded json from your file browser. Change the name and Dashboard UID if you wish and press \"Import\" to finish. </p> <p>Finally you will be redirected to the dashboard \ud83e\udd73</p>"},{"location":"tutorials/k8s-policies/","title":"Working with Tracee Policies on Kubernetes","text":""},{"location":"tutorials/k8s-policies/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following:</p> <ul> <li>A Kubernetes cluster up and running</li> <li>kubectl command-line tool installed and configured to work with your cluster</li> <li>Helm v3 or later installed on your local machine</li> </ul>"},{"location":"tutorials/k8s-policies/#install-tracee-via-helm","title":"Install Tracee via Helm","text":"<p>To install Tracee using Helm, follow these steps:</p> <p>Add the Aqua Security Helm repository:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\n</code></pre> <p>Install Tracee with the default settings:</p> <pre><code>helm install tracee aqua/tracee \\\n    --namespace tracee-system --create-namespace \\\n    --set hostPID=true\n</code></pre> <p>This command installs Tracee in the tracee-system namespace, enabling the use of the host's PID namespace.</p>"},{"location":"tutorials/k8s-policies/#add-a-new-tracee-policy","title":"Add a new Tracee policy","text":"<p>By default, Tracee comes with a policy for signature events. In this step, you will learn how to add a new policy suit your requirements.</p> <p>The <code>tracee-policies</code> configmap should have all policies tracee will load when booting. Let's take a look on the default policy:</p> <pre><code>kubectl get configmap -n tracee-system\n\nNAME               DATA   AGE\ntracee-config      1      58m\ntracee-policies    2      58m\n</code></pre> <p>Let's take a look at a look at the default policy:</p> <p><pre><code>kubectl describe configmap/tracee-policies -ntracee-system\n</code></pre> <pre><code>Name:         tracee-policies\nNamespace:    tracee-system\nData\n====\nsignatures.yaml:\n----\napiVersion: tracee.aquasec.com/v1beta1\nkind: Policy\nmetadata:\n    name: signature-events\n    annotations:\n        description: traces all signature events\nspec:\n    scope:\n      - global\n    rules:\n      - event: stdio_over_socket\n      - event: k8s_api_connection\n      - event: aslr_inspection\n      - event: proc_mem_code_injection\n      - event: docker_abuse\n      - event: scheduled_task_mod\n      - event: ld_preload\n      - event: cgroup_notify_on_release\n      - event: default_loader_mod\n      - event: sudoers_modification\n      - event: sched_debug_recon\n      - event: system_request_key_mod\n      - event: cgroup_release_agent\n      - event: rcd_modification\n      - event: core_pattern_modification\n      - event: proc_kcore_read\n      - event: proc_mem_access\n      - event: hidden_file_created\n      - event: anti_debugging\n      - event: ptrace_code_injection\n      - event: process_vm_write_inject\n      - event: disk_mount\n      - event: dynamic_code_loading\n      - event: fileless_execution\n      - event: illegitimate_shell\n      - event: kernel_module_loading\n      - event: k8s_cert_theft\n      - event: proc_fops_hooking\n      - event: syscall_hooking\n      - event: dropped_executable\n</code></pre></p> <p>But let's supposed we also need tracee to trace all <code>execve</code> events, for it we need to change the configmap <code>tracee-policies</code> adding a new policy.</p> <p>Let's edit the tracee-policies ConfigMap using kubectl:</p> <pre><code>kubectl edit cm/tracee-policies -n tracee-system\n</code></pre> <p>The ConfigMap will open in your default text editor. Locate the data section.</p> <p>To add a new policy for tracking execve events, add the following YAML block before the signatures.yaml section, maintaining proper indentation:</p> <p><pre><code>data:\n  events.yaml: |-\n    apiVersion: tracee.aquasec.com/v1beta1\n    kind: Policy\n    metadata:\n        name: execve-event\n        annotations:\n          description: traces all execve events\n    spec:\n        scope:\n          - global\n        rules:\n          - event: execve\n  signatures.yaml: |-\n  ...\n</code></pre> Save and close the file. The changes will be applied to the configmap.</p> <p>Note</p> <p>If you having a problem editing the configmap, you can apply it directly with: <pre><code>kubectl apply -f https://gist.githubusercontent.com/josedonizetti/3df19a61d39840441ea5be448d6c9354/raw/c50b9b66d7996bb27b6fac301d24d6390e356f8c/tracee-policies-configmap.yaml\n</code></pre></p> <p>Step 3: Restart Tracee Daemonset After modifying the Tracee policies, you need to restart the Tracee daemonset for the changes to take effect.</p> <p>Restart the Tracee daemonset using the following command:</p> <pre><code>kubectl rollout restart ds/tracee -n tracee-system\n</code></pre> <p>Wait for the daemonset to restart and stabilize. You can monitor the progress using the following command:</p> <pre><code>kubectl rollout status ds/tracee -n tracee-system\n</code></pre> <p>Then check for <code>execve</code> events:</p> <pre><code>kubectl logs -f ds/tracee -n tracee-system | grep execve\n</code></pre> <pre><code>{\"timestamp\":1684688250477166817,\"threadStartTime\":1684688250477064221,\"processorId\":7,\"processId\":35694,\"cgroupId\":1386180,\"threadId\":35694,\"parentProcessId\":1033,\"hostProcessId\":3242201,\"hostThreadId\":3242201,\"hostParentProcessId\":3205483,\"userId\":0,\"mountNamespace\":4026532829,\"pidNamespace\":4026532833,\"processName\":\"cri-dockerd\",\"hostName\":\"minikube\",\"container\":{},\"kubernetes\":{},\"eventId\":\"59\",\"eventName\":\"execve\",\"matchedPolicies\":[\"execve_event\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"execve\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/opt/cni/bin/bridge\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"/opt/cni/bin/bridge\"]},{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":null}]}\n</code></pre> <p>Once the daemonset is up and running, the modified policies will be applied.</p> <p>Congratulations! You have successfully installed Tracee via Helm, modified the default policies to add an <code>execve</code> event policy.</p> <p>Note: Modifying the policies may have security implications, so it is important to carefully consider the events you enable based on your specific requirements and security considerations.</p> <p>Feel free to reach out if you have any further questions or need additional assistance!</p>"},{"location":"tutorials/overview/","title":"Tutorials","text":"<p>In this section you can find step-by-step guides that help you accomplish specific tasks.</p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p> <p>If there are any specific tutorials that you would like to see please let us know on the Aqua Open Source Slack.</p>"},{"location":"tutorials/promtail/","title":"Using Promtail, Loki and Grafana to access Tracee Logs","text":"<p>By default, Tracee is emitting events to stdout. Users can then configure logging solutions to collect, store, and manage Tracee logs. </p> <p>This tutorial will showcase how to install and configure Promtail, Loki, Grafana and Prometheus to then access Tracee logs from the cluster in Grafana.</p> <p>If you prefer the video tutorial, check out the tutorial below on the Aqua Open Source YouTube channel:</p> <p>Grafana Loki to access Tracee logs    </p>"},{"location":"tutorials/promtail/#prerequisites","title":"Prerequisites","text":"<p>Please make sure to have the following tools installed in your CLI:</p> <ul> <li>Kubectl installed and connected to a Kubernetes cluster (any cluster will work for this purpose)</li> <li>The Helm CLI installed</li> </ul> <p>Additionally, you might have the following Obserability Stack already installed in your cluster, if not we will detailed how to set it up further below in this guide: </p> <ul> <li>Prometheus</li> <li>Loki and Promtail</li> <li>Grafana</li> </ul> <p>Alternatively, this tutorial showcases after the Tracee Installation section how to get an observability stack running with the above tools.</p>"},{"location":"tutorials/promtail/#installing-the-tracee-helm-chart-and-accessing-logs","title":"Installing the Tracee Helm Chart and accessing logs","text":"<p>Right now, we cannot access any logs from our cluster since we do not have any application that actively produces logs. Thus, we will install Tracee inside our cluster through the Tracee Helm Chart.</p> <p>Add the Tracee Helm Chart:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\n</code></pre> <p>Update the repository list on Helm:</p> <pre><code>helm repo update\n</code></pre> <p>Install the Tracee Helm Chart inside your Kubernetes cluster:</p> <pre><code>helm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n        --set hostPID=true\n</code></pre> <p>Now, ensure that Tracee is running inside the <code>tracee-system</code> namespace:</p> <pre><code>kubectl get all -n tracee-system\n</code></pre> <p>Similar to Promtail, also for Tracee one pod should run on each node of the Kubernetes cluster.</p>"},{"location":"tutorials/promtail/#accessing-tracee-logs","title":"Accessing Tracee Logs","text":"<p>Generally, it is possible to access logs from the Tracee pods directly through kubectl:</p> <pre><code>kubectl logs -f daemonset/tracee -n tracee-system\n</code></pre> <p>Next, open the Grafana Dashboard, on the left, go to \"Explore\". There, you should be able to select Loki as a Datasource.</p> <p>Now, you can write log queries in LogQL to access the logs that are stored in the Tracee pods:</p> <p></p>"},{"location":"tutorials/promtail/#installation-of-observability-tools","title":"Installation of Observability Tools","text":"<p>We need to install an observability stack to access the logs of the pods inside our cluster. This will consist of: - Grafana (for Dashboards and querying logs) - Promtail for collecting logs from the pods on each node - Loki, which is feeding the logs inot Grafana</p> <p>And since it is easier to install Grafana together with Prometheus, we are also going to install Prometheus.</p> <p>If you are completely new to Loki, have a look at the following presentation:  Learning the tricks of Grafana Loki for distributed logging at scale in a Kubernetes environment </p>"},{"location":"tutorials/promtail/#grafana-and-prometheus","title":"Grafana and Prometheus","text":"<p>First, we are going to install the kube-prometheus-stack chart with Prometheus and Grafana.</p> <p>For this, we will need to specify some custom values that we will pass into the Helm Chart. </p> <p>Create a new file called <code>grafana-config.yaml</code> with the following content:</p> <pre><code>prometheus:\n  prometheusSpec:\n    serviceMonitorSelectorNilUsesHelmValues: false\n    serviceMonitorSelector: {}\n    serviceMonitorNamespaceSelector: {}\n\ngrafana:\n  sidecar:\n    datasources:\n      defaultDatasourceEnabled: true\n  additionalDataSources:\n    - name: Loki\n      type: loki\n      url: http://loki-loki-distributed-query-frontend.monitoring:3100\n</code></pre> <p>Next, we can install the kube-prometheus-stack chart into our cluster with the following commands:</p> <p>Create a namespace for all the monitoring tools</p> <pre><code>kubectl create ns monitoring\n</code></pre> <p>Add the kube-prometheus-stack Helm Chart to your Helm repository list:</p> <pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\n</code></pre> <p>Ensure you have the latest version of all your repositories:</p> <pre><code>helm repo update\n</code></pre> <p>Install the kube-prometheus-stack Helm Chart:</p> <pre><code>helm upgrade --install prom prometheus-community/kube-prometheus-stack -n monitoring --values grafana-config.yaml\n</code></pre> <p>Lastly, confirm that all the pods have been created properly by querying the namespace:</p> <pre><code>kubectl get all -n monitoring\n</code></pre>"},{"location":"tutorials/promtail/#promtail-and-loki","title":"Promtail and Loki","text":"<p>Next, we need to install Promtail and Loki inside the cluster to actually access logs.</p> <p>For this, first add the Grafana Helm Chart repository to you repository list:</p> <pre><code>helm repo add grafana https://grafana.github.io/helm-charts\n</code></pre> <p>Update your Helm repository list:</p> <pre><code>helm repo update\n</code></pre> <p>Next, create a file with the Helm Chart configuration for Prometail in a promtail-config.yaml:</p> <pre><code>config:\n  serverPort: 8080\n  clients:\n    - url: http://loki-loki-distributed-gateway/loki/api/v1/push\n</code></pre> <p>Now we can install the Promtail Helm Chart inside our cluster:</p> <pre><code>helm upgrade --install promtail grafana/promtail --values promtail-config.yaml -n monitoring\n</code></pre> <p>Make sure that Promtail is running the same number of pods as there are nodes on the cluster since Promtail has to run one pod per node:</p> <pre><code>k get pods -n monitoring\n</code></pre> <p>For instance, if the cluster consists of three nodes, then there should be three Promtails pods inside of the monitoring namespace.</p> <p>Now, we can install Loki. Loki's job is to collect the logs from Promtail and forward them to Grafana.</p> <pre><code>helm upgrade --install loki grafana/loki-distributed -n monitoring\n</code></pre> <p>Loki will install a variety of components inside your cluster, so don't be alarmed by the number of pods it is starting, namely:</p> <pre><code>loki-loki-distributed-distributor-5db986bb4f-x444n\nloki-loki-distributed-query-frontend-bd6845f89-z6nx6\nloki-loki-distributed-gateway-79d4d4ff5d-sxx58\nloki-loki-distributed-querier-0\nloki-loki-distributed-ingester-0    \n</code></pre> <p>At this point, the following pods should be running inside the Kubernetes cluster:</p> <pre><code>NAME                                                     READY   STATUS    RESTARTS      AGE\nprom-prometheus-node-exporter-l4cm4                      1/1     Running   0             22m\nprom-kube-prometheus-stack-operator-84cf966ff5-96xdp     1/1     Running   0             22m\nprom-kube-state-metrics-dc769cd87-fmrsk                  1/1     Running   0             22m\nprom-grafana-6fdb45b4d5-2zxw7                            3/3     Running   0             22m\nalertmanager-prom-kube-prometheus-stack-alertmanager-0   2/2     Running   1 (22m ago)   22m\nprometheus-prom-kube-prometheus-stack-prometheus-0       2/2     Running   0             22m\npromtail-sxfl5                                           1/1     Running   0             4m7s\nloki-loki-distributed-gateway-79d4d4ff5d-sxx58           1/1     Running   0             72s\nloki-loki-distributed-distributor-5db986bb4f-x444n       1/1     Running   0             72s\nloki-loki-distributed-query-frontend-bd6845f89-z6nx6     1/1     Running   0             72s\nloki-loki-distributed-querier-0                          1/1     Running   0             72s\nloki-loki-distributed-ingester-0                         1/1     Running   0             72s\n</code></pre> <p>Since everything is running properly, we need to ensure that we can access Loki as a data source inside of Grafana.</p> <p>For this, port-forward to Grafana:</p> <pre><code>kubectl port-forward service/prom-grafana -n monitoring 3000:80\n</code></pre> <p>and open the Grafana UI on localhost:3000.</p> <p>Here, you will need the username and the password: username: admin password: prom-operator</p> <p>The password name is dependent on how you called the Helm Chart installation of the kube-prometheus-stack chart e.g. in our case, it was \"prom\".</p> <p>Now navigate on Grafana to: Explore  Here select Loki as a data source.</p>"},{"location":"tutorials/tracee-vagrant/","title":"Using the Tracee container image on MacOS with Parallels and Vagrant","text":"<p>There are a few more steps involved in running Tracee through a container image on arm64 (M1).</p> <p>Prerequisites:</p> <ul> <li>Vagrant CLI installed</li> <li>Parallels Pro installed</li> </ul> <p>First, clone the Tracee Git repository and move into the root directory:</p> <pre><code>git clone git@github.com:aquasecurity/tracee.git\n\ncd tracee\n</code></pre> <p>Next, use Vagrant to start a Parallels VM:</p> <pre><code>vagrant up\n</code></pre> <p>This will use the Vagrantfile in the root of the Tracee directory.</p> <p>Lastly, ssh into the created VM:</p> <pre><code>vagrant ssh\n</code></pre> <p>Now, it is possible to run the Tracee Container image:</p> <pre><code>docker run --name tracee -it --rm \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  -v /var/run:/var/run:ro \\\n  aquasec/tracee:latest\n</code></pre> <p>To learn how to install Tracee in a production environment, check out the Kubernetes guide.</p>"},{"location":"tutorials/verify-tracee-signature/","title":"Cosign: verify tracee signature","text":""},{"location":"tutorials/verify-tracee-signature/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following installed:</p> <ul> <li>cosign</li> </ul>"},{"location":"tutorials/verify-tracee-signature/#verify-tracee-signature","title":"Verify tracee signature","text":"<p>Tracee images are signed with cosign keyless. To verify the signature we can run the command:</p> <pre><code>cosign verify aquasec/tracee:tag-name  --certificate-oidc-issuer https://token.actions.githubusercontent.com --certificate-identity-regexp https://github.com/aquasecurity/tracee | jq\n</code></pre> <p>Note that all of the tag-names can be found on the Tracee Docker Hub Registry.</p> <p>The output should look similar to the following: </p>"}]}