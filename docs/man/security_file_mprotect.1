.\" Automatically generated by Pandoc 3.2
.\"
.TH "TRACEE\-SECURITY\-FILE\-MPROTECT" "1" "" "" "Tracee Event Manual"
.SS NAME
\f[B]security_file_mprotect\f[R] \- memory protection change security
check
.SS DESCRIPTION
Triggered when there is an attempt to change the access protection of a
memory region through the Linux Security Module (LSM) hook.
This event occurs during permissions checks for operations like
\f[CR]mprotect\f[R] or \f[CR]pkey_mprotect\f[R] system calls, capturing
attempts to modify memory access permissions.
.PP
Memory protection changes are critical security events as they can
indicate code injection, exploitation attempts, or legitimate
application behavior like JIT compilation.
The event provides detailed information about the memory addresses,
protection changes, and associated files.
.SS EVENT SETS
\f[B]lsm_hooks\f[R]
.SS DATA FIELDS
.TP
\f[B]pathname\f[R] (\f[I]string\f[R])
The path of the file associated with the memory region (if file\-backed)
.TP
\f[B]prot\f[R] (\f[I]int32\f[R])
The new access protection for the memory region (parsed to string if
parse\-arguments enabled)
.TP
\f[B]ctime\f[R] (\f[I]uint64\f[R])
The creation time of the file associated with the memory region
.TP
\f[B]prev_prot\f[R] (\f[I]int32\f[R])
The previous access protection for the memory region (parsed to string
if parse\-arguments enabled)
.TP
\f[B]addr\f[R] (\f[I]trace.Pointer\f[R])
The start of virtual memory address where protection change is requested
.TP
\f[B]len\f[R] (\f[I]uint64\f[R])
The length of the memory region to apply the new protection
.TP
\f[B]pkey\f[R] (\f[I]int32\f[R], optional)
The protection key used for the operation (only available for
\f[CR]pkey_mprotect\f[R] syscall)
.SS DEPENDENCIES
.IP \[bu] 2
\f[CR]mprotect\f[R]
.IP \[bu] 2
\f[CR]pkey_mprotect\f[R]
.SS USE CASES
.IP \[bu] 2
\f[B]Exploit detection\f[R]: Identify attempts to make data pages
executable for code injection
.IP \[bu] 2
\f[B]JIT compilation monitoring\f[R]: Track legitimate just\-in\-time
compilation activities
.IP \[bu] 2
\f[B]Memory forensics\f[R]: Analyze memory protection patterns during
incident investigation
.IP \[bu] 2
\f[B]Security auditing\f[R]: Monitor applications making unusual memory
protection changes
.IP \[bu] 2
\f[B]Malware analysis\f[R]: Identify malware attempting to modify memory
protections
.SS MEMORY PROTECTION FLAGS
Common protection flags (prot values):
.IP \[bu] 2
\f[B]PROT_NONE (0)\f[R]: No access permissions
.IP \[bu] 2
\f[B]PROT_READ (1)\f[R]: Read access
.IP \[bu] 2
\f[B]PROT_WRITE (2)\f[R]: Write access
.IP \[bu] 2
\f[B]PROT_EXEC (4)\f[R]: Execute access
.IP \[bu] 2
\f[B]Combinations\f[R]: PROT_READ|PROT_WRITE (3), PROT_READ|PROT_EXEC
(5), etc.
.SS SUSPICIOUS PATTERNS
Monitor for potentially malicious protection changes:
.IP \[bu] 2
\f[B]Making data executable\f[R]: Changing non\-executable pages to
executable (W→X, RW→RX)
.IP \[bu] 2
\f[B]Removing write protection\f[R]: Making code pages writable for
modification
.IP \[bu] 2
\f[B]Anonymous memory execution\f[R]: Making heap/stack regions
executable
.IP \[bu] 2
\f[B]Large memory operations\f[R]: Protecting unusually large memory
regions
.IP \[bu] 2
\f[B]Frequent changes\f[R]: Rapid succession of protection modifications
.SS LEGITIMATE USE CASES
Common legitimate scenarios:
.IP \[bu] 2
\f[B]JIT compilers\f[R]: Java, .NET, JavaScript engines modifying code
pages
.IP \[bu] 2
\f[B]Dynamic loaders\f[R]: Runtime library loading and symbol resolution
.IP \[bu] 2
\f[B]Garbage collectors\f[R]: Memory management in managed languages
.IP \[bu] 2
\f[B]Code generation\f[R]: Template engines and runtime code generation
.IP \[bu] 2
\f[B]Self\-modifying code\f[R]: Some legitimate applications and
libraries
.SS MEMORY REGIONS
Different memory region types:
.IP \[bu] 2
\f[B]File\-backed mappings\f[R]: Memory mapped from files (pathname
provided)
.IP \[bu] 2
\f[B]Anonymous mappings\f[R]: Heap, stack, or anonymous memory (no
pathname)
.IP \[bu] 2
\f[B]Shared mappings\f[R]: Memory shared between processes
.IP \[bu] 2
\f[B]Private mappings\f[R]: Process\-private memory regions
.SS EXPLOITATION TECHNIQUES
Memory protection changes in attacks:
.IP \[bu] 2
\f[B]Code injection\f[R]: Making injected shellcode executable
.IP \[bu] 2
\f[B]Return\-oriented programming\f[R]: Preparing ROP/JOP gadget
execution
.IP \[bu] 2
\f[B]Process hollowing\f[R]: Modifying legitimate process memory
.IP \[bu] 2
\f[B]DLL injection\f[R]: Preparing injected libraries for execution
.IP \[bu] 2
\f[B]Heap spraying\f[R]: Preparing heap memory for exploitation
.SS SECURITY IMPLICATIONS
Memory protection changes can enable:
.IP \[bu] 2
\f[B]Arbitrary code execution\f[R]: Making data regions executable
.IP \[bu] 2
\f[B]Defense evasion\f[R]: Bypassing DEP/NX bit protections
.IP \[bu] 2
\f[B]Control flow hijacking\f[R]: Preparing memory for malicious code
.IP \[bu] 2
\f[B]Information disclosure\f[R]: Modifying protections to read
sensitive data
.SS RELATED EVENTS
.IP \[bu] 2
\f[B]mprotect\f[R]: The underlying system call for memory protection
changes
.IP \[bu] 2
\f[B]pkey_mprotect\f[R]: Protection key\-based memory protection system
call
.IP \[bu] 2
\f[B]mem_prot_alert\f[R]: Custom signature for suspicious protection
changes
.IP \[bu] 2
\f[B]vma_modification\f[R]: Virtual memory area modification events
