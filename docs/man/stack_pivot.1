.\" Automatically generated by Pandoc 3.2
.\"
.TH "TRACEE\-STACK\-PIVOT" "1" "" "" "Tracee Event Manual"
.SS NAME
\f[B]stack_pivot\f[R] \- Detects syscalls invoked with a stack pointer
outside the stack region
.SS DESCRIPTION
The stack pivot event detects a technique commonly used in ROP
(Return\-Oriented Programming) exploits where the stack pointer is
manipulated to point outside the legitimate stack region.
.PP
All native code execution makes use of the stack \- a region of memory
used for storing function\-local data like parameters, return addresses,
and local variables.
A stack overflow vulnerability allows an attacker to write data past the
end of a stack\-allocated buffer, potentially overwriting other stack
data including return addresses.
.PP
In ROP exploits, the attacker overwrites return addresses to chain
together small code sequences called \[lq]gadgets\[rq].
One limitation is the amount of data that can be written to the stack \-
it may not be enough for the full sequence of gadget addresses.
The stack pivot technique overcomes this by using a gadget that changes
the stack pointer to point to an attacker\-controlled location,
effectively moving the stack and allowing a longer ROP chain.
.PP
This event detects stack pivoting by checking the stack pointer at
selected syscall invocations and identifying cases where it points
outside the original stack region.
.SS EVENT SETS
\f[B]none\f[R]
.SS DATA FIELDS
.TP
\f[B]syscall\f[R] (\f[I]int32\f[R])
The syscall which was invoked while the stack pointer was outside the
stack.
The syscall name is decoded if the \f[CR]decoded\-data\f[R] option is
specified.
This argument is also used as a parameter to select which syscalls
should be checked.
.TP
\f[B]sp\f[R] (\f[I]trace.Pointer\f[R])
The stack pointer value at the time of syscall invocation
.TP
\f[B]vma_type\f[R] (\f[I]string\f[R])
Description of the memory region type containing the stack pointer
address
.TP
\f[B]vma_start\f[R] (\f[I]trace.Pointer\f[R])
Start address of the memory region containing the stack pointer
.TP
\f[B]vma_size\f[R] (\f[I]uint64\f[R])
Size of the memory region containing the stack pointer
.TP
\f[B]vma_flags\f[R] (\f[I]uint64\f[R])
Memory region flags (decoded if \f[CR]decoded\-data\f[R] is enabled)
.SS DEPENDENCIES
\f[B]Thread Tracking:\f[R]
.IP \[bu] 2
sched_process_fork (optional) \- Used for thread stack tracking
.IP \[bu] 2
sched_process_exec (optional) \- Used for thread stack tracking
.SS USE CASES
.IP \[bu] 2
\f[B]Exploit detection\f[R]: Detect ROP exploits that use the stack
pivot technique
.IP \[bu] 2
\f[B]Security monitoring\f[R]: Monitor for suspicious stack pointer
manipulation
.IP \[bu] 2
\f[B]Memory analysis\f[R]: Identify potential memory corruption exploits
.SS IMPLEMENTATION NOTES
The kernel manages the stack for each process\[cq]s main thread, but
additional threads must create and manage their own stacks.
Since the kernel has no direct notion of thread stacks, Tracee tracks
thread stacks by storing the memory region pointed to by the stack
pointer when new threads are created.
.PP
Limitations:
.IP \[bu] 2
Threads created before Tracee starts are not tracked
.IP \[bu] 2
For untracked threads, anonymous memory regions are ignored to avoid
false positives
.IP \[bu] 2
This may result in false negatives for legitimate thread stacks created
before Tracee started
.SS EXAMPLE USAGE
Monitor specific syscalls for stack pivoting:
.IP
.EX
tracee \-\-events stack_pivot.args.syscall=open,openat
.EE
.SS RELATED EVENTS
.IP \[bu] 2
\f[B]mem_prot_alert\f[R]: Memory protection alerts
.IP \[bu] 2
\f[B]proc_mem_code_injection\f[R]: Process memory code injection
.IP \[bu] 2
\f[B]process_vm_write_code_injection\f[R]: Process VM write code
injection
.IP \[bu] 2
\f[B]ptrace_code_injection\f[R]: Ptrace\-based code injection
