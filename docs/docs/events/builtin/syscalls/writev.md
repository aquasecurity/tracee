
# writev

## Intro
writev - atomically write data from multiple buffers to a file descriptor

## Description
The `writev()` system call writes data from multiple buffers, as specified by `iov`
into a file descriptor `fd`. The number of buffers to write is given in `iovcnt`.
The `iov` is a pointer to a list of `struct iovec`s, which define multiple non-contiguous
buffers. Each `struct iovec` contains a starting address and length of a data
buffer. `writev()` atomicly writes all of the data in the given buffers. If all
the buffers are written then the `writev()` system call returns the total number
of bytes written to the file descriptor `fd`. 

## Arguments
* `fd`:`int`[K] - A file descriptor that identifies the file into which `writev()`
will write data.
* `iov`:`const struct iovec*`[K,U] - A pointer to the `struct iovec` that defines 
the multiple non-contiguous buffers.
* `iovcnt`:`int`[OPT,K] - The number of buffers to write, as specified by `iov`.

### Available Tags
* K - Originated from kernel-space.
* U - Originated from user space (for example, pointer to user space memory used to get it)
* OPT - Optional argument - might not always be available (passed with null value)

## Hooks
### sys_writev
#### Type
kprobes
#### Purpose
Hooked to trace the sys_writev syscall.

## Example Use Case
`writev()` is often used when writing to a socket. For example, when sending
data to a web server the data is usually split into multiple chunks and `writev()`
is used to write the data in a single operation, atomically.

## Issues
There are no known issues with the `writev()` system call.

## Related Events
* readv

> This document was automatically generated by OpenAI and needs review. It might
> not be accurate and might contain errors. The authors of Tracee recommend that
> the user reads the "events.go" source file to understand the events and their
> arguments better.
