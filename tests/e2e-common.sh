#!/bin/bash

#
# e2e-common.sh - Common library for E2E tests
#
# This file provides shared functions for E2E tests.
#

# Source the main library for logging and utilities
__LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../scripts" && pwd)"
# shellcheck disable=SC1091
. "${__LIB_DIR}/lib.sh"

# ==============================================================================
# Test Configuration Helpers
# ==============================================================================

# Add a test configuration entry to the map
# Usage: add_test_config <config_map_name> <test_name> <policy_name> <timeout> <sleep>
# Arguments:
#   config_map_name - Name of associative array variable
#   test_name - Test identifier (e.g., "VFS_WRITE")
#   policy_name - Policy name for the test
#   timeout - Test timeout in seconds
#   sleep - Internal sleep duration in seconds
add_test_config() {
    local -n config_map="$1"
    local test_name="$2"
    local policy_name="$3"
    local timeout="$4"
    local sleep="$5"
    
    config_map["$test_name"]="${policy_name}:${timeout}:${sleep}"
}

# Extract policy name from test configuration map
# Usage: get_policy_name <config_map_name> <test_name>
# Arguments:
#   config_map_name - Name of associative array variable (not the value)
#   test_name - Test name key to lookup
# Map format: "policy:timeout:sleep"
get_policy_name() {
    # shellcheck disable=SC2178  # nameref to associative array is intentional
    local -n config_map="$1"
    local test_name="$2"
    local policy_name
    
    if [[ -z "${config_map[$test_name]:-}" ]]; then
        error "Test '${test_name}' is not configured in TEST_CONFIG_MAP"
        return 1
    fi
    
    policy_name=$(echo "${config_map[$test_name]}" | cut -d: -f1)
    echo "${policy_name}"
}

# Extract timeout from test configuration map
# Usage: get_test_timeout <config_map_name> <test_name>
get_test_timeout() {
    # shellcheck disable=SC2178  # nameref to associative array is intentional
    local -n config_map="$1"
    local test_name="$2"
    local timeout
    
    if [[ -z "${config_map[$test_name]:-}" ]]; then
        error "Test '${test_name}' is not configured in TEST_CONFIG_MAP"
        return 1
    fi
    
    timeout=$(echo "${config_map[$test_name]}" | cut -d: -f2)
    echo "${timeout}"
}

# Extract sleep duration from test configuration map
# Usage: get_test_sleep <config_map_name> <test_name>
get_test_sleep() {
    # shellcheck disable=SC2178  # nameref to associative array is intentional
    local -n config_map="$1"
    local test_name="$2"
    local sleep_time
    
    if [[ -z "${config_map[$test_name]:-}" ]]; then
        error "Test '${test_name}' is not configured in TEST_CONFIG_MAP"
        return 1
    fi
    
    sleep_time=$(echo "${config_map[$test_name]}" | cut -d: -f3)
    echo "${sleep_time}"
}

# ==============================================================================
# Output Formatting Functions (using lib.sh print functions)
# ==============================================================================

# Print test separator (used to separate individual tests within a section)
# Usage: print_test_separator
print_test_separator() {
    print_separator '-' 80
    info
}

# Print major section banner with top and bottom borders
# Usage: print_major_section <section_name>
print_major_section() {
    local section_name="$1"
    print_section_banner "${section_name}" "=" 80
    info
}

# Print test header with formatting
# Usage: print_test_header <test_name> [action]
print_test_header() {
    local test_name="$1"
    local action="${2:-}"
    local header_text

    if [[ -z "$action" ]]; then
        # main section headers - use banner for major sections
        print_major_section "${test_name}"
    else
        # individual test headers
        header_text="${action} TEST: ${test_name}"
        print_section_header "${header_text}" "=" 80
        info
    fi
}

# ==============================================================================
# Log Analysis Functions
# ==============================================================================

# Filter and show only WARN, ERROR, FATAL log levels
# Usage: filter_critical_logs <logfile>
filter_critical_logs() {
    local logfile="$1"
    if [[ -f "${logfile}" ]]; then
        grep -E "(WARN|ERROR|FATAL)" "${logfile}" || echo "No WARN, ERROR, or FATAL logs found"
    else
        error "Log file not found: ${logfile}"
    fi
}

# ==============================================================================
# Event Analysis Functions (JQ Helpers)
# ==============================================================================

# Get count of events matching a specific event name and policy
# Usage: get_event_match_count <outputfile> <event_name> <policy_name>
# Returns: Integer count of matching events
get_event_match_count() {
    local outputfile="$1"
    local event_name="$2"
    local policy_name="$3"

    jq -s \
        --arg event "${event_name}" \
        --arg policy "${policy_name}" \
        '
        [.[] | 
         select(.eventName == $event and (.matchedPolicies[]? == $policy))
        ] | length
        ' \
        "${outputfile}"
}

# Get events that matched multiple policies
# Usage: get_multi_policy_matches <outputfile> <event_name> <policy_name>
# Returns: Formatted string with timestamp, event, and policies
get_multi_policy_matches() {
    local outputfile="$1"
    local event_name="$2"
    local policy_name="$3"

    jq -s \
        --arg event "${event_name}" \
        --arg policy "${policy_name}" \
        -r \
        '
        [.[] | 
         select(.eventName == $event and 
                (.matchedPolicies[]? == $policy) and 
                (.matchedPolicies | length > 1))
        ] |
        .[] | "  Timestamp: \(.timestamp) | Event: \(.eventName) | Policies: \(.matchedPolicies | join(", "))"
        ' \
        "${outputfile}"
}

# Check and report multi-policy matches
# Usage: check_multi_policy_matches <outputfile> <event_name> <policy_name>
check_multi_policy_matches() {
    local outputfile="$1"
    local event_name="$2"
    local policy_name="$3"

    local multi_policy_output
    multi_policy_output=$(get_multi_policy_matches "${outputfile}" "${event_name}" "${policy_name}")

    if [[ -n "${multi_policy_output}" ]]; then
        local multi_policy_count
        multi_policy_count=$(echo "${multi_policy_output}" | wc -l)
        info "Found ${multi_policy_count} events that matched multiple policies:"
        while IFS= read -r line; do
            info "${line}"
        done <<< "${multi_policy_output}"
    fi
}

# ==============================================================================
# Test Artifact Management
# ==============================================================================

# Cleanup or preserve test artifact files based on flag
# Usage: cleanup_test_artifact_files <keep_artifacts> <file1> [file2] [file3] ...
# Arguments:
#   keep_artifacts - 0 to delete files, 1 to preserve
#   files - One or more file paths to cleanup/preserve
cleanup_test_artifact_files() {
    local keep_artifacts="$1"
    shift
    local files=("$@")

    if [[ ${keep_artifacts} -eq 1 ]]; then
        info "Test artifacts preserved:"
    fi

    for file in "${files[@]}"; do
        if [[ ${keep_artifacts} -eq 0 ]]; then
            rm -f "${file}"
        elif [[ -f "${file}" ]]; then
            info "  ${file}"
        fi
    done
}
